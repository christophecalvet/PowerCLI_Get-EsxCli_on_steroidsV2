function add-EsxCLI.device{
<#
.SYNOPSIS
Add a device to enable a software device driver.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER deviceidentifier
Device identifier from the device specification for the software device driver. Valid input is in reverse domain name format (e.g. com.company.device).

.PARAMETER instanceaddress
Unique number to address this instance of the device, if multiple instances of the same device identifier are added. Valid values are integer in the range 0-31. Default is 0.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$deviceidentifier,
	[long]$instanceaddress,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.device.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.device.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.device.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.device.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('deviceidentifier')){
					if($HashTable.containskey('deviceidentifier')){
						$HashTable.deviceidentifier = $deviceidentifier
					}
					Else{
						Write-error "The parameter deviceidentifier is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('instanceaddress')){
					if($HashTable.containskey('instanceaddress')){
						$HashTable.instanceaddress = $instanceaddress
					}
					Else{
						Write-error "The parameter instanceaddress is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.device.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('deviceidentifier') -or $PSBoundParameters.ContainsKey('instanceaddress')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.device.add.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.device.alias{
<#
.SYNOPSIS
Display hardware location info for a device alias.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER alias
Alias to lookup

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$alias,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.device.alias.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.device.alias.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.device.alias.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.device.alias.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('alias')){
					if($HashTable.containskey('alias')){
						$HashTable.alias = $alias
					}
					Else{
						Write-error "The parameter alias is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.device.alias.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('alias')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.device.alias.get.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.device.alias{
<#
.SYNOPSIS
List device aliases.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.device.alias.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.device.alias.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.device.alias.list.invoke()
		}
	}
}

function get-EsxCLI.elxnet.dbgmask{
<#
.SYNOPSIS
Gets Debug Mask of an elxnet nic

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER pcidevname
PCI SBDF address for an elxnet NIC. The address can be found in the "PCI Device" column of the `esxcli network nic list' command.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$pcidevname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.elxnet.dbgmask.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.elxnet.dbgmask.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.elxnet.dbgmask.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.elxnet.dbgmask.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('pcidevname')){
					if($HashTable.containskey('pcidevname')){
						$HashTable.pcidevname = $pcidevname
					}
					Else{
						Write-error "The parameter pcidevname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.elxnet.dbgmask.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('pcidevname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.elxnet.dbgmask.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.elxnet.dbgmask{
<#
.SYNOPSIS
Sets Debug Mask of an elxnet nic

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER mask
DebugMask value in 8 digit Hex (Ex: 0x00000101), DRIVER: 0x1, UPLINK: 0x2, QUEUE: 0x4, INTR: 0x8, MCC: 0x10, TX: 0x20, RX: 0x40, MGMT: 0x80, WORKER: 0x100, SRIOV: 0x200, EVENT: 0x400, VLAN: 0x800, VXLAN: 0x1000

.PARAMETER pcidevname
PCI SBDF address for an elxnet NIC. The address can be found in the "PCI Device" column of the `esxcli network nic list' command.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$pcidevname,
	[Parameter(Mandatory=$true)]
	[string]$mask,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.elxnet.dbgmask.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.elxnet.dbgmask.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.elxnet.dbgmask.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.elxnet.dbgmask.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('pcidevname')){
					if($HashTable.containskey('pcidevname')){
						$HashTable.pcidevname = $pcidevname
					}
					Else{
						Write-error "The parameter pcidevname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('mask')){
					if($HashTable.containskey('mask')){
						$HashTable.mask = $mask
					}
					Else{
						Write-error "The parameter mask is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.elxnet.dbgmask.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('pcidevname') -or $PSBoundParameters.ContainsKey('mask')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.elxnet.dbgmask.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.elxnet.regdump{
<#
.SYNOPSIS
Gets regdump (FAT dump) of an elxnet nic

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER filepath
Absolute file path (must begin with "/") to copy register dump. File will be generated on the target ESXi machine in case of remote esxcli invocations.

.PARAMETER pcidevname
PCI SBDF address for an elxnet NIC. The address can be found in the "PCI Device" column of the `esxcli network nic list' command.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$pcidevname,
	[Parameter(Mandatory=$true)]
	[string]$filepath,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.elxnet.regdump.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.elxnet.regdump.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.elxnet.regdump.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.elxnet.regdump.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('pcidevname')){
					if($HashTable.containskey('pcidevname')){
						$HashTable.pcidevname = $pcidevname
					}
					Else{
						Write-error "The parameter pcidevname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('filepath')){
					if($HashTable.containskey('filepath')){
						$HashTable.filepath = $filepath
					}
					Else{
						Write-error "The parameter filepath is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.elxnet.regdump.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('pcidevname') -or $PSBoundParameters.ContainsKey('filepath')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.elxnet.regdump.get.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.elxnet.stats{
<#
.SYNOPSIS
Displays private stats of an elxnet nic

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER pcidevname
PCI SBDF address for an elxnet NIC. The address can be found in the "PCI Device" column of the `esxcli network nic list' command.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$pcidevname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.elxnet.stats.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.elxnet.stats.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.elxnet.stats.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.elxnet.stats.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('pcidevname')){
					if($HashTable.containskey('pcidevname')){
						$HashTable.pcidevname = $pcidevname
					}
					Else{
						Write-error "The parameter pcidevname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.elxnet.stats.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('pcidevname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.elxnet.stats.get.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.elxnet.vib{
<#
.SYNOPSIS
Displays the name of the VIB that provided this esxcli plugin

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.elxnet.vib.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.elxnet.vib.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.elxnet.vib.get.invoke()
		}
	}
}

function list-EsxCLI.esxcli.command{
<#
.SYNOPSIS
This command will list all of the esxcli commands with their namespace, object, command name and description.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.esxcli.command.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.esxcli.command.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.esxcli.command.list.invoke()
		}
	}
}

function list-EsxCLI.fcoe.adapter{
<#
.SYNOPSIS
List FCOE-capable CNA devices.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.fcoe.adapter.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.fcoe.adapter.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.fcoe.adapter.list.invoke()
		}
	}
}

function disable-EsxCLI.fcoe.nic{
<#
.SYNOPSIS
Disable rediscovery of FCOE storage on behalf of an FCOE-capable CNA upon next boot.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER nicname
The CNA adapter name (vmnicX)

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$nicname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.fcoe.nic.disable){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.fcoe.nic.disable is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.fcoe.nic.disable | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.fcoe.nic.disable.CreateArgs()
				if($PSBoundParameters.ContainsKey('nicname')){
					if($HashTable.containskey('nicname')){
						$HashTable.nicname = $nicname
					}
					Else{
						Write-error "The parameter nicname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.fcoe.nic.disable.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('nicname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.fcoe.nic.disable.invoke()
				}
			}
		}
	}
}

function discover-EsxCLI.fcoe.nic{
<#
.SYNOPSIS
Initiate FCOE adapter discovery on behalf of an FCOE-capable CNA.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER nicname
The CNA adapter name (vmnicX)

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$nicname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.fcoe.nic.discover){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.fcoe.nic.discover is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.fcoe.nic.discover | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.fcoe.nic.discover.CreateArgs()
				if($PSBoundParameters.ContainsKey('nicname')){
					if($HashTable.containskey('nicname')){
						$HashTable.nicname = $nicname
					}
					Else{
						Write-error "The parameter nicname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.fcoe.nic.discover.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('nicname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.fcoe.nic.discover.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.fcoe.nic{
<#
.SYNOPSIS
List FCOE-capable CNA devices.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.fcoe.nic.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.fcoe.nic.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.fcoe.nic.list.invoke()
		}
	}
}

function set-EsxCLI.fcoe.nic{
<#
.SYNOPSIS
Set options on FCOE-capable CNA.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER enablevn2vn
Enable or Disable VN2VN mode on the nic (Reboot Required)

.PARAMETER nicname
The CNA adapter name (vmnicX)

.PARAMETER vlanid
The VLAN id for this nic, range '0 - 4095'(Reboot Required)

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$nicname,
	[boolean]$enablevn2vn,
	[long]$vlanid,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.fcoe.nic.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.fcoe.nic.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.fcoe.nic.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.fcoe.nic.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('nicname')){
					if($HashTable.containskey('nicname')){
						$HashTable.nicname = $nicname
					}
					Else{
						Write-error "The parameter nicname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('enablevn2vn')){
					if($HashTable.containskey('enablevn2vn')){
						$HashTable.enablevn2vn = $enablevn2vn
					}
					Else{
						Write-error "The parameter enablevn2vn is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vlanid')){
					if($HashTable.containskey('vlanid')){
						$HashTable.vlanid = $vlanid
					}
					Else{
						Write-error "The parameter vlanid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.fcoe.nic.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('nicname') -or $PSBoundParameters.ContainsKey('enablevn2vn') -or $PSBoundParameters.ContainsKey('vlanid')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.fcoe.nic.set.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.graphics.device{
<#
.SYNOPSIS
List all of the graphics devices on this host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.graphics.device.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.graphics.device.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.graphics.device.list.invoke()
		}
	}
}

function list-EsxCLI.graphics.vm{
<#
.SYNOPSIS
List active VMs associated with graphics devices.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.graphics.vm.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.graphics.vm.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.graphics.vm.list.invoke()
		}
	}
}

function list-EsxCLI.hardware.bootdevice{
<#
.SYNOPSIS
List the boot device order, if available, for this host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.hardware.bootdevice.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.hardware.bootdevice.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.hardware.bootdevice.list.invoke()
		}
	}
}

function get-EsxCLI.hardware.clock{
<#
.SYNOPSIS
Disply the current hardware clock time.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.hardware.clock.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.hardware.clock.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.hardware.clock.get.invoke()
		}
	}
}

function set-EsxCLI.hardware.clock{
<#
.SYNOPSIS
Set the hardware clock time. Any missing parameters will default to the current time.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER day
Day

.PARAMETER hour
Hour

.PARAMETER min
Minute

.PARAMETER month
Month

.PARAMETER sec
Second

.PARAMETER year
Year

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[long]$hour,
	[long]$min,
	[long]$month,
	[long]$year,
	[long]$sec,
	[long]$day,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.hardware.clock.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.hardware.clock.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.hardware.clock.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.hardware.clock.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('hour')){
					if($HashTable.containskey('hour')){
						$HashTable.hour = $hour
					}
					Else{
						Write-error "The parameter hour is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('min')){
					if($HashTable.containskey('min')){
						$HashTable.min = $min
					}
					Else{
						Write-error "The parameter min is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('month')){
					if($HashTable.containskey('month')){
						$HashTable.month = $month
					}
					Else{
						Write-error "The parameter month is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('year')){
					if($HashTable.containskey('year')){
						$HashTable.year = $year
					}
					Else{
						Write-error "The parameter year is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('sec')){
					if($HashTable.containskey('sec')){
						$HashTable.sec = $sec
					}
					Else{
						Write-error "The parameter sec is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('day')){
					if($HashTable.containskey('day')){
						$HashTable.day = $day
					}
					Else{
						Write-error "The parameter day is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.hardware.clock.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('hour') -or $PSBoundParameters.ContainsKey('min') -or $PSBoundParameters.ContainsKey('month') -or $PSBoundParameters.ContainsKey('year') -or $PSBoundParameters.ContainsKey('sec') -or $PSBoundParameters.ContainsKey('day')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.hardware.clock.set.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.hardware.cpu{
<#
.SYNOPSIS
List all of the CPUs on this host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.hardware.cpu.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.hardware.cpu.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.hardware.cpu.list.invoke()
		}
	}
}

function get-EsxCLI.hardware.cpu.cpuid{
<#
.SYNOPSIS
Get CPUID fields for the given CPU.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER cpu
The ID of the CPU to query for CPUID data

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[long]$cpu,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.hardware.cpu.cpuid.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.hardware.cpu.cpuid.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.hardware.cpu.cpuid.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.hardware.cpu.cpuid.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('cpu')){
					if($HashTable.containskey('cpu')){
						$HashTable.cpu = $cpu
					}
					Else{
						Write-error "The parameter cpu is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.hardware.cpu.cpuid.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('cpu')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.hardware.cpu.cpuid.get.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.hardware.cpu.global{
<#
.SYNOPSIS
Get properties that are global to all CPUs.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.hardware.cpu.global.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.hardware.cpu.global.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.hardware.cpu.global.get.invoke()
		}
	}
}

function set-EsxCLI.hardware.cpu.global{
<#
.SYNOPSIS
Set properties that are global to all CPUs.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER hyperthreading
Enable or disable hyperthreading

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[boolean]$hyperthreading,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.hardware.cpu.global.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.hardware.cpu.global.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.hardware.cpu.global.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.hardware.cpu.global.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('hyperthreading')){
					if($HashTable.containskey('hyperthreading')){
						$HashTable.hyperthreading = $hyperthreading
					}
					Else{
						Write-error "The parameter hyperthreading is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.hardware.cpu.global.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('hyperthreading')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.hardware.cpu.global.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.hardware.ipmi.fru{
<#
.SYNOPSIS
Get IPMI Field Replaceable Unit (FRU) device details.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER ignoremissing
Do not fail command if ipmi device is not present

.PARAMETER includeprettyraw
Include a hex dump where each byte is separated by a space and its value is presented with two hexidecimal characters using a leading zero if needed

.PARAMETER includeraw
Include a hex dump where the value of each byte is presented as hexidecimal characters joined without spaces

.PARAMETER node
Specify which IPMI device (0..3) to query, defaults to 'all' for all ipmi nodes

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$node,
	[boolean]$includeraw,
	[boolean]$ignoremissing,
	[boolean]$includeprettyraw,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.hardware.ipmi.fru.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.hardware.ipmi.fru.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.hardware.ipmi.fru.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.hardware.ipmi.fru.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('node')){
					if($HashTable.containskey('node')){
						$HashTable.node = $node
					}
					Else{
						Write-error "The parameter node is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('includeraw')){
					if($HashTable.containskey('includeraw')){
						$HashTable.includeraw = $includeraw
					}
					Else{
						Write-error "The parameter includeraw is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ignoremissing')){
					if($HashTable.containskey('ignoremissing')){
						$HashTable.ignoremissing = $ignoremissing
					}
					Else{
						Write-error "The parameter ignoremissing is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('includeprettyraw')){
					if($HashTable.containskey('includeprettyraw')){
						$HashTable.includeprettyraw = $includeprettyraw
					}
					Else{
						Write-error "The parameter includeprettyraw is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.hardware.ipmi.fru.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('node') -or $PSBoundParameters.ContainsKey('includeraw') -or $PSBoundParameters.ContainsKey('ignoremissing') -or $PSBoundParameters.ContainsKey('includeprettyraw')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.hardware.ipmi.fru.get.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.hardware.ipmi.fru{
<#
.SYNOPSIS
List IPMI Field Replaceable Unit (FRU) inventory.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER ignoremissing
Do not fail command if ipmi device is not present

.PARAMETER includeprettyraw
Include a hex dump where each byte is separated by a space and its value is presented with two hexidecimal characters using a leading zero if needed

.PARAMETER includeraw
Include a hex dump where the value of each byte is presented as hexidecimal characters joined without spaces

.PARAMETER node
Specify which IPMI device (0..3) to query, defaults to 'all' for all ipmi nodes

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$node,
	[boolean]$includeraw,
	[boolean]$ignoremissing,
	[boolean]$includeprettyraw,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.hardware.ipmi.fru.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.hardware.ipmi.fru.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.hardware.ipmi.fru.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.hardware.ipmi.fru.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('node')){
					if($HashTable.containskey('node')){
						$HashTable.node = $node
					}
					Else{
						Write-error "The parameter node is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('includeraw')){
					if($HashTable.containskey('includeraw')){
						$HashTable.includeraw = $includeraw
					}
					Else{
						Write-error "The parameter includeraw is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ignoremissing')){
					if($HashTable.containskey('ignoremissing')){
						$HashTable.ignoremissing = $ignoremissing
					}
					Else{
						Write-error "The parameter ignoremissing is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('includeprettyraw')){
					if($HashTable.containskey('includeprettyraw')){
						$HashTable.includeprettyraw = $includeprettyraw
					}
					Else{
						Write-error "The parameter includeprettyraw is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.hardware.ipmi.fru.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('node') -or $PSBoundParameters.ContainsKey('includeraw') -or $PSBoundParameters.ContainsKey('ignoremissing') -or $PSBoundParameters.ContainsKey('includeprettyraw')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.hardware.ipmi.fru.list.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.hardware.ipmi.sdr{
<#
.SYNOPSIS
Get IPMI Sensor Data Repository (SDR) properties.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER ignoremissing
Do not fail command if ipmi device is not present

.PARAMETER includeprettyraw
Include a hex dump where each byte is separated by a space and its value is presented with two hexidecimal characters using a leading zero if needed

.PARAMETER includeraw
Include a hex dump where the value of each byte is presented as hexidecimal characters joined without spaces

.PARAMETER node
Specify which IPMI device (0..3) to query, defaults to 'all' for all ipmi nodes

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$node,
	[boolean]$includeraw,
	[boolean]$ignoremissing,
	[boolean]$includeprettyraw,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.hardware.ipmi.sdr.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.hardware.ipmi.sdr.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.hardware.ipmi.sdr.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.hardware.ipmi.sdr.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('node')){
					if($HashTable.containskey('node')){
						$HashTable.node = $node
					}
					Else{
						Write-error "The parameter node is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('includeraw')){
					if($HashTable.containskey('includeraw')){
						$HashTable.includeraw = $includeraw
					}
					Else{
						Write-error "The parameter includeraw is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ignoremissing')){
					if($HashTable.containskey('ignoremissing')){
						$HashTable.ignoremissing = $ignoremissing
					}
					Else{
						Write-error "The parameter ignoremissing is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('includeprettyraw')){
					if($HashTable.containskey('includeprettyraw')){
						$HashTable.includeprettyraw = $includeprettyraw
					}
					Else{
						Write-error "The parameter includeprettyraw is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.hardware.ipmi.sdr.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('node') -or $PSBoundParameters.ContainsKey('includeraw') -or $PSBoundParameters.ContainsKey('ignoremissing') -or $PSBoundParameters.ContainsKey('includeprettyraw')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.hardware.ipmi.sdr.get.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.hardware.ipmi.sdr{
<#
.SYNOPSIS
List IPMI Sensor Data Repository.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER formatter
Override the formatter to use for a given command. Available formatter: simple ,table

.PARAMETER ignoremissing
Do not fail command if ipmi device is not present

.PARAMETER includeprettyraw
Include a hex dump where each byte is separated by a space and its value is presented with two hexidecimal characters using a leading zero if needed

.PARAMETER includeraw
Include a hex dump where the value of each byte is presented as hexidecimal characters joined without spaces

.PARAMETER node
Specify which IPMI device (0..3) to query, defaults to 'all' for all ipmi nodes

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$node,
	[boolean]$includeprettyraw,
	[boolean]$ignoremissing,
	[string]$formatter,
	[boolean]$includeraw,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.hardware.ipmi.sdr.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.hardware.ipmi.sdr.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.hardware.ipmi.sdr.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.hardware.ipmi.sdr.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('node')){
					if($HashTable.containskey('node')){
						$HashTable.node = $node
					}
					Else{
						Write-error "The parameter node is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('includeprettyraw')){
					if($HashTable.containskey('includeprettyraw')){
						$HashTable.includeprettyraw = $includeprettyraw
					}
					Else{
						Write-error "The parameter includeprettyraw is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ignoremissing')){
					if($HashTable.containskey('ignoremissing')){
						$HashTable.ignoremissing = $ignoremissing
					}
					Else{
						Write-error "The parameter ignoremissing is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('formatter')){
					if($HashTable.containskey('formatter')){
						$HashTable.formatter = $formatter
					}
					Else{
						Write-error "The parameter formatter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('includeraw')){
					if($HashTable.containskey('includeraw')){
						$HashTable.includeraw = $includeraw
					}
					Else{
						Write-error "The parameter includeraw is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.hardware.ipmi.sdr.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('node') -or $PSBoundParameters.ContainsKey('includeprettyraw') -or $PSBoundParameters.ContainsKey('ignoremissing') -or $PSBoundParameters.ContainsKey('formatter') -or $PSBoundParameters.ContainsKey('includeraw')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.hardware.ipmi.sdr.list.invoke()
				}
			}
		}
	}
}

function clear-EsxCLI.hardware.ipmi.sel{
<#
.SYNOPSIS
Clear IPMI System Event Log.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER ignoremissing
Do not fail command if ipmi device is not present

.PARAMETER includeprettyraw
Include a hex dump where each byte is separated by a space and its value is presented with two hexidecimal characters using a leading zero if needed

.PARAMETER includeraw
Include a hex dump where the value of each byte is presented as hexidecimal characters joined without spaces

.PARAMETER node
Specify which IPMI device (0..3) to query, defaults to 'all' for all ipmi nodes

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$node,
	[boolean]$includeraw,
	[boolean]$ignoremissing,
	[boolean]$includeprettyraw,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.hardware.ipmi.sel.clear){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.hardware.ipmi.sel.clear is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.hardware.ipmi.sel.clear | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.hardware.ipmi.sel.clear.CreateArgs()
				if($PSBoundParameters.ContainsKey('node')){
					if($HashTable.containskey('node')){
						$HashTable.node = $node
					}
					Else{
						Write-error "The parameter node is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('includeraw')){
					if($HashTable.containskey('includeraw')){
						$HashTable.includeraw = $includeraw
					}
					Else{
						Write-error "The parameter includeraw is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ignoremissing')){
					if($HashTable.containskey('ignoremissing')){
						$HashTable.ignoremissing = $ignoremissing
					}
					Else{
						Write-error "The parameter ignoremissing is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('includeprettyraw')){
					if($HashTable.containskey('includeprettyraw')){
						$HashTable.includeprettyraw = $includeprettyraw
					}
					Else{
						Write-error "The parameter includeprettyraw is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.hardware.ipmi.sel.clear.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('node') -or $PSBoundParameters.ContainsKey('includeraw') -or $PSBoundParameters.ContainsKey('ignoremissing') -or $PSBoundParameters.ContainsKey('includeprettyraw')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.hardware.ipmi.sel.clear.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.hardware.ipmi.sel{
<#
.SYNOPSIS
Get IPMI System Event Log (SEL) properties.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER ignoremissing
Do not fail command if ipmi device is not present

.PARAMETER includeprettyraw
Include a hex dump where each byte is separated by a space and its value is presented with two hexidecimal characters using a leading zero if needed

.PARAMETER includeraw
Include a hex dump where the value of each byte is presented as hexidecimal characters joined without spaces

.PARAMETER node
Specify which IPMI device (0..3) to query, defaults to 'all' for all ipmi nodes

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$node,
	[boolean]$includeraw,
	[boolean]$ignoremissing,
	[boolean]$includeprettyraw,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.hardware.ipmi.sel.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.hardware.ipmi.sel.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.hardware.ipmi.sel.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.hardware.ipmi.sel.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('node')){
					if($HashTable.containskey('node')){
						$HashTable.node = $node
					}
					Else{
						Write-error "The parameter node is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('includeraw')){
					if($HashTable.containskey('includeraw')){
						$HashTable.includeraw = $includeraw
					}
					Else{
						Write-error "The parameter includeraw is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ignoremissing')){
					if($HashTable.containskey('ignoremissing')){
						$HashTable.ignoremissing = $ignoremissing
					}
					Else{
						Write-error "The parameter ignoremissing is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('includeprettyraw')){
					if($HashTable.containskey('includeprettyraw')){
						$HashTable.includeprettyraw = $includeprettyraw
					}
					Else{
						Write-error "The parameter includeprettyraw is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.hardware.ipmi.sel.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('node') -or $PSBoundParameters.ContainsKey('includeraw') -or $PSBoundParameters.ContainsKey('ignoremissing') -or $PSBoundParameters.ContainsKey('includeprettyraw')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.hardware.ipmi.sel.get.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.hardware.ipmi.sel{
<#
.SYNOPSIS
List IPMI System Event Log.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER ignoremissing
Do not fail command if ipmi device is not present

.PARAMETER includeprettyraw
Include a hex dump where each byte is separated by a space and its value is presented with two hexidecimal characters using a leading zero if needed

.PARAMETER includeraw
Include a hex dump where the value of each byte is presented as hexidecimal characters joined without spaces

.PARAMETER node
Specify which IPMI device (0..3) to query, defaults to 'all' for all ipmi nodes

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$node,
	[boolean]$includeraw,
	[boolean]$ignoremissing,
	[boolean]$includeprettyraw,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.hardware.ipmi.sel.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.hardware.ipmi.sel.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.hardware.ipmi.sel.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.hardware.ipmi.sel.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('node')){
					if($HashTable.containskey('node')){
						$HashTable.node = $node
					}
					Else{
						Write-error "The parameter node is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('includeraw')){
					if($HashTable.containskey('includeraw')){
						$HashTable.includeraw = $includeraw
					}
					Else{
						Write-error "The parameter includeraw is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ignoremissing')){
					if($HashTable.containskey('ignoremissing')){
						$HashTable.ignoremissing = $ignoremissing
					}
					Else{
						Write-error "The parameter ignoremissing is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('includeprettyraw')){
					if($HashTable.containskey('includeprettyraw')){
						$HashTable.includeprettyraw = $includeprettyraw
					}
					Else{
						Write-error "The parameter includeprettyraw is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.hardware.ipmi.sel.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('node') -or $PSBoundParameters.ContainsKey('includeraw') -or $PSBoundParameters.ContainsKey('ignoremissing') -or $PSBoundParameters.ContainsKey('includeprettyraw')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.hardware.ipmi.sel.list.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.hardware.memory{
<#
.SYNOPSIS
Get information about memory.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.hardware.memory.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.hardware.memory.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.hardware.memory.get.invoke()
		}
	}
}

function list-EsxCLI.hardware.pci{
<#
.SYNOPSIS
List all of the PCI devices on this host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER class
Filter the PCI devices based on their hexadecimal Class ID

.PARAMETER mask
Mask the filter provided by the class flag

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$class,
	[string]$mask,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.hardware.pci.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.hardware.pci.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.hardware.pci.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.hardware.pci.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('class')){
					if($HashTable.containskey('class')){
						$HashTable.class = $class
					}
					Else{
						Write-error "The parameter class is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('mask')){
					if($HashTable.containskey('mask')){
						$HashTable.mask = $mask
					}
					Else{
						Write-error "The parameter mask is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.hardware.pci.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('class') -or $PSBoundParameters.ContainsKey('mask')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.hardware.pci.list.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.hardware.platform{
<#
.SYNOPSIS
Get information about the platform

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.hardware.platform.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.hardware.platform.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.hardware.platform.get.invoke()
		}
	}
}

function list-EsxCLI.hardware.smartcard.certificate{
<#
.SYNOPSIS
Certificates from inserted smart cards.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER slot
List certificates from only the token in the given slot.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[long]$slot,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.hardware.smartcard.certificate.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.hardware.smartcard.certificate.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.hardware.smartcard.certificate.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.hardware.smartcard.certificate.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('slot')){
					if($HashTable.containskey('slot')){
						$HashTable.slot = $slot
					}
					Else{
						Write-error "The parameter slot is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.hardware.smartcard.certificate.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('slot')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.hardware.smartcard.certificate.list.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.hardware.smartcard.info{
<#
.SYNOPSIS
Information about the smart card subsystem.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.hardware.smartcard.info.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.hardware.smartcard.info.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.hardware.smartcard.info.get.invoke()
		}
	}
}

function list-EsxCLI.hardware.smartcard.slot{
<#
.SYNOPSIS
Information about connected smart card readers.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.hardware.smartcard.slot.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.hardware.smartcard.slot.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.hardware.smartcard.slot.list.invoke()
		}
	}
}

function list-EsxCLI.hardware.smartcard.token{
<#
.SYNOPSIS
Information about inserted smart cards.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER slot
List tokens only for the given slot.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[long]$slot,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.hardware.smartcard.token.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.hardware.smartcard.token.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.hardware.smartcard.token.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.hardware.smartcard.token.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('slot')){
					if($HashTable.containskey('slot')){
						$HashTable.slot = $slot
					}
					Else{
						Write-error "The parameter slot is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.hardware.smartcard.token.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('slot')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.hardware.smartcard.token.list.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.hardware.trustedboot{
<#
.SYNOPSIS
Information about the status of trusted boot. (TPM, DRTM status)

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.hardware.trustedboot.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.hardware.trustedboot.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.hardware.trustedboot.get.invoke()
		}
	}
}

function get-EsxCLI.iscsi.adapter{
<#
.SYNOPSIS
List the iSCSI information for the iSCSI Host Bus Adapter.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.adapter.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.adapter.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.adapter.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.adapter.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.adapter.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.adapter.get.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.iscsi.adapter{
<#
.SYNOPSIS
List all the iSCSI Host Bus Adapters on the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.adapter.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.adapter.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.adapter.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.adapter.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.adapter.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.adapter.list.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.iscsi.adapter{
<#
.SYNOPSIS
Set the iSCSI name and alias for the iSCSI Host Bus Adapter.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER alias
The iSCSI initiator alias.

.PARAMETER name
The iSCSI initiator name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[string]$name,
	[string]$alias,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.adapter.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.adapter.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.adapter.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.adapter.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('name')){
					if($HashTable.containskey('name')){
						$HashTable.name = $name
					}
					Else{
						Write-error "The parameter name is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('alias')){
					if($HashTable.containskey('alias')){
						$HashTable.alias = $alias
					}
					Else{
						Write-error "The parameter alias is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.adapter.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter') -or $PSBoundParameters.ContainsKey('name') -or $PSBoundParameters.ContainsKey('alias')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.adapter.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.iscsi.adapter.auth.chap{
<#
.SYNOPSIS
Get the iSCSI CHAP authentication for the iSCSI Host Bus Adapter.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER direction
The iSCSI CHAP authentication direction. Options are: [uni, mutual]

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[string]$direction,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.adapter.auth.chap.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.adapter.auth.chap.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.adapter.auth.chap.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.adapter.auth.chap.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('direction')){
					if($HashTable.containskey('direction')){
						$HashTable.direction = $direction
					}
					Else{
						Write-error "The parameter direction is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.adapter.auth.chap.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter') -or $PSBoundParameters.ContainsKey('direction')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.adapter.auth.chap.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.iscsi.adapter.auth.chap{
<#
.SYNOPSIS
Set the iSCSI CHAP authentication for the iSCSI Host Bus Adapter.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER authname
The iSCSI CHAP authentication name

.PARAMETER default
Resetting iSCSI CHAP authenthication setting to default.

.PARAMETER direction
The iSCSI CHAP authentication direction. Options are: [uni, mutual]

.PARAMETER level
The iSCSI CHAP authentication level. Options are: [prohibited, discouraged, preferred, required]

.PARAMETER secret
The iSCSI CHAP authentication secret

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$default,
	[string]$authname,
	[string]$level,
	[string]$secret,
	[string]$direction,
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.adapter.auth.chap.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.adapter.auth.chap.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.adapter.auth.chap.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.adapter.auth.chap.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('default')){
					if($HashTable.containskey('default')){
						$HashTable.default = $default
					}
					Else{
						Write-error "The parameter default is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('authname')){
					if($HashTable.containskey('authname')){
						$HashTable.authname = $authname
					}
					Else{
						Write-error "The parameter authname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('level')){
					if($HashTable.containskey('level')){
						$HashTable.level = $level
					}
					Else{
						Write-error "The parameter level is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('secret')){
					if($HashTable.containskey('secret')){
						$HashTable.secret = $secret
					}
					Else{
						Write-error "The parameter secret is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('direction')){
					if($HashTable.containskey('direction')){
						$HashTable.direction = $direction
					}
					Else{
						Write-error "The parameter direction is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.adapter.auth.chap.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('default') -or $PSBoundParameters.ContainsKey('authname') -or $PSBoundParameters.ContainsKey('level') -or $PSBoundParameters.ContainsKey('secret') -or $PSBoundParameters.ContainsKey('direction') -or $PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.adapter.auth.chap.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.iscsi.adapter.capabilities{
<#
.SYNOPSIS
List the iSCSI details for the iSCSI Host Bus Adapter.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.adapter.capabilities.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.adapter.capabilities.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.adapter.capabilities.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.adapter.capabilities.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.adapter.capabilities.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.adapter.capabilities.get.invoke()
				}
			}
		}
	}
}

function rediscover-EsxCLI.iscsi.adapter.discovery{
<#
.SYNOPSIS
Do the iSCSI Discovery for the iSCSI Host Bus Adapter.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.adapter.discovery.rediscover){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.adapter.discovery.rediscover is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.adapter.discovery.rediscover | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.adapter.discovery.rediscover.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.adapter.discovery.rediscover.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.adapter.discovery.rediscover.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.iscsi.adapter.discovery.sendtarget{
<#
.SYNOPSIS
Add a sendtarget address

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER address
The iSCSI sendtarget address: <ip/dns[:port]>. IPv6 address can be specified as [XX:XX:XX:XX::XX]:port or XX:XX:XX:XX::XX

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true)]
	[string]$address,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.adapter.discovery.sendtarget.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.adapter.discovery.sendtarget.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.adapter.discovery.sendtarget.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.adapter.discovery.sendtarget.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('address')){
					if($HashTable.containskey('address')){
						$HashTable.address = $address
					}
					Else{
						Write-error "The parameter address is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.adapter.discovery.sendtarget.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter') -or $PSBoundParameters.ContainsKey('address')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.adapter.discovery.sendtarget.add.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.iscsi.adapter.discovery.sendtarget{
<#
.SYNOPSIS
List sendtarget addresses

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.adapter.discovery.sendtarget.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.adapter.discovery.sendtarget.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.adapter.discovery.sendtarget.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.adapter.discovery.sendtarget.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.adapter.discovery.sendtarget.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.adapter.discovery.sendtarget.list.invoke()
				}
			}
		}
	}
}

function remove-EsxCLI.iscsi.adapter.discovery.sendtarget{
<#
.SYNOPSIS
Remove a sendtarget address

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER address
The iSCSI sendtarget address: <ip/dns[:port]>. IPv6 address can be specified as [XX:XX:XX:XX::XX]:port or XX:XX:XX:XX::XX

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true)]
	[string]$address,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.adapter.discovery.sendtarget.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.adapter.discovery.sendtarget.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.adapter.discovery.sendtarget.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.adapter.discovery.sendtarget.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('address')){
					if($HashTable.containskey('address')){
						$HashTable.address = $address
					}
					Else{
						Write-error "The parameter address is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.adapter.discovery.sendtarget.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter') -or $PSBoundParameters.ContainsKey('address')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.adapter.discovery.sendtarget.remove.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.iscsi.adapter.discovery.sendtarget.auth.chap{
<#
.SYNOPSIS
Get iSCSI CHAP authentication on a sendtarget address

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER address
The iSCSI sendtarget address: <ip/dns[:port]>

.PARAMETER direction
The iSCSI authentication direction. Options are: [uni, mutual]

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[string]$direction,
	[Parameter(Mandatory=$true)]
	[string]$address,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.adapter.discovery.sendtarget.auth.chap.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.adapter.discovery.sendtarget.auth.chap.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.adapter.discovery.sendtarget.auth.chap.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.adapter.discovery.sendtarget.auth.chap.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('direction')){
					if($HashTable.containskey('direction')){
						$HashTable.direction = $direction
					}
					Else{
						Write-error "The parameter direction is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('address')){
					if($HashTable.containskey('address')){
						$HashTable.address = $address
					}
					Else{
						Write-error "The parameter address is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.adapter.discovery.sendtarget.auth.chap.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter') -or $PSBoundParameters.ContainsKey('direction') -or $PSBoundParameters.ContainsKey('address')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.adapter.discovery.sendtarget.auth.chap.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.iscsi.adapter.discovery.sendtarget.auth.chap{
<#
.SYNOPSIS
Set iSCSI CHAP authentication on a sendtarget address

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER address
The iSCSI sendtarget address: <ip/dns[:port]>

.PARAMETER authname
The iSCSI authentication name

.PARAMETER default
Resetting iSCSI authentication setting to default.

.PARAMETER direction
The iSCSI authentication direction. Options are: [uni, mutual]

.PARAMETER inherit
Inheriting iSCSI authentication setting from parent.

.PARAMETER level
The iSCSI authentication level. Options are: [prohibited, discouraged, preferred, required]

.PARAMETER secret
The iSCSI authentication secret

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$secret,
	[string]$authname,
	[boolean]$default,
	[Parameter(Mandatory=$true)]
	[string]$address,
	[boolean]$inherit,
	[string]$level,
	[string]$direction,
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.adapter.discovery.sendtarget.auth.chap.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.adapter.discovery.sendtarget.auth.chap.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.adapter.discovery.sendtarget.auth.chap.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.adapter.discovery.sendtarget.auth.chap.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('secret')){
					if($HashTable.containskey('secret')){
						$HashTable.secret = $secret
					}
					Else{
						Write-error "The parameter secret is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('authname')){
					if($HashTable.containskey('authname')){
						$HashTable.authname = $authname
					}
					Else{
						Write-error "The parameter authname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('default')){
					if($HashTable.containskey('default')){
						$HashTable.default = $default
					}
					Else{
						Write-error "The parameter default is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('address')){
					if($HashTable.containskey('address')){
						$HashTable.address = $address
					}
					Else{
						Write-error "The parameter address is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('inherit')){
					if($HashTable.containskey('inherit')){
						$HashTable.inherit = $inherit
					}
					Else{
						Write-error "The parameter inherit is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('level')){
					if($HashTable.containskey('level')){
						$HashTable.level = $level
					}
					Else{
						Write-error "The parameter level is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('direction')){
					if($HashTable.containskey('direction')){
						$HashTable.direction = $direction
					}
					Else{
						Write-error "The parameter direction is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.adapter.discovery.sendtarget.auth.chap.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('secret') -or $PSBoundParameters.ContainsKey('authname') -or $PSBoundParameters.ContainsKey('default') -or $PSBoundParameters.ContainsKey('address') -or $PSBoundParameters.ContainsKey('inherit') -or $PSBoundParameters.ContainsKey('level') -or $PSBoundParameters.ContainsKey('direction') -or $PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.adapter.discovery.sendtarget.auth.chap.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.iscsi.adapter.discovery.sendtarget.param{
<#
.SYNOPSIS
Get iSCSI parameter on a sendtarget address

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER address
The iSCSI sendtarget address: <ip/dns[:port]>

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true)]
	[string]$address,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.adapter.discovery.sendtarget.param.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.adapter.discovery.sendtarget.param.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.adapter.discovery.sendtarget.param.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.adapter.discovery.sendtarget.param.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('address')){
					if($HashTable.containskey('address')){
						$HashTable.address = $address
					}
					Else{
						Write-error "The parameter address is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.adapter.discovery.sendtarget.param.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter') -or $PSBoundParameters.ContainsKey('address')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.adapter.discovery.sendtarget.param.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.iscsi.adapter.discovery.sendtarget.param{
<#
.SYNOPSIS
Set the iSCSI parameter for the iSCSI Sendtarget.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER address
The iSCSI sendtarget address: <ip/dns[:port]>

.PARAMETER default
Resetting iSCSI parameter setting to default.

.PARAMETER inherit
Inheriting iSCSI parameter setting from parent.

.PARAMETER key
The iSCSI parameter key

.PARAMETER value
The iSCSI parameter value

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$default,
	[Parameter(Mandatory=$true)]
	[string]$address,
	[boolean]$inherit,
	[string]$value,
	[Parameter(Mandatory=$true)]
	[string]$key,
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.adapter.discovery.sendtarget.param.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.adapter.discovery.sendtarget.param.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.adapter.discovery.sendtarget.param.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.adapter.discovery.sendtarget.param.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('default')){
					if($HashTable.containskey('default')){
						$HashTable.default = $default
					}
					Else{
						Write-error "The parameter default is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('address')){
					if($HashTable.containskey('address')){
						$HashTable.address = $address
					}
					Else{
						Write-error "The parameter address is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('inherit')){
					if($HashTable.containskey('inherit')){
						$HashTable.inherit = $inherit
					}
					Else{
						Write-error "The parameter inherit is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('value')){
					if($HashTable.containskey('value')){
						$HashTable.value = $value
					}
					Else{
						Write-error "The parameter value is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('key')){
					if($HashTable.containskey('key')){
						$HashTable.key = $key
					}
					Else{
						Write-error "The parameter key is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.adapter.discovery.sendtarget.param.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('default') -or $PSBoundParameters.ContainsKey('address') -or $PSBoundParameters.ContainsKey('inherit') -or $PSBoundParameters.ContainsKey('value') -or $PSBoundParameters.ContainsKey('key') -or $PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.adapter.discovery.sendtarget.param.set.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.iscsi.adapter.discovery.statictarget{
<#
.SYNOPSIS
Add a static target address

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER address
The iSCSI target address: <ip/dns[:port]>. IPv6 address can be specified as [XX:XX:XX:XX::XX]:port or XX:XX:XX:XX::XX

.PARAMETER name
The iSCSI target name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true)]
	[string]$name,
	[Parameter(Mandatory=$true)]
	[string]$address,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.adapter.discovery.statictarget.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.adapter.discovery.statictarget.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.adapter.discovery.statictarget.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.adapter.discovery.statictarget.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('name')){
					if($HashTable.containskey('name')){
						$HashTable.name = $name
					}
					Else{
						Write-error "The parameter name is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('address')){
					if($HashTable.containskey('address')){
						$HashTable.address = $address
					}
					Else{
						Write-error "The parameter address is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.adapter.discovery.statictarget.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter') -or $PSBoundParameters.ContainsKey('name') -or $PSBoundParameters.ContainsKey('address')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.adapter.discovery.statictarget.add.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.iscsi.adapter.discovery.statictarget{
<#
.SYNOPSIS
List static target addresses

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.adapter.discovery.statictarget.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.adapter.discovery.statictarget.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.adapter.discovery.statictarget.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.adapter.discovery.statictarget.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.adapter.discovery.statictarget.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.adapter.discovery.statictarget.list.invoke()
				}
			}
		}
	}
}

function remove-EsxCLI.iscsi.adapter.discovery.statictarget{
<#
.SYNOPSIS
Remove a static target

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER address
The iSCSI target address: <ip/dns[:port]>. IPv6 address can be specified as [XX:XX:XX:XX::XX]:port or XX:XX:XX:XX::XX

.PARAMETER name
The iSCSI target name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true)]
	[string]$name,
	[Parameter(Mandatory=$true)]
	[string]$address,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.adapter.discovery.statictarget.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.adapter.discovery.statictarget.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.adapter.discovery.statictarget.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.adapter.discovery.statictarget.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('name')){
					if($HashTable.containskey('name')){
						$HashTable.name = $name
					}
					Else{
						Write-error "The parameter name is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('address')){
					if($HashTable.containskey('address')){
						$HashTable.address = $address
					}
					Else{
						Write-error "The parameter address is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.adapter.discovery.statictarget.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter') -or $PSBoundParameters.ContainsKey('name') -or $PSBoundParameters.ContainsKey('address')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.adapter.discovery.statictarget.remove.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.iscsi.adapter.discovery.status{
<#
.SYNOPSIS
Get the iSCSI adapter discovery status for the iSCSI Host Bus Adapter.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.adapter.discovery.status.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.adapter.discovery.status.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.adapter.discovery.status.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.adapter.discovery.status.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.adapter.discovery.status.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.adapter.discovery.status.get.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.iscsi.adapter.firmware{
<#
.SYNOPSIS
Validate the iSCSI firmware for the iSCSI Host Bus Adapter.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER file
Path to the firmware file to retrieve information from.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true)]
	[string]$file,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.adapter.firmware.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.adapter.firmware.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.adapter.firmware.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.adapter.firmware.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('file')){
					if($HashTable.containskey('file')){
						$HashTable.file = $file
					}
					Else{
						Write-error "The parameter file is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.adapter.firmware.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter') -or $PSBoundParameters.ContainsKey('file')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.adapter.firmware.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.iscsi.adapter.firmware{
<#
.SYNOPSIS
Upload the iSCSI firmware for the iSCSI Host Bus Adapter.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER file
Path to the firmware file to download.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true)]
	[string]$file,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.adapter.firmware.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.adapter.firmware.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.adapter.firmware.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.adapter.firmware.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('file')){
					if($HashTable.containskey('file')){
						$HashTable.file = $file
					}
					Else{
						Write-error "The parameter file is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.adapter.firmware.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter') -or $PSBoundParameters.ContainsKey('file')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.adapter.firmware.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.iscsi.adapter.param{
<#
.SYNOPSIS
Get the iSCSI parameters for the iSCSI Host Bus Adapter.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.adapter.param.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.adapter.param.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.adapter.param.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.adapter.param.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.adapter.param.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.adapter.param.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.iscsi.adapter.param{
<#
.SYNOPSIS
Set the iSCSI parameter for the iSCSI Host Bus Adapter.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER default
Resetting iSCSI parameter setting to default.

.PARAMETER key
The iSCSI initiator parameter key.

.PARAMETER value
The iSCSI initiator parameter value.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$default,
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true)]
	[string]$key,
	[string]$value,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.adapter.param.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.adapter.param.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.adapter.param.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.adapter.param.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('default')){
					if($HashTable.containskey('default')){
						$HashTable.default = $default
					}
					Else{
						Write-error "The parameter default is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('key')){
					if($HashTable.containskey('key')){
						$HashTable.key = $key
					}
					Else{
						Write-error "The parameter key is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('value')){
					if($HashTable.containskey('value')){
						$HashTable.value = $value
					}
					Else{
						Write-error "The parameter value is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.adapter.param.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('default') -or $PSBoundParameters.ContainsKey('adapter') -or $PSBoundParameters.ContainsKey('key') -or $PSBoundParameters.ContainsKey('value')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.adapter.param.set.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.iscsi.adapter.target{
<#
.SYNOPSIS
List iSCSI targets.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER name
The iSCSI target name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$adapter,
	[string]$name,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.adapter.target.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.adapter.target.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.adapter.target.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.adapter.target.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('name')){
					if($HashTable.containskey('name')){
						$HashTable.name = $name
					}
					Else{
						Write-error "The parameter name is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.adapter.target.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter') -or $PSBoundParameters.ContainsKey('name')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.adapter.target.list.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.iscsi.adapter.target.portal{
<#
.SYNOPSIS
List iSCSI target portals.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER name
The iSCSI target name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$adapter,
	[string]$name,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.adapter.target.portal.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.adapter.target.portal.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.adapter.target.portal.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.adapter.target.portal.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('name')){
					if($HashTable.containskey('name')){
						$HashTable.name = $name
					}
					Else{
						Write-error "The parameter name is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.adapter.target.portal.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter') -or $PSBoundParameters.ContainsKey('name')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.adapter.target.portal.list.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.iscsi.adapter.target.portal.auth.chap{
<#
.SYNOPSIS
Get iSCSI CHAP authentication on a target

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER address
The iSCSI target address: <ip/dns[:port]>

.PARAMETER direction
The iSCSI authentication direction. Options are: [uni, mutual]

.PARAMETER method
The iSCSI authentication method. Options are: [chap]

.PARAMETER name
The iSCSI target name: <iqn/eui>

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true)]
	[string]$name,
	[string]$direction,
	[Parameter(Mandatory=$true)]
	[string]$address,
	[string]$method,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.adapter.target.portal.auth.chap.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.adapter.target.portal.auth.chap.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.adapter.target.portal.auth.chap.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.adapter.target.portal.auth.chap.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('name')){
					if($HashTable.containskey('name')){
						$HashTable.name = $name
					}
					Else{
						Write-error "The parameter name is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('direction')){
					if($HashTable.containskey('direction')){
						$HashTable.direction = $direction
					}
					Else{
						Write-error "The parameter direction is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('address')){
					if($HashTable.containskey('address')){
						$HashTable.address = $address
					}
					Else{
						Write-error "The parameter address is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('method')){
					if($HashTable.containskey('method')){
						$HashTable.method = $method
					}
					Else{
						Write-error "The parameter method is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.adapter.target.portal.auth.chap.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter') -or $PSBoundParameters.ContainsKey('name') -or $PSBoundParameters.ContainsKey('direction') -or $PSBoundParameters.ContainsKey('address') -or $PSBoundParameters.ContainsKey('method')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.adapter.target.portal.auth.chap.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.iscsi.adapter.target.portal.auth.chap{
<#
.SYNOPSIS
Set the iSCSI CHAP authentication for the iSCSI Target.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER address
The iSCSI target address: <ip/dns[:port]>

.PARAMETER authname
The iSCSI authentication name

.PARAMETER default
Resetting iSCSI authentication setting to default.

.PARAMETER direction
The iSCSI authentication direction. Options are: [uni, mutual]

.PARAMETER inherit
Inheriting iSCSI authentication setting from parent.

.PARAMETER level
The iSCSI authentication level. Options are: [prohibited, discouraged, preferred, required]

.PARAMETER name
The iSCSI target name: <iqn/eui>

.PARAMETER secret
The iSCSI authentication password

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$secret,
	[string]$authname,
	[boolean]$default,
	[Parameter(Mandatory=$true)]
	[string]$name,
	[Parameter(Mandatory=$true)]
	[string]$address,
	[boolean]$inherit,
	[string]$level,
	[string]$direction,
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.adapter.target.portal.auth.chap.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.adapter.target.portal.auth.chap.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.adapter.target.portal.auth.chap.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.adapter.target.portal.auth.chap.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('secret')){
					if($HashTable.containskey('secret')){
						$HashTable.secret = $secret
					}
					Else{
						Write-error "The parameter secret is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('authname')){
					if($HashTable.containskey('authname')){
						$HashTable.authname = $authname
					}
					Else{
						Write-error "The parameter authname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('default')){
					if($HashTable.containskey('default')){
						$HashTable.default = $default
					}
					Else{
						Write-error "The parameter default is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('name')){
					if($HashTable.containskey('name')){
						$HashTable.name = $name
					}
					Else{
						Write-error "The parameter name is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('address')){
					if($HashTable.containskey('address')){
						$HashTable.address = $address
					}
					Else{
						Write-error "The parameter address is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('inherit')){
					if($HashTable.containskey('inherit')){
						$HashTable.inherit = $inherit
					}
					Else{
						Write-error "The parameter inherit is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('level')){
					if($HashTable.containskey('level')){
						$HashTable.level = $level
					}
					Else{
						Write-error "The parameter level is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('direction')){
					if($HashTable.containskey('direction')){
						$HashTable.direction = $direction
					}
					Else{
						Write-error "The parameter direction is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.adapter.target.portal.auth.chap.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('secret') -or $PSBoundParameters.ContainsKey('authname') -or $PSBoundParameters.ContainsKey('default') -or $PSBoundParameters.ContainsKey('name') -or $PSBoundParameters.ContainsKey('address') -or $PSBoundParameters.ContainsKey('inherit') -or $PSBoundParameters.ContainsKey('level') -or $PSBoundParameters.ContainsKey('direction') -or $PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.adapter.target.portal.auth.chap.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.iscsi.adapter.target.portal.param{
<#
.SYNOPSIS
Get iSCSI parameter on a target

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER address
The iSCSI target address: <ip/dns[:port]>

.PARAMETER name
The iSCSI target name: <iqn/eui>

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true)]
	[string]$name,
	[Parameter(Mandatory=$true)]
	[string]$address,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.adapter.target.portal.param.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.adapter.target.portal.param.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.adapter.target.portal.param.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.adapter.target.portal.param.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('name')){
					if($HashTable.containskey('name')){
						$HashTable.name = $name
					}
					Else{
						Write-error "The parameter name is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('address')){
					if($HashTable.containskey('address')){
						$HashTable.address = $address
					}
					Else{
						Write-error "The parameter address is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.adapter.target.portal.param.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter') -or $PSBoundParameters.ContainsKey('name') -or $PSBoundParameters.ContainsKey('address')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.adapter.target.portal.param.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.iscsi.adapter.target.portal.param{
<#
.SYNOPSIS
Set the iSCSI parameter for the iSCSI Target.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER address
The iSCSI target address: <ip/dns[:port]>

.PARAMETER default
Resetting iSCSI parameter setting to default.

.PARAMETER inherit
Inheriting iSCSI parameter setting from parent.

.PARAMETER key
The iSCSI parameter key

.PARAMETER name
The iSCSI target name: <iqn/eui>

.PARAMETER value
The iSCSI parameter value

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$default,
	[Parameter(Mandatory=$true)]
	[string]$name,
	[Parameter(Mandatory=$true)]
	[string]$address,
	[boolean]$inherit,
	[string]$value,
	[Parameter(Mandatory=$true)]
	[string]$key,
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.adapter.target.portal.param.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.adapter.target.portal.param.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.adapter.target.portal.param.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.adapter.target.portal.param.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('default')){
					if($HashTable.containskey('default')){
						$HashTable.default = $default
					}
					Else{
						Write-error "The parameter default is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('name')){
					if($HashTable.containskey('name')){
						$HashTable.name = $name
					}
					Else{
						Write-error "The parameter name is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('address')){
					if($HashTable.containskey('address')){
						$HashTable.address = $address
					}
					Else{
						Write-error "The parameter address is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('inherit')){
					if($HashTable.containskey('inherit')){
						$HashTable.inherit = $inherit
					}
					Else{
						Write-error "The parameter inherit is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('value')){
					if($HashTable.containskey('value')){
						$HashTable.value = $value
					}
					Else{
						Write-error "The parameter value is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('key')){
					if($HashTable.containskey('key')){
						$HashTable.key = $key
					}
					Else{
						Write-error "The parameter key is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.adapter.target.portal.param.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('default') -or $PSBoundParameters.ContainsKey('name') -or $PSBoundParameters.ContainsKey('address') -or $PSBoundParameters.ContainsKey('inherit') -or $PSBoundParameters.ContainsKey('value') -or $PSBoundParameters.ContainsKey('key') -or $PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.adapter.target.portal.param.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.iscsi.ibftboot{
<#
.SYNOPSIS
Get iSCSI IBFT Boot details.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.ibftboot.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.ibftboot.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.iscsi.ibftboot.get.invoke()
		}
	}
}

function import-EsxCLI.iscsi.ibftboot{
<#
.SYNOPSIS
Import iSCSI target configuration from iBFT to ESX iSCSI initiators. The boot target recorded in iBFT is added to all the eligible 'dependent' iSCSI adapters.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.ibftboot.import){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.ibftboot.import is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.iscsi.ibftboot.import.invoke()
		}
	}
}

function list-EsxCLI.iscsi.logicalnetworkportal{
<#
.SYNOPSIS
List Logical Network Portals for iSCSI Adapter

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.logicalnetworkportal.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.logicalnetworkportal.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.logicalnetworkportal.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.logicalnetworkportal.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.logicalnetworkportal.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.logicalnetworkportal.list.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.iscsi.networkportal{
<#
.SYNOPSIS
Add a network portal for iSCSI adapter

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER force
The force flag (force add of iSCSI vmknic even it's not compatible for iscsi multipathing)

.PARAMETER nic
The iSCSI network portal (bound vmknic)

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[boolean]$force,
	[Parameter(Mandatory=$true)]
	[string]$nic,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.networkportal.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.networkportal.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.networkportal.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.networkportal.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('force')){
					if($HashTable.containskey('force')){
						$HashTable.force = $force
					}
					Else{
						Write-error "The parameter force is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('nic')){
					if($HashTable.containskey('nic')){
						$HashTable.nic = $nic
					}
					Else{
						Write-error "The parameter nic is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.networkportal.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter') -or $PSBoundParameters.ContainsKey('force') -or $PSBoundParameters.ContainsKey('nic')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.networkportal.add.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.iscsi.networkportal{
<#
.SYNOPSIS
List Network Portal for iSCSI Adapter

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.networkportal.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.networkportal.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.networkportal.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.networkportal.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.networkportal.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.networkportal.list.invoke()
				}
			}
		}
	}
}

function remove-EsxCLI.iscsi.networkportal{
<#
.SYNOPSIS
Remove a network portal for iSCSI adapter

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER force
The force flag (force removal of iSCSI vmknic when sessions are active using it)

.PARAMETER nic
The iSCSI network portal (bound vmknic)

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[boolean]$force,
	[Parameter(Mandatory=$true)]
	[string]$nic,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.networkportal.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.networkportal.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.networkportal.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.networkportal.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('force')){
					if($HashTable.containskey('force')){
						$HashTable.force = $force
					}
					Else{
						Write-error "The parameter force is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('nic')){
					if($HashTable.containskey('nic')){
						$HashTable.nic = $nic
					}
					Else{
						Write-error "The parameter nic is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.networkportal.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter') -or $PSBoundParameters.ContainsKey('force') -or $PSBoundParameters.ContainsKey('nic')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.networkportal.remove.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.iscsi.networkportal.ipconfig{
<#
.SYNOPSIS
Get iSCSI network portal ipv4 configuration

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER nic
The iSCSI network portal (vmknic)

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[string]$nic,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.networkportal.ipconfig.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.networkportal.ipconfig.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.networkportal.ipconfig.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.networkportal.ipconfig.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('nic')){
					if($HashTable.containskey('nic')){
						$HashTable.nic = $nic
					}
					Else{
						Write-error "The parameter nic is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.networkportal.ipconfig.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter') -or $PSBoundParameters.ContainsKey('nic')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.networkportal.ipconfig.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.iscsi.networkportal.ipconfig{
<#
.SYNOPSIS
Set iSCSI network portal IPv4 configuration.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER dns1
The iSCSI network portal primary DNS address

.PARAMETER dns2
The iSCSI network portal secondary DNS address

.PARAMETER enable
Enable/Disable IPv4. All other options will be ignored if IPv4 is being disabled.

.PARAMETER enabledhcpv4
Enable/Disable IPv4 configuration using DHCPv4. If DHCPv4 is being enabled, static configuration parameters (ip,subnet,gateway,dns1,dns2) are ignored.

.PARAMETER gateway
The iSCSI network portal IPv4 gateway address

.PARAMETER ip
The iSCSI network portal IPv4 address

.PARAMETER nic
The iSCSI network portal (vmknic)

.PARAMETER subnet
The iSCSI network portal IPv4 subnet mask

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$enable,
	[string]$ip,
	[string]$gateway,
	[string]$nic,
	[string]$dns1,
	[string]$dns2,
	[boolean]$enabledhcpv4,
	[string]$subnet,
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.networkportal.ipconfig.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.networkportal.ipconfig.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.networkportal.ipconfig.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.networkportal.ipconfig.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('enable')){
					if($HashTable.containskey('enable')){
						$HashTable.enable = $enable
					}
					Else{
						Write-error "The parameter enable is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ip')){
					if($HashTable.containskey('ip')){
						$HashTable.ip = $ip
					}
					Else{
						Write-error "The parameter ip is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('gateway')){
					if($HashTable.containskey('gateway')){
						$HashTable.gateway = $gateway
					}
					Else{
						Write-error "The parameter gateway is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('nic')){
					if($HashTable.containskey('nic')){
						$HashTable.nic = $nic
					}
					Else{
						Write-error "The parameter nic is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('dns1')){
					if($HashTable.containskey('dns1')){
						$HashTable.dns1 = $dns1
					}
					Else{
						Write-error "The parameter dns1 is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('dns2')){
					if($HashTable.containskey('dns2')){
						$HashTable.dns2 = $dns2
					}
					Else{
						Write-error "The parameter dns2 is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('enabledhcpv4')){
					if($HashTable.containskey('enabledhcpv4')){
						$HashTable.enabledhcpv4 = $enabledhcpv4
					}
					Else{
						Write-error "The parameter enabledhcpv4 is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('subnet')){
					if($HashTable.containskey('subnet')){
						$HashTable.subnet = $subnet
					}
					Else{
						Write-error "The parameter subnet is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.networkportal.ipconfig.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('enable') -or $PSBoundParameters.ContainsKey('ip') -or $PSBoundParameters.ContainsKey('gateway') -or $PSBoundParameters.ContainsKey('nic') -or $PSBoundParameters.ContainsKey('dns1') -or $PSBoundParameters.ContainsKey('dns2') -or $PSBoundParameters.ContainsKey('enabledhcpv4') -or $PSBoundParameters.ContainsKey('subnet') -or $PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.networkportal.ipconfig.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.iscsi.networkportal.ipv6config{
<#
.SYNOPSIS
Get iSCSI network portal ipv6 configuration

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.networkportal.ipv6config.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.networkportal.ipv6config.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.networkportal.ipv6config.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.networkportal.ipv6config.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.networkportal.ipv6config.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.networkportal.ipv6config.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.iscsi.networkportal.ipv6config{
<#
.SYNOPSIS
Set iSCSI network portal IPv6 configuration.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER enable
Enable/Disable IPv6

.PARAMETER enabledhcpv6
Enable/Disable IPv6 configuration using DHCPv6

.PARAMETER enablelinklocalautoconfiguration
Enable/Disable auto configuration of linklocal address

.PARAMETER enablerouteradvertisement
Enable/Disable IPv6 configuration using Router Advertisement

.PARAMETER gateway6
The iSCSI network portal IPv6 gateway address

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$gateway6,
	[boolean]$enable,
	[boolean]$enablerouteradvertisement,
	[boolean]$enablelinklocalautoconfiguration,
	[boolean]$enabledhcpv6,
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.networkportal.ipv6config.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.networkportal.ipv6config.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.networkportal.ipv6config.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.networkportal.ipv6config.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('gateway6')){
					if($HashTable.containskey('gateway6')){
						$HashTable.gateway6 = $gateway6
					}
					Else{
						Write-error "The parameter gateway6 is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('enable')){
					if($HashTable.containskey('enable')){
						$HashTable.enable = $enable
					}
					Else{
						Write-error "The parameter enable is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('enablerouteradvertisement')){
					if($HashTable.containskey('enablerouteradvertisement')){
						$HashTable.enablerouteradvertisement = $enablerouteradvertisement
					}
					Else{
						Write-error "The parameter enablerouteradvertisement is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('enablelinklocalautoconfiguration')){
					if($HashTable.containskey('enablelinklocalautoconfiguration')){
						$HashTable.enablelinklocalautoconfiguration = $enablelinklocalautoconfiguration
					}
					Else{
						Write-error "The parameter enablelinklocalautoconfiguration is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('enabledhcpv6')){
					if($HashTable.containskey('enabledhcpv6')){
						$HashTable.enabledhcpv6 = $enabledhcpv6
					}
					Else{
						Write-error "The parameter enabledhcpv6 is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.networkportal.ipv6config.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('gateway6') -or $PSBoundParameters.ContainsKey('enable') -or $PSBoundParameters.ContainsKey('enablerouteradvertisement') -or $PSBoundParameters.ContainsKey('enablelinklocalautoconfiguration') -or $PSBoundParameters.ContainsKey('enabledhcpv6') -or $PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.networkportal.ipv6config.set.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.iscsi.networkportal.ipv6config.address{
<#
.SYNOPSIS
Add IPv6 addresses to the given iSCSI network portal.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER addresslist
An IPv6 address to add in X:X:X::/X format. Multiple addresses can be provided using format -a address1 -a address2 -a address3.

.PARAMETER removeallexisting
Remove all existing routable IPv6 addresses before adding the addresses specified by --address-list. If this flag is passed and --address-list is empty, all existing routable addresses are removed.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[string[]]$addresslist,
	[boolean]$removeallexisting,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.networkportal.ipv6config.address.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.networkportal.ipv6config.address.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.networkportal.ipv6config.address.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.networkportal.ipv6config.address.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('addresslist')){
					if($HashTable.containskey('addresslist')){
						$HashTable.addresslist = $addresslist
					}
					Else{
						Write-error "The parameter addresslist is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('removeallexisting')){
					if($HashTable.containskey('removeallexisting')){
						$HashTable.removeallexisting = $removeallexisting
					}
					Else{
						Write-error "The parameter removeallexisting is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.networkportal.ipv6config.address.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter') -or $PSBoundParameters.ContainsKey('addresslist') -or $PSBoundParameters.ContainsKey('removeallexisting')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.networkportal.ipv6config.address.add.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.iscsi.networkportal.ipv6config.address{
<#
.SYNOPSIS
List the IPv6 addresses assigned to the iSCSI network portal.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.networkportal.ipv6config.address.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.networkportal.ipv6config.address.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.networkportal.ipv6config.address.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.networkportal.ipv6config.address.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.networkportal.ipv6config.address.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.networkportal.ipv6config.address.list.invoke()
				}
			}
		}
	}
}

function remove-EsxCLI.iscsi.networkportal.ipv6config.address{
<#
.SYNOPSIS
Remove IPv6 addresses from the given iSCSI network portal.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER addresslist
An IPv6 address to remove in X:X:X::/X format. Multiple addresses can be provided using format -a address1 -a address2 -a address3.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true)]
	[string[]]$addresslist,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.networkportal.ipv6config.address.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.networkportal.ipv6config.address.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.networkportal.ipv6config.address.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.networkportal.ipv6config.address.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('addresslist')){
					if($HashTable.containskey('addresslist')){
						$HashTable.addresslist = $addresslist
					}
					Else{
						Write-error "The parameter addresslist is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.networkportal.ipv6config.address.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter') -or $PSBoundParameters.ContainsKey('addresslist')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.networkportal.ipv6config.address.remove.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.iscsi.physicalnetworkportal{
<#
.SYNOPSIS
List Physical Network Portal for iSCSI Adapter

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.physicalnetworkportal.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.physicalnetworkportal.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.physicalnetworkportal.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.physicalnetworkportal.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.physicalnetworkportal.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.physicalnetworkportal.list.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.iscsi.physicalnetworkportal.param{
<#
.SYNOPSIS
Get network parameters on a Physical Network Portal (vmnic)

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER nic
The physical network portal name: <vmnic>

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[string]$nic,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.physicalnetworkportal.param.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.physicalnetworkportal.param.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.physicalnetworkportal.param.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.physicalnetworkportal.param.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('nic')){
					if($HashTable.containskey('nic')){
						$HashTable.nic = $nic
					}
					Else{
						Write-error "The parameter nic is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.physicalnetworkportal.param.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter') -or $PSBoundParameters.ContainsKey('nic')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.physicalnetworkportal.param.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.iscsi.physicalnetworkportal.param{
<#
.SYNOPSIS
Set network parameter on a Physical Network Portal

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER nic
The physical network portal name: <vmnic>

.PARAMETER option
The network parameter option. Supported options are  [MTU, ArpRedirect].

.PARAMETER value
Input value for a Physical Network Portal option (use 0/1 for bool, and number for int)

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$option,
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true)]
	[long]$value,
	[string]$nic,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.physicalnetworkportal.param.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.physicalnetworkportal.param.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.physicalnetworkportal.param.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.physicalnetworkportal.param.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('option')){
					if($HashTable.containskey('option')){
						$HashTable.option = $option
					}
					Else{
						Write-error "The parameter option is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('value')){
					if($HashTable.containskey('value')){
						$HashTable.value = $value
					}
					Else{
						Write-error "The parameter value is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('nic')){
					if($HashTable.containskey('nic')){
						$HashTable.nic = $nic
					}
					Else{
						Write-error "The parameter nic is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.physicalnetworkportal.param.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('option') -or $PSBoundParameters.ContainsKey('adapter') -or $PSBoundParameters.ContainsKey('value') -or $PSBoundParameters.ContainsKey('nic')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.physicalnetworkportal.param.set.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.iscsi.plugin{
<#
.SYNOPSIS
List IMA plugins.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER plugin
The IMA plugin file name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$plugin,
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.plugin.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.plugin.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.plugin.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.plugin.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('plugin')){
					if($HashTable.containskey('plugin')){
						$HashTable.plugin = $plugin
					}
					Else{
						Write-error "The parameter plugin is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.plugin.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('plugin') -or $PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.plugin.list.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.iscsi.session{
<#
.SYNOPSIS
Login sessions on current iSCSI configuration.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER isid
The isid of a session to duplicate for login.

.PARAMETER name
The iSCSI target name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$isid,
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[string]$name,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.session.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.session.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.session.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.session.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('isid')){
					if($HashTable.containskey('isid')){
						$HashTable.isid = $isid
					}
					Else{
						Write-error "The parameter isid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('name')){
					if($HashTable.containskey('name')){
						$HashTable.name = $name
					}
					Else{
						Write-error "The parameter name is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.session.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('isid') -or $PSBoundParameters.ContainsKey('adapter') -or $PSBoundParameters.ContainsKey('name')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.session.add.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.iscsi.session{
<#
.SYNOPSIS
List iSCSI Sessions.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER isid
The iSCSI session identifier.

.PARAMETER name
The iSCSI target name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$isid,
	[string]$adapter,
	[string]$name,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.session.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.session.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.session.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.session.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('isid')){
					if($HashTable.containskey('isid')){
						$HashTable.isid = $isid
					}
					Else{
						Write-error "The parameter isid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('name')){
					if($HashTable.containskey('name')){
						$HashTable.name = $name
					}
					Else{
						Write-error "The parameter name is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.session.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('isid') -or $PSBoundParameters.ContainsKey('adapter') -or $PSBoundParameters.ContainsKey('name')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.session.list.invoke()
				}
			}
		}
	}
}

function remove-EsxCLI.iscsi.session{
<#
.SYNOPSIS
Logout sessions on current iSCSI configuration.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER isid
The isid of a session to duplicate for login.

.PARAMETER name
The name of the target to login to.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$isid,
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[string]$name,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.session.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.session.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.session.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.session.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('isid')){
					if($HashTable.containskey('isid')){
						$HashTable.isid = $isid
					}
					Else{
						Write-error "The parameter isid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('name')){
					if($HashTable.containskey('name')){
						$HashTable.name = $name
					}
					Else{
						Write-error "The parameter name is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.session.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('isid') -or $PSBoundParameters.ContainsKey('adapter') -or $PSBoundParameters.ContainsKey('name')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.session.remove.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.iscsi.session.connection{
<#
.SYNOPSIS
List iSCSI connections.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
The iSCSI adapter name.

.PARAMETER cid
The iSCSI connection identifier(CID).

.PARAMETER isid
The iSCSI session identifier(ISID).

.PARAMETER name
The iSCSI target name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$isid,
	[string]$adapter,
	[string]$name,
	[string]$cid,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.session.connection.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.session.connection.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.session.connection.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.session.connection.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('isid')){
					if($HashTable.containskey('isid')){
						$HashTable.isid = $isid
					}
					Else{
						Write-error "The parameter isid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('name')){
					if($HashTable.containskey('name')){
						$HashTable.name = $name
					}
					Else{
						Write-error "The parameter name is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('cid')){
					if($HashTable.containskey('cid')){
						$HashTable.cid = $cid
					}
					Else{
						Write-error "The parameter cid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.session.connection.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('isid') -or $PSBoundParameters.ContainsKey('adapter') -or $PSBoundParameters.ContainsKey('name') -or $PSBoundParameters.ContainsKey('cid')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.session.connection.list.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.iscsi.software{
<#
.SYNOPSIS
Software iSCSI information.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.software.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.software.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.iscsi.software.get.invoke()
		}
	}
}

function set-EsxCLI.iscsi.software{
<#
.SYNOPSIS
Enable or disable software iSCSI.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER enabled
Enable or disable the module.

.PARAMETER name
The iSCSI initiator name.
The initiator name must not be specified when disabling software iSCSI.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[boolean]$enabled,
	[string]$name,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.iscsi.software.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.iscsi.software.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.iscsi.software.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.iscsi.software.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('enabled')){
					if($HashTable.containskey('enabled')){
						$HashTable.enabled = $enabled
					}
					Else{
						Write-error "The parameter enabled is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('name')){
					if($HashTable.containskey('name')){
						$HashTable.name = $name
					}
					Else{
						Write-error "The parameter name is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.iscsi.software.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('enabled') -or $PSBoundParameters.ContainsKey('name')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.iscsi.software.set.invoke()
				}
			}
		}
	}
}

function ping-EsxCLI.network.diag{
<#
.SYNOPSIS
Send ICMP echo requests to network hosts.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER count
Specify the number of packets to send.

.PARAMETER debug2
VMKPing debug mode.

.PARAMETER df
Set DF bit on IPv4 packets.

.PARAMETER host2
Specify the host to send packets to. This parameter is required when not executing ping in debug mode (-D)

.PARAMETER interface
Specify the outgoing interface.

.PARAMETER interval
Set the interval for sending packets in seconds.

.PARAMETER ipv4
Ping with ICMPv4 echo requests.

.PARAMETER ipv6
Ping with ICMPv6 echo requests.

.PARAMETER netstack
Specify the TCP/IP netstack which the interface resides on

.PARAMETER nexthop
Override the system's default route selection, in dotted quad notation. (IPv4 only. Requires interface option)

.PARAMETER size
Set the payload size of the packets to send.

.PARAMETER ttl
Set IPv4 Time To Live or IPv6 Hop Limit

.PARAMETER wait
Set the timeout to wait if no responses are received in seconds.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$host2,
	[string]$wait,
	[boolean]$df,
	[string]$interval,
	[long]$ttl,
	[boolean]$debug2,
	[string]$nexthop,
	[long]$count,
	[string]$netstack,
	[long]$size,
	[boolean]$ipv4,
	[boolean]$ipv6,
	[string]$interface,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.diag.ping){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.diag.ping is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.diag.ping | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.diag.ping.CreateArgs()
				if($PSBoundParameters.ContainsKey('host2')){
					if($HashTable.containskey('host')){
						$HashTable.host = $host2
					}
					Else{
						Write-error "The parameter host2 is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('wait')){
					if($HashTable.containskey('wait')){
						$HashTable.wait = $wait
					}
					Else{
						Write-error "The parameter wait is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('df')){
					if($HashTable.containskey('df')){
						$HashTable.df = $df
					}
					Else{
						Write-error "The parameter df is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('interval')){
					if($HashTable.containskey('interval')){
						$HashTable.interval = $interval
					}
					Else{
						Write-error "The parameter interval is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ttl')){
					if($HashTable.containskey('ttl')){
						$HashTable.ttl = $ttl
					}
					Else{
						Write-error "The parameter ttl is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('debug2')){
					if($HashTable.containskey('debug')){
						$HashTable.debug = $debug2
					}
					Else{
						Write-error "The parameter debug2 is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('nexthop')){
					if($HashTable.containskey('nexthop')){
						$HashTable.nexthop = $nexthop
					}
					Else{
						Write-error "The parameter nexthop is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('count')){
					if($HashTable.containskey('count')){
						$HashTable.count = $count
					}
					Else{
						Write-error "The parameter count is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('netstack')){
					if($HashTable.containskey('netstack')){
						$HashTable.netstack = $netstack
					}
					Else{
						Write-error "The parameter netstack is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('size')){
					if($HashTable.containskey('size')){
						$HashTable.size = $size
					}
					Else{
						Write-error "The parameter size is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ipv4')){
					if($HashTable.containskey('ipv4')){
						$HashTable.ipv4 = $ipv4
					}
					Else{
						Write-error "The parameter ipv4 is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ipv6')){
					if($HashTable.containskey('ipv6')){
						$HashTable.ipv6 = $ipv6
					}
					Else{
						Write-error "The parameter ipv6 is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('interface')){
					if($HashTable.containskey('interface')){
						$HashTable.interface = $interface
					}
					Else{
						Write-error "The parameter interface is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.diag.ping.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('host2') -or $PSBoundParameters.ContainsKey('wait') -or $PSBoundParameters.ContainsKey('df') -or $PSBoundParameters.ContainsKey('interval') -or $PSBoundParameters.ContainsKey('ttl') -or $PSBoundParameters.ContainsKey('debug2') -or $PSBoundParameters.ContainsKey('nexthop') -or $PSBoundParameters.ContainsKey('count') -or $PSBoundParameters.ContainsKey('netstack') -or $PSBoundParameters.ContainsKey('size') -or $PSBoundParameters.ContainsKey('ipv4') -or $PSBoundParameters.ContainsKey('ipv6') -or $PSBoundParameters.ContainsKey('interface')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.diag.ping.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.network.firewall{
<#
.SYNOPSIS
Get the firewall status.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.firewall.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.firewall.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.network.firewall.get.invoke()
		}
	}
}

function load-EsxCLI.network.firewall{
<#
.SYNOPSIS
Load firewall module and rulesets configuration.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.firewall.load){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.firewall.load is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.network.firewall.load.invoke()
		}
	}
}

function refresh-EsxCLI.network.firewall{
<#
.SYNOPSIS
Load ruleset configuration for firewall.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.firewall.refresh){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.firewall.refresh is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.network.firewall.refresh.invoke()
		}
	}
}

function set-EsxCLI.network.firewall{
<#
.SYNOPSIS
Set firewall enabled status and default action.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER defaultaction
Set to true to set defaultaction PASS, set to false to DROP.

.PARAMETER enabled
Set to true to enable the firewall, set to false to disable the firewall.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$enabled,
	[boolean]$defaultaction,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.firewall.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.firewall.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.firewall.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.firewall.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('enabled')){
					if($HashTable.containskey('enabled')){
						$HashTable.enabled = $enabled
					}
					Else{
						Write-error "The parameter enabled is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('defaultaction')){
					if($HashTable.containskey('defaultaction')){
						$HashTable.defaultaction = $defaultaction
					}
					Else{
						Write-error "The parameter defaultaction is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.firewall.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('enabled') -or $PSBoundParameters.ContainsKey('defaultaction')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.firewall.set.invoke()
				}
			}
		}
	}
}

function unload-EsxCLI.network.firewall{
<#
.SYNOPSIS
Allow unload firewall module.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.firewall.unload){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.firewall.unload is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.network.firewall.unload.invoke()
		}
	}
}

function list-EsxCLI.network.firewall.ruleset{
<#
.SYNOPSIS
List the rulesets in firewall.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER rulesetid
List configuration for specfic ruleset

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$rulesetid,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.firewall.ruleset.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.firewall.ruleset.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.firewall.ruleset.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.firewall.ruleset.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('rulesetid')){
					if($HashTable.containskey('rulesetid')){
						$HashTable.rulesetid = $rulesetid
					}
					Else{
						Write-error "The parameter rulesetid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.firewall.ruleset.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('rulesetid')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.firewall.ruleset.list.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.network.firewall.ruleset{
<#
.SYNOPSIS
Set firewall ruleset status (allowedAll flag and enabled status).

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER allowedall
Set to true to allowed all ip, set to false to use allowed ip list.

.PARAMETER enabled
Set to true to enable ruleset, set to false to disable it.

.PARAMETER rulesetid
The label of the ruleset.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$enabled,
	[boolean]$allowedall,
	[Parameter(Mandatory=$true)]
	[string]$rulesetid,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.firewall.ruleset.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.firewall.ruleset.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.firewall.ruleset.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.firewall.ruleset.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('enabled')){
					if($HashTable.containskey('enabled')){
						$HashTable.enabled = $enabled
					}
					Else{
						Write-error "The parameter enabled is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('allowedall')){
					if($HashTable.containskey('allowedall')){
						$HashTable.allowedall = $allowedall
					}
					Else{
						Write-error "The parameter allowedall is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('rulesetid')){
					if($HashTable.containskey('rulesetid')){
						$HashTable.rulesetid = $rulesetid
					}
					Else{
						Write-error "The parameter rulesetid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.firewall.ruleset.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('enabled') -or $PSBoundParameters.ContainsKey('allowedall') -or $PSBoundParameters.ContainsKey('rulesetid')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.firewall.ruleset.set.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.network.firewall.ruleset.allowedip{
<#
.SYNOPSIS
Add allowed ip address/range to the ruleset ruleset.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER ipaddress
Allowed ip address/range for the ruleset.

.PARAMETER rulesetid
The label of the ruleset.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$rulesetid,
	[Parameter(Mandatory=$true)]
	[string]$ipaddress,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.firewall.ruleset.allowedip.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.firewall.ruleset.allowedip.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.firewall.ruleset.allowedip.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.firewall.ruleset.allowedip.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('rulesetid')){
					if($HashTable.containskey('rulesetid')){
						$HashTable.rulesetid = $rulesetid
					}
					Else{
						Write-error "The parameter rulesetid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ipaddress')){
					if($HashTable.containskey('ipaddress')){
						$HashTable.ipaddress = $ipaddress
					}
					Else{
						Write-error "The parameter ipaddress is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.firewall.ruleset.allowedip.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('rulesetid') -or $PSBoundParameters.ContainsKey('ipaddress')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.firewall.ruleset.allowedip.add.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.firewall.ruleset.allowedip{
<#
.SYNOPSIS
list allowed ip addresses for rulesets.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER rulesetid
The label of the ruleset.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$rulesetid,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.firewall.ruleset.allowedip.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.firewall.ruleset.allowedip.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.firewall.ruleset.allowedip.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.firewall.ruleset.allowedip.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('rulesetid')){
					if($HashTable.containskey('rulesetid')){
						$HashTable.rulesetid = $rulesetid
					}
					Else{
						Write-error "The parameter rulesetid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.firewall.ruleset.allowedip.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('rulesetid')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.firewall.ruleset.allowedip.list.invoke()
				}
			}
		}
	}
}

function remove-EsxCLI.network.firewall.ruleset.allowedip{
<#
.SYNOPSIS
Remove allowed ip address/range from the ruleset.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER ipaddress
Allowed ip address/range for the ruleset.

.PARAMETER rulesetid
The label of the ruleset.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$rulesetid,
	[Parameter(Mandatory=$true)]
	[string]$ipaddress,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.firewall.ruleset.allowedip.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.firewall.ruleset.allowedip.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.firewall.ruleset.allowedip.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.firewall.ruleset.allowedip.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('rulesetid')){
					if($HashTable.containskey('rulesetid')){
						$HashTable.rulesetid = $rulesetid
					}
					Else{
						Write-error "The parameter rulesetid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ipaddress')){
					if($HashTable.containskey('ipaddress')){
						$HashTable.ipaddress = $ipaddress
					}
					Else{
						Write-error "The parameter ipaddress is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.firewall.ruleset.allowedip.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('rulesetid') -or $PSBoundParameters.ContainsKey('ipaddress')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.firewall.ruleset.allowedip.remove.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.firewall.ruleset.rule{
<#
.SYNOPSIS
List the rules of each ruleset in firewall.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER rulesetid
List rules for specfic ruleset

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$rulesetid,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.firewall.ruleset.rule.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.firewall.ruleset.rule.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.firewall.ruleset.rule.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.firewall.ruleset.rule.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('rulesetid')){
					if($HashTable.containskey('rulesetid')){
						$HashTable.rulesetid = $rulesetid
					}
					Else{
						Write-error "The parameter rulesetid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.firewall.ruleset.rule.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('rulesetid')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.firewall.ruleset.rule.list.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.network.ip{
<#
.SYNOPSIS
Get global IP settings

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.network.ip.get.invoke()
		}
	}
}

function set-EsxCLI.network.ip{
<#
.SYNOPSIS
Update global IP settings

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER ipv6enabled
Enable or disable IPv6 (Reboot Required)

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$ipv6enabled,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('ipv6enabled')){
					if($HashTable.containskey('ipv6enabled')){
						$HashTable.ipv6enabled = $ipv6enabled
					}
					Else{
						Write-error "The parameter ipv6enabled is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('ipv6enabled')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.set.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.ip.connection{
<#
.SYNOPSIS
List active TCP/IP connections

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER netstack
The network stack instance; if unspecified, use the default netstack instance

.PARAMETER type
Connection type :  [ip, tcp, udp, all]

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$type,
	[string]$netstack,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.connection.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.connection.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.connection.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.connection.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('type')){
					if($HashTable.containskey('type')){
						$HashTable.type = $type
					}
					Else{
						Write-error "The parameter type is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('netstack')){
					if($HashTable.containskey('netstack')){
						$HashTable.netstack = $netstack
					}
					Else{
						Write-error "The parameter netstack is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.connection.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('type') -or $PSBoundParameters.ContainsKey('netstack')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.connection.list.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.network.ip.dns.search{
<#
.SYNOPSIS
Add a search domain to the list of domains to be searched when trying to resolve an host name on the ESXi host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER domain
The string name of a domain to add to the list of search domains.

.PARAMETER netstack
The network stack instance; if unspecified, use the default netstack instance

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$domain,
	[string]$netstack,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.dns.search.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.dns.search.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.dns.search.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.dns.search.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('domain')){
					if($HashTable.containskey('domain')){
						$HashTable.domain = $domain
					}
					Else{
						Write-error "The parameter domain is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('netstack')){
					if($HashTable.containskey('netstack')){
						$HashTable.netstack = $netstack
					}
					Else{
						Write-error "The parameter netstack is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.dns.search.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('domain') -or $PSBoundParameters.ContainsKey('netstack')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.dns.search.add.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.ip.dns.search{
<#
.SYNOPSIS
List the search domains currently configured on the ESXi host in the order in which they will be used when searching.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER netstack
The network stack instance; if unspecified, use the default netstack instance

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$netstack,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.dns.search.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.dns.search.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.dns.search.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.dns.search.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('netstack')){
					if($HashTable.containskey('netstack')){
						$HashTable.netstack = $netstack
					}
					Else{
						Write-error "The parameter netstack is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.dns.search.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('netstack')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.dns.search.list.invoke()
				}
			}
		}
	}
}

function remove-EsxCLI.network.ip.dns.search{
<#
.SYNOPSIS
Remove a search domain from the list of domains to be searched when trying to resolve an host name on the ESXi host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER domain
The string name of a domain to remove from the list of search domains.

.PARAMETER netstack
The network stack instance; if unspecified, use the default netstack instance

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$domain,
	[string]$netstack,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.dns.search.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.dns.search.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.dns.search.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.dns.search.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('domain')){
					if($HashTable.containskey('domain')){
						$HashTable.domain = $domain
					}
					Else{
						Write-error "The parameter domain is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('netstack')){
					if($HashTable.containskey('netstack')){
						$HashTable.netstack = $netstack
					}
					Else{
						Write-error "The parameter netstack is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.dns.search.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('domain') -or $PSBoundParameters.ContainsKey('netstack')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.dns.search.remove.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.network.ip.dns.server{
<#
.SYNOPSIS
Add a new DNS server to the end of the list of DNS servers to use for this ESXi host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER netstack
The network stack instance; if unspecified, use the default netstack instance

.PARAMETER server
The IP address (v4 or v6) of the DNS server to add to the DNS server list.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$server,
	[string]$netstack,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.dns.server.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.dns.server.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.dns.server.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.dns.server.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('server')){
					if($HashTable.containskey('server')){
						$HashTable.server = $server
					}
					Else{
						Write-error "The parameter server is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('netstack')){
					if($HashTable.containskey('netstack')){
						$HashTable.netstack = $netstack
					}
					Else{
						Write-error "The parameter netstack is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.dns.server.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('server') -or $PSBoundParameters.ContainsKey('netstack')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.dns.server.add.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.ip.dns.server{
<#
.SYNOPSIS
Print a list of the DNS server currently configured on the system in the order in which they will be used.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER netstack
The network stack instance; if unspecified, use the default netstack instance

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$netstack,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.dns.server.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.dns.server.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.dns.server.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.dns.server.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('netstack')){
					if($HashTable.containskey('netstack')){
						$HashTable.netstack = $netstack
					}
					Else{
						Write-error "The parameter netstack is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.dns.server.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('netstack')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.dns.server.list.invoke()
				}
			}
		}
	}
}

function remove-EsxCLI.network.ip.dns.server{
<#
.SYNOPSIS
Remove a DNS server from the list of DNS servers to use for this ESXi host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER all


.PARAMETER netstack
The network stack instance; if unspecified, use the default netstack instance

.PARAMETER server


.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$all,
	[string]$netstack,
	[Parameter(Mandatory=$true)]
	[string]$server,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.dns.server.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.dns.server.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.dns.server.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.dns.server.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('all')){
					if($HashTable.containskey('all')){
						$HashTable.all = $all
					}
					Else{
						Write-error "The parameter all is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('netstack')){
					if($HashTable.containskey('netstack')){
						$HashTable.netstack = $netstack
					}
					Else{
						Write-error "The parameter netstack is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('server')){
					if($HashTable.containskey('server')){
						$HashTable.server = $server
					}
					Else{
						Write-error "The parameter server is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.dns.server.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('all') -or $PSBoundParameters.ContainsKey('netstack') -or $PSBoundParameters.ContainsKey('server')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.dns.server.remove.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.network.ip.interface{
<#
.SYNOPSIS
Add a new VMkernel network interface.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER dvportid
DVPort ID of the connection point. This requires --dvs-name to be given in the same command

.PARAMETER dvsname
DVSwitch name of the connection point. This requires --dvport-id to be given in the same command

.PARAMETER interfacename
The name of the VMkernel network interface to create. This name must be in the form vmkX, where X is a number 0-255

.PARAMETER macaddress
Set the MAC address for the newly created VMkernel network interface.

.PARAMETER mtu
Set the MTU setting for a given VMkernel network interface on creation

.PARAMETER netstack
The network stack instance; if unspecified, use the default netstack instance

.PARAMETER portgroupname
The name of the vswitch port group to add this VMkernel network interface to.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$interfacename,
	[string]$portgroupname,
	[string]$dvportid,
	[long]$mtu,
	[string]$macaddress,
	[string]$netstack,
	[string]$dvsname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.interface.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.interface.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.interface.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.interface.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('interfacename')){
					if($HashTable.containskey('interfacename')){
						$HashTable.interfacename = $interfacename
					}
					Else{
						Write-error "The parameter interfacename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('portgroupname')){
					if($HashTable.containskey('portgroupname')){
						$HashTable.portgroupname = $portgroupname
					}
					Else{
						Write-error "The parameter portgroupname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('dvportid')){
					if($HashTable.containskey('dvportid')){
						$HashTable.dvportid = $dvportid
					}
					Else{
						Write-error "The parameter dvportid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('mtu')){
					if($HashTable.containskey('mtu')){
						$HashTable.mtu = $mtu
					}
					Else{
						Write-error "The parameter mtu is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('macaddress')){
					if($HashTable.containskey('macaddress')){
						$HashTable.macaddress = $macaddress
					}
					Else{
						Write-error "The parameter macaddress is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('netstack')){
					if($HashTable.containskey('netstack')){
						$HashTable.netstack = $netstack
					}
					Else{
						Write-error "The parameter netstack is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('dvsname')){
					if($HashTable.containskey('dvsname')){
						$HashTable.dvsname = $dvsname
					}
					Else{
						Write-error "The parameter dvsname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.interface.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('interfacename') -or $PSBoundParameters.ContainsKey('portgroupname') -or $PSBoundParameters.ContainsKey('dvportid') -or $PSBoundParameters.ContainsKey('mtu') -or $PSBoundParameters.ContainsKey('macaddress') -or $PSBoundParameters.ContainsKey('netstack') -or $PSBoundParameters.ContainsKey('dvsname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.interface.add.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.ip.interface{
<#
.SYNOPSIS
This command will list the VMkernel network interfaces currently known to the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER netstack
The network stack instance; if unspecified, consider all netstack instances

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$netstack,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.interface.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.interface.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.interface.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.interface.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('netstack')){
					if($HashTable.containskey('netstack')){
						$HashTable.netstack = $netstack
					}
					Else{
						Write-error "The parameter netstack is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.interface.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('netstack')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.interface.list.invoke()
				}
			}
		}
	}
}

function remove-EsxCLI.network.ip.interface{
<#
.SYNOPSIS
Remove a VMkernel network interface from the ESXi host. A VMKernel network interface can be uniquely specified by --interface-name or --portgroup-name or --dvs-name/--dvport-id. i.e. Providing its name or its connection point are two ways to uniquely specify a VMKernel network interface.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER dvportid
DVPort ID of the connection point. This requires --dvs-name to be given in the same command

.PARAMETER dvsname
DVSwitch name of the connection point. This requires --dvport-id to be given in the same command

.PARAMETER interfacename
The name of the VMkernel network interface to remove. This name must be in the form vmkX, where X is a number 0-255

.PARAMETER netstack
The network stack instance; if unspecified, use the default netstack instance

.PARAMETER portgroupname
The name of the vswitch port group to delete this VMkernel network interface from.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$interfacename,
	[string]$netstack,
	[string]$dvportid,
	[string]$dvsname,
	[string]$portgroupname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.interface.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.interface.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.interface.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.interface.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('interfacename')){
					if($HashTable.containskey('interfacename')){
						$HashTable.interfacename = $interfacename
					}
					Else{
						Write-error "The parameter interfacename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('netstack')){
					if($HashTable.containskey('netstack')){
						$HashTable.netstack = $netstack
					}
					Else{
						Write-error "The parameter netstack is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('dvportid')){
					if($HashTable.containskey('dvportid')){
						$HashTable.dvportid = $dvportid
					}
					Else{
						Write-error "The parameter dvportid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('dvsname')){
					if($HashTable.containskey('dvsname')){
						$HashTable.dvsname = $dvsname
					}
					Else{
						Write-error "The parameter dvsname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('portgroupname')){
					if($HashTable.containskey('portgroupname')){
						$HashTable.portgroupname = $portgroupname
					}
					Else{
						Write-error "The parameter portgroupname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.interface.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('interfacename') -or $PSBoundParameters.ContainsKey('netstack') -or $PSBoundParameters.ContainsKey('dvportid') -or $PSBoundParameters.ContainsKey('dvsname') -or $PSBoundParameters.ContainsKey('portgroupname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.interface.remove.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.network.ip.interface{
<#
.SYNOPSIS
This command sets the enabled status and MTU size of a given IP interface

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER enabled
Set to true to enable the interface, set to false to disable it.

.PARAMETER interfacename
The name of the interface to apply the configurations.

.PARAMETER mtu
The MTU size of the IP interface.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$interfacename,
	[boolean]$enabled,
	[long]$mtu,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.interface.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.interface.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.interface.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.interface.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('interfacename')){
					if($HashTable.containskey('interfacename')){
						$HashTable.interfacename = $interfacename
					}
					Else{
						Write-error "The parameter interfacename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('enabled')){
					if($HashTable.containskey('enabled')){
						$HashTable.enabled = $enabled
					}
					Else{
						Write-error "The parameter enabled is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('mtu')){
					if($HashTable.containskey('mtu')){
						$HashTable.mtu = $mtu
					}
					Else{
						Write-error "The parameter mtu is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.interface.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('interfacename') -or $PSBoundParameters.ContainsKey('enabled') -or $PSBoundParameters.ContainsKey('mtu')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.interface.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.network.ip.interface.ipv4{
<#
.SYNOPSIS
Get IPv4 settings for VMkernel network interfaces.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER interfacename
The name of the VMkernel network interface to limit the output of this command to.

.PARAMETER netstack
The network stack instance; if unspecified, consider all netstack instances

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$interfacename,
	[string]$netstack,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.interface.ipv4.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.interface.ipv4.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.interface.ipv4.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.interface.ipv4.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('interfacename')){
					if($HashTable.containskey('interfacename')){
						$HashTable.interfacename = $interfacename
					}
					Else{
						Write-error "The parameter interfacename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('netstack')){
					if($HashTable.containskey('netstack')){
						$HashTable.netstack = $netstack
					}
					Else{
						Write-error "The parameter netstack is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.interface.ipv4.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('interfacename') -or $PSBoundParameters.ContainsKey('netstack')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.interface.ipv4.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.network.ip.interface.ipv4{
<#
.SYNOPSIS
Configure IPv4 setting for a given VMkernel network interface.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER interfacename
The name of the VMkernel network interface to set IPv4 settings for. This name must be an interface listed in the interface list command.

.PARAMETER ipv4
The static IPv4 address for this interface.

.PARAMETER netmask
The static IPv4 netmask for this interface.

.PARAMETER peerdns
A boolean value to indicate if the system should use the DNS settings published via DHCP for this interface.

.PARAMETER type
IPv4 Address type : 
    dhcp: Use DHCP to aquire IPv4 setting for this interface.
    none: Remove IPv4 settings form this interface.
    static: Set Static IPv4 information for this interface. Requires --ipv4 and --netmask options.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$interfacename,
	[boolean]$peerdns,
	[Parameter(Mandatory=$true)]
	[string]$type,
	[string]$ipv4,
	[string]$netmask,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.interface.ipv4.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.interface.ipv4.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.interface.ipv4.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.interface.ipv4.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('interfacename')){
					if($HashTable.containskey('interfacename')){
						$HashTable.interfacename = $interfacename
					}
					Else{
						Write-error "The parameter interfacename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('peerdns')){
					if($HashTable.containskey('peerdns')){
						$HashTable.peerdns = $peerdns
					}
					Else{
						Write-error "The parameter peerdns is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('type')){
					if($HashTable.containskey('type')){
						$HashTable.type = $type
					}
					Else{
						Write-error "The parameter type is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ipv4')){
					if($HashTable.containskey('ipv4')){
						$HashTable.ipv4 = $ipv4
					}
					Else{
						Write-error "The parameter ipv4 is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('netmask')){
					if($HashTable.containskey('netmask')){
						$HashTable.netmask = $netmask
					}
					Else{
						Write-error "The parameter netmask is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.interface.ipv4.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('interfacename') -or $PSBoundParameters.ContainsKey('peerdns') -or $PSBoundParameters.ContainsKey('type') -or $PSBoundParameters.ContainsKey('ipv4') -or $PSBoundParameters.ContainsKey('netmask')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.interface.ipv4.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.network.ip.interface.ipv6{
<#
.SYNOPSIS
Get IPv6 settings for VMkernel network interfaces. This does not include the IPv6 addresses which can be found in the listipv6 command

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER interfacename
The name of the VMkernel network interface to limit the output of this command to.

.PARAMETER netstack
The network stack instance; if unspecified, consider all netstack instances

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$interfacename,
	[string]$netstack,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.interface.ipv6.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.interface.ipv6.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.interface.ipv6.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.interface.ipv6.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('interfacename')){
					if($HashTable.containskey('interfacename')){
						$HashTable.interfacename = $interfacename
					}
					Else{
						Write-error "The parameter interfacename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('netstack')){
					if($HashTable.containskey('netstack')){
						$HashTable.netstack = $netstack
					}
					Else{
						Write-error "The parameter netstack is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.interface.ipv6.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('interfacename') -or $PSBoundParameters.ContainsKey('netstack')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.interface.ipv6.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.network.ip.interface.ipv6{
<#
.SYNOPSIS
Configure IPv6 settings for a given VMkernel network interface.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER enabledhcpv6
Setting this value to true will enable DHCPv6 on this interface and attempt to aquire an IPv6 address from the network

.PARAMETER enablerouteradv
Setting this value to true will enable IPv6 Router Advertised IPv6 addresses to be added to this interface from any routers broadcasting on the local network.

.PARAMETER interfacename
The name of the VMkernel network interface to set IPv6 settings for. This name must be an interface listed in the interface list command.

.PARAMETER peerdns
A boolean value to indicate if the system should use the DNS settings published via DHCPv6 for this interface.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$interfacename,
	[boolean]$enabledhcpv6,
	[boolean]$peerdns,
	[boolean]$enablerouteradv,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.interface.ipv6.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.interface.ipv6.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.interface.ipv6.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.interface.ipv6.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('interfacename')){
					if($HashTable.containskey('interfacename')){
						$HashTable.interfacename = $interfacename
					}
					Else{
						Write-error "The parameter interfacename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('enabledhcpv6')){
					if($HashTable.containskey('enabledhcpv6')){
						$HashTable.enabledhcpv6 = $enabledhcpv6
					}
					Else{
						Write-error "The parameter enabledhcpv6 is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('peerdns')){
					if($HashTable.containskey('peerdns')){
						$HashTable.peerdns = $peerdns
					}
					Else{
						Write-error "The parameter peerdns is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('enablerouteradv')){
					if($HashTable.containskey('enablerouteradv')){
						$HashTable.enablerouteradv = $enablerouteradv
					}
					Else{
						Write-error "The parameter enablerouteradv is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.interface.ipv6.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('interfacename') -or $PSBoundParameters.ContainsKey('enabledhcpv6') -or $PSBoundParameters.ContainsKey('peerdns') -or $PSBoundParameters.ContainsKey('enablerouteradv')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.interface.ipv6.set.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.network.ip.interface.ipv6.address{
<#
.SYNOPSIS
Add a static IPv6 address to a given VMkernel network interface.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER interfacename
The name of the VMkernel network interface to add a static IPv6 address to. This name must be an interface listed in the interface list command.

.PARAMETER ipv6
The IPv6 address to add to the given VMkernel network interface. This must be in X:X:X::/X format

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$interfacename,
	[Parameter(Mandatory=$true)]
	[string]$ipv6,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.interface.ipv6.address.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.interface.ipv6.address.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.interface.ipv6.address.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.interface.ipv6.address.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('interfacename')){
					if($HashTable.containskey('interfacename')){
						$HashTable.interfacename = $interfacename
					}
					Else{
						Write-error "The parameter interfacename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ipv6')){
					if($HashTable.containskey('ipv6')){
						$HashTable.ipv6 = $ipv6
					}
					Else{
						Write-error "The parameter ipv6 is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.interface.ipv6.address.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('interfacename') -or $PSBoundParameters.ContainsKey('ipv6')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.interface.ipv6.address.add.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.ip.interface.ipv6.address{
<#
.SYNOPSIS
This command will list all of the IPv6 addresses currently assigned to the system

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER interfacename
The name of the VMkernel network interface to limit the output of this command to.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$interfacename,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.interface.ipv6.address.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.interface.ipv6.address.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.interface.ipv6.address.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.interface.ipv6.address.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('interfacename')){
					if($HashTable.containskey('interfacename')){
						$HashTable.interfacename = $interfacename
					}
					Else{
						Write-error "The parameter interfacename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.interface.ipv6.address.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('interfacename')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.interface.ipv6.address.list.invoke()
				}
			}
		}
	}
}

function remove-EsxCLI.network.ip.interface.ipv6.address{
<#
.SYNOPSIS
Remove an IPv6 address from a given VMkernel network interface.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER interfacename
The name of the VMkernel network interface to remove an IPv6 address from. This name must be an interface listed in the interface list command.

.PARAMETER ipv6
The IPv6 address to remove from the given VMkernel network interface. This must be in X:X:X::/X format

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$interfacename,
	[Parameter(Mandatory=$true)]
	[string]$ipv6,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.interface.ipv6.address.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.interface.ipv6.address.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.interface.ipv6.address.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.interface.ipv6.address.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('interfacename')){
					if($HashTable.containskey('interfacename')){
						$HashTable.interfacename = $interfacename
					}
					Else{
						Write-error "The parameter interfacename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ipv6')){
					if($HashTable.containskey('ipv6')){
						$HashTable.ipv6 = $ipv6
					}
					Else{
						Write-error "The parameter ipv6 is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.interface.ipv6.address.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('interfacename') -or $PSBoundParameters.ContainsKey('ipv6')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.interface.ipv6.address.remove.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.network.ip.interface.tag{
<#
.SYNOPSIS
Adds a tag on a given VMkernel network interface. Supported tags are: Management, VMotion, faultToleranceLogging, vSphereReplication, vSphereReplicationNFC, vSphereProvisioning, VSAN

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER interfacename
The name of the VMkernel network interface on which tags should be set. This name must be an interface listed in the interface list command.

.PARAMETER tagname
Tag name to assign to the interface

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$interfacename,
	[Parameter(Mandatory=$true)]
	[string]$tagname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.interface.tag.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.interface.tag.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.interface.tag.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.interface.tag.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('interfacename')){
					if($HashTable.containskey('interfacename')){
						$HashTable.interfacename = $interfacename
					}
					Else{
						Write-error "The parameter interfacename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('tagname')){
					if($HashTable.containskey('tagname')){
						$HashTable.tagname = $tagname
					}
					Else{
						Write-error "The parameter tagname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.interface.tag.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('interfacename') -or $PSBoundParameters.ContainsKey('tagname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.interface.tag.add.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.network.ip.interface.tag{
<#
.SYNOPSIS
Gets the tags set on the given VMkernel network interface.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER interfacename
Name of vmknic whose tags are to be read

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$interfacename,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.interface.tag.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.interface.tag.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.interface.tag.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.interface.tag.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('interfacename')){
					if($HashTable.containskey('interfacename')){
						$HashTable.interfacename = $interfacename
					}
					Else{
						Write-error "The parameter interfacename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.interface.tag.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('interfacename')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.interface.tag.get.invoke()
				}
			}
		}
	}
}

function remove-EsxCLI.network.ip.interface.tag{
<#
.SYNOPSIS
Removes a tag on a given VMkernel network interface.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER interfacename
The name of the VMkernel network interface from which tags should be removed. This name must be an interface listed  in the interface list command.

.PARAMETER tagname
Tag name to assign to the interface

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$interfacename,
	[Parameter(Mandatory=$true)]
	[string]$tagname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.interface.tag.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.interface.tag.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.interface.tag.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.interface.tag.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('interfacename')){
					if($HashTable.containskey('interfacename')){
						$HashTable.interfacename = $interfacename
					}
					Else{
						Write-error "The parameter interfacename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('tagname')){
					if($HashTable.containskey('tagname')){
						$HashTable.tagname = $tagname
					}
					Else{
						Write-error "The parameter tagname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.interface.tag.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('interfacename') -or $PSBoundParameters.ContainsKey('tagname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.interface.tag.remove.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.network.ip.ipsec{
<#
.SYNOPSIS
Set IKE config file path.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER ikeconf
Pass an IKE config path to IKE daemon, this will copy the config to IKE config and restart IKE daemons

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$ikeconf,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.ipsec.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.ipsec.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.ipsec.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.ipsec.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('ikeconf')){
					if($HashTable.containskey('ikeconf')){
						$HashTable.ikeconf = $ikeconf
					}
					Else{
						Write-error "The parameter ikeconf is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.ipsec.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('ikeconf')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.ipsec.set.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.network.ip.ipsec.sa{
<#
.SYNOPSIS
Add a Security Association.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER encryptionalgorithm
Encryption algorithm for the Security Association. Should be one in set  [null, 3des-cbc, aes128-cbc].

.PARAMETER encryptionkey
Encryption key(ASCII or hex). Length of hex key is dependent upon algorithm used. Required when a encryption algorithm has been specified.

.PARAMETER integrityalgorithm
Integrity algorithm for the Security Association. Should be one in set  [hmac-sha1, hmac-sha2-256].

.PARAMETER integritykey
Integrity key(ASCII or hex). Length of hex key is dependent upon algorithm used.

.PARAMETER sadestination
Ipv6 address of Security Association destination. Can be specified as 'any' or a correct IPv6 address.

.PARAMETER samode
Security Association mode. Should be one in set  [transport, tunnel].

.PARAMETER saname
Name for the Security Association to be added.

.PARAMETER sasource
Ipv6 address of Security Association source. Can be specified as 'any' or a correct IPv6 address.

.PARAMETER saspi
SPI value for the Security Association(hex).

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$samode,
	[Parameter(Mandatory=$true)]
	[string]$saspi,
	[Parameter(Mandatory=$true)]
	[string]$integritykey,
	[Parameter(Mandatory=$true)]
	[string]$sadestination,
	[Parameter(Mandatory=$true)]
	[string]$saname,
	[Parameter(Mandatory=$true)]
	[string]$sasource,
	[Parameter(Mandatory=$true)]
	[string]$integrityalgorithm,
	[Parameter(Mandatory=$true)]
	[string]$encryptionalgorithm,
	[string]$encryptionkey,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.ipsec.sa.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.ipsec.sa.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.ipsec.sa.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.ipsec.sa.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('samode')){
					if($HashTable.containskey('samode')){
						$HashTable.samode = $samode
					}
					Else{
						Write-error "The parameter samode is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('saspi')){
					if($HashTable.containskey('saspi')){
						$HashTable.saspi = $saspi
					}
					Else{
						Write-error "The parameter saspi is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('integritykey')){
					if($HashTable.containskey('integritykey')){
						$HashTable.integritykey = $integritykey
					}
					Else{
						Write-error "The parameter integritykey is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('sadestination')){
					if($HashTable.containskey('sadestination')){
						$HashTable.sadestination = $sadestination
					}
					Else{
						Write-error "The parameter sadestination is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('saname')){
					if($HashTable.containskey('saname')){
						$HashTable.saname = $saname
					}
					Else{
						Write-error "The parameter saname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('sasource')){
					if($HashTable.containskey('sasource')){
						$HashTable.sasource = $sasource
					}
					Else{
						Write-error "The parameter sasource is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('integrityalgorithm')){
					if($HashTable.containskey('integrityalgorithm')){
						$HashTable.integrityalgorithm = $integrityalgorithm
					}
					Else{
						Write-error "The parameter integrityalgorithm is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('encryptionalgorithm')){
					if($HashTable.containskey('encryptionalgorithm')){
						$HashTable.encryptionalgorithm = $encryptionalgorithm
					}
					Else{
						Write-error "The parameter encryptionalgorithm is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('encryptionkey')){
					if($HashTable.containskey('encryptionkey')){
						$HashTable.encryptionkey = $encryptionkey
					}
					Else{
						Write-error "The parameter encryptionkey is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.ipsec.sa.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('samode') -or $PSBoundParameters.ContainsKey('saspi') -or $PSBoundParameters.ContainsKey('integritykey') -or $PSBoundParameters.ContainsKey('sadestination') -or $PSBoundParameters.ContainsKey('saname') -or $PSBoundParameters.ContainsKey('sasource') -or $PSBoundParameters.ContainsKey('integrityalgorithm') -or $PSBoundParameters.ContainsKey('encryptionalgorithm') -or $PSBoundParameters.ContainsKey('encryptionkey')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.ipsec.sa.add.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.ip.ipsec.sa{
<#
.SYNOPSIS
List configured Security Associations

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.ipsec.sa.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.ipsec.sa.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.network.ip.ipsec.sa.list.invoke()
		}
	}
}

function remove-EsxCLI.network.ip.ipsec.sa{
<#
.SYNOPSIS
Operation to remove Security Association(s)

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER removeall
Set to remove all Security Associations.

.PARAMETER sadestination
Ipv6 address of Security Association destination. This option needs to be specified when removing an auto SA.

.PARAMETER saname
Name for the Security Association to be removed. Specify 'auto' to remove an auto SA.

.PARAMETER sasource
Ipv6 address of Security Association source. This option needs to be specified when removing an auto SA.

.PARAMETER saspi
SPI value for the Security Association (hex). This option needs to be specified when removing an auto SA

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$saspi,
	[string]$sasource,
	[string]$sadestination,
	[boolean]$removeall,
	[string]$saname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.ipsec.sa.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.ipsec.sa.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.ipsec.sa.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.ipsec.sa.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('saspi')){
					if($HashTable.containskey('saspi')){
						$HashTable.saspi = $saspi
					}
					Else{
						Write-error "The parameter saspi is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('sasource')){
					if($HashTable.containskey('sasource')){
						$HashTable.sasource = $sasource
					}
					Else{
						Write-error "The parameter sasource is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('sadestination')){
					if($HashTable.containskey('sadestination')){
						$HashTable.sadestination = $sadestination
					}
					Else{
						Write-error "The parameter sadestination is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('removeall')){
					if($HashTable.containskey('removeall')){
						$HashTable.removeall = $removeall
					}
					Else{
						Write-error "The parameter removeall is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('saname')){
					if($HashTable.containskey('saname')){
						$HashTable.saname = $saname
					}
					Else{
						Write-error "The parameter saname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.ipsec.sa.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('saspi') -or $PSBoundParameters.ContainsKey('sasource') -or $PSBoundParameters.ContainsKey('sadestination') -or $PSBoundParameters.ContainsKey('removeall') -or $PSBoundParameters.ContainsKey('saname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.ipsec.sa.remove.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.network.ip.ipsec.sp{
<#
.SYNOPSIS
Add a Security Policy.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER action
Action for Security Policy. Should be one in set  [none, discard, ipsec].

.PARAMETER destinationport
Destination Port for Security Policy. '0' stands for 'any'

.PARAMETER flowdirection
Flow direction for Security Policy. Should be one in set  [in, out].

.PARAMETER saname
Name for the Security Association. Not being Specified lets vmkernel automatically choose an Security Association. If no applicable Security Association exists, then vmkernel may request one using IKE.

.PARAMETER sourceport
Source Port for Security Policy. '0' stands for 'any'

.PARAMETER spdestination
Ipv6 address and prefix length of Security Policy destination. Can be specified as 'any' or a correct Ipv6 network address.

.PARAMETER spmode
Security Policy mode. Should be one in set  [transport, tunnel].

.PARAMETER spname
Name for the Security Policy to be added.

.PARAMETER spsource
Ipv6 address and prefix length of Security Policy source. Can be specified as 'any' or a correct IPv6 network address.

.PARAMETER upperlayerprotocol
Upper layer protocol for Security Policy, Should be one in set  [any, tcp, udp, icmp6].

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[long]$sourceport,
	[string]$action,
	[Parameter(Mandatory=$true)]
	[string]$spname,
	[Parameter(Mandatory=$true)]
	[long]$destinationport,
	[string]$saname,
	[Parameter(Mandatory=$true)]
	[string]$spdestination,
	[string]$spmode,
	[Parameter(Mandatory=$true)]
	[string]$spsource,
	[string]$upperlayerprotocol,
	[string]$flowdirection,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.ipsec.sp.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.ipsec.sp.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.ipsec.sp.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.ipsec.sp.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('sourceport')){
					if($HashTable.containskey('sourceport')){
						$HashTable.sourceport = $sourceport
					}
					Else{
						Write-error "The parameter sourceport is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('action')){
					if($HashTable.containskey('action')){
						$HashTable.action = $action
					}
					Else{
						Write-error "The parameter action is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('spname')){
					if($HashTable.containskey('spname')){
						$HashTable.spname = $spname
					}
					Else{
						Write-error "The parameter spname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('destinationport')){
					if($HashTable.containskey('destinationport')){
						$HashTable.destinationport = $destinationport
					}
					Else{
						Write-error "The parameter destinationport is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('saname')){
					if($HashTable.containskey('saname')){
						$HashTable.saname = $saname
					}
					Else{
						Write-error "The parameter saname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('spdestination')){
					if($HashTable.containskey('spdestination')){
						$HashTable.spdestination = $spdestination
					}
					Else{
						Write-error "The parameter spdestination is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('spmode')){
					if($HashTable.containskey('spmode')){
						$HashTable.spmode = $spmode
					}
					Else{
						Write-error "The parameter spmode is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('spsource')){
					if($HashTable.containskey('spsource')){
						$HashTable.spsource = $spsource
					}
					Else{
						Write-error "The parameter spsource is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('upperlayerprotocol')){
					if($HashTable.containskey('upperlayerprotocol')){
						$HashTable.upperlayerprotocol = $upperlayerprotocol
					}
					Else{
						Write-error "The parameter upperlayerprotocol is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('flowdirection')){
					if($HashTable.containskey('flowdirection')){
						$HashTable.flowdirection = $flowdirection
					}
					Else{
						Write-error "The parameter flowdirection is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.ipsec.sp.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('sourceport') -or $PSBoundParameters.ContainsKey('action') -or $PSBoundParameters.ContainsKey('spname') -or $PSBoundParameters.ContainsKey('destinationport') -or $PSBoundParameters.ContainsKey('saname') -or $PSBoundParameters.ContainsKey('spdestination') -or $PSBoundParameters.ContainsKey('spmode') -or $PSBoundParameters.ContainsKey('spsource') -or $PSBoundParameters.ContainsKey('upperlayerprotocol') -or $PSBoundParameters.ContainsKey('flowdirection')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.ipsec.sp.add.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.ip.ipsec.sp{
<#
.SYNOPSIS
List configured Security Policys

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.ipsec.sp.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.ipsec.sp.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.network.ip.ipsec.sp.list.invoke()
		}
	}
}

function remove-EsxCLI.network.ip.ipsec.sp{
<#
.SYNOPSIS
Operation to remove Security Policy

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER removeall
Set to remove all Security Policys

.PARAMETER spname
Name for the Security Policy to be removed.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$spname,
	[boolean]$removeall,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.ipsec.sp.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.ipsec.sp.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.ipsec.sp.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.ipsec.sp.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('spname')){
					if($HashTable.containskey('spname')){
						$HashTable.spname = $spname
					}
					Else{
						Write-error "The parameter spname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('removeall')){
					if($HashTable.containskey('removeall')){
						$HashTable.removeall = $removeall
					}
					Else{
						Write-error "The parameter removeall is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.ipsec.sp.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('spname') -or $PSBoundParameters.ContainsKey('removeall')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.ipsec.sp.remove.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.ip.neighbor{
<#
.SYNOPSIS
List ARP table entries

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER interfacename
The name of the VMkernel network interface to limit the output of this command to; if unspecified, list neighbors on all interfaces.

.PARAMETER netstack
The network stack instance; if unspecified, use the default netstack instance

.PARAMETER version2
IP version :  [4, 6, all]

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$interfacename,
	[string]$netstack,
	[string]$version2,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.neighbor.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.neighbor.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.neighbor.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.neighbor.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('interfacename')){
					if($HashTable.containskey('interfacename')){
						$HashTable.interfacename = $interfacename
					}
					Else{
						Write-error "The parameter interfacename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('netstack')){
					if($HashTable.containskey('netstack')){
						$HashTable.netstack = $netstack
					}
					Else{
						Write-error "The parameter netstack is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('version2')){
					if($HashTable.containskey('version')){
						$HashTable.version = $version2
					}
					Else{
						Write-error "The parameter version2 is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.neighbor.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('interfacename') -or $PSBoundParameters.ContainsKey('netstack') -or $PSBoundParameters.ContainsKey('version2')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.neighbor.list.invoke()
				}
			}
		}
	}
}

function remove-EsxCLI.network.ip.neighbor{
<#
.SYNOPSIS
Remove ARP table entries

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER interfacename
The name of the VMkernel network interface to remove the neighbor entry from. If not specified, neighbor will be removed from all interfaces

.PARAMETER neighboraddr
The IPv4/IPv6 address of the neighbor.

.PARAMETER netstack
The network stack instance; if unspecified, use the default netstack instance

.PARAMETER version2
IP version :  [4, 6]

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$interfacename,
	[string]$netstack,
	[Parameter(Mandatory=$true)]
	[string]$neighboraddr,
	[Parameter(Mandatory=$true)]
	[string]$version2,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.neighbor.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.neighbor.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.neighbor.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.neighbor.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('interfacename')){
					if($HashTable.containskey('interfacename')){
						$HashTable.interfacename = $interfacename
					}
					Else{
						Write-error "The parameter interfacename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('netstack')){
					if($HashTable.containskey('netstack')){
						$HashTable.netstack = $netstack
					}
					Else{
						Write-error "The parameter netstack is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('neighboraddr')){
					if($HashTable.containskey('neighboraddr')){
						$HashTable.neighboraddr = $neighboraddr
					}
					Else{
						Write-error "The parameter neighboraddr is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('version2')){
					if($HashTable.containskey('version')){
						$HashTable.version = $version2
					}
					Else{
						Write-error "The parameter version2 is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.neighbor.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('interfacename') -or $PSBoundParameters.ContainsKey('netstack') -or $PSBoundParameters.ContainsKey('neighboraddr') -or $PSBoundParameters.ContainsKey('version2')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.neighbor.remove.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.network.ip.netstack{
<#
.SYNOPSIS
Add a new Netstack Instance.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER disabled
Create the netstack instance only in config i.e. in disabled state. Does not create in kernel.

.PARAMETER netstack
The network stack instance

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$disabled,
	[Parameter(Mandatory=$true)]
	[string]$netstack,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.netstack.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.netstack.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.netstack.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.netstack.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('disabled')){
					if($HashTable.containskey('disabled')){
						$HashTable.disabled = $disabled
					}
					Else{
						Write-error "The parameter disabled is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('netstack')){
					if($HashTable.containskey('netstack')){
						$HashTable.netstack = $netstack
					}
					Else{
						Write-error "The parameter netstack is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.netstack.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('disabled') -or $PSBoundParameters.ContainsKey('netstack')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.netstack.add.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.network.ip.netstack{
<#
.SYNOPSIS
Get runtime/configuration settings for a given Netstack Instance.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER netstack
The network stack instance

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$netstack,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.netstack.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.netstack.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.netstack.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.netstack.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('netstack')){
					if($HashTable.containskey('netstack')){
						$HashTable.netstack = $netstack
					}
					Else{
						Write-error "The parameter netstack is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.netstack.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('netstack')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.netstack.get.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.ip.netstack{
<#
.SYNOPSIS
This command will list the VMkernel Netstack instances currently known to the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.netstack.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.netstack.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.network.ip.netstack.list.invoke()
		}
	}
}

function remove-EsxCLI.network.ip.netstack{
<#
.SYNOPSIS
Remove a new Netstack Instance.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER netstack
The network stack instance

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$netstack,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.netstack.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.netstack.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.netstack.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.netstack.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('netstack')){
					if($HashTable.containskey('netstack')){
						$HashTable.netstack = $netstack
					}
					Else{
						Write-error "The parameter netstack is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.netstack.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('netstack')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.netstack.remove.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.network.ip.netstack{
<#
.SYNOPSIS
Configure settings for a given Netstack Instance.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER ccalgo
The TCP Congestion Contol Algorithm for this netstack instance (not applied to existing connections).: 
    cubic: Set cubic as the algorithm
    newreno: Set newreno as the algorithm

.PARAMETER enable
Enable the netstack instance (create in kernel)

.PARAMETER ipv6enabled
To enable IPv6 for this netstack instance (aplied only during netstack creation).

.PARAMETER maxconn
The maximum number of connections for this netstack instance (applied only during netstack creation).

.PARAMETER name
The name for this netstack instance.

.PARAMETER netstack
The network stack instance. This name must be an interface listed in the netstack list command.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[long]$maxconn,
	[boolean]$enable,
	[string]$name,
	[boolean]$ipv6enabled,
	[Parameter(Mandatory=$true)]
	[string]$netstack,
	[string]$ccalgo,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.netstack.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.netstack.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.netstack.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.netstack.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('maxconn')){
					if($HashTable.containskey('maxconn')){
						$HashTable.maxconn = $maxconn
					}
					Else{
						Write-error "The parameter maxconn is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('enable')){
					if($HashTable.containskey('enable')){
						$HashTable.enable = $enable
					}
					Else{
						Write-error "The parameter enable is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('name')){
					if($HashTable.containskey('name')){
						$HashTable.name = $name
					}
					Else{
						Write-error "The parameter name is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ipv6enabled')){
					if($HashTable.containskey('ipv6enabled')){
						$HashTable.ipv6enabled = $ipv6enabled
					}
					Else{
						Write-error "The parameter ipv6enabled is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('netstack')){
					if($HashTable.containskey('netstack')){
						$HashTable.netstack = $netstack
					}
					Else{
						Write-error "The parameter netstack is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ccalgo')){
					if($HashTable.containskey('ccalgo')){
						$HashTable.ccalgo = $ccalgo
					}
					Else{
						Write-error "The parameter ccalgo is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.netstack.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('maxconn') -or $PSBoundParameters.ContainsKey('enable') -or $PSBoundParameters.ContainsKey('name') -or $PSBoundParameters.ContainsKey('ipv6enabled') -or $PSBoundParameters.ContainsKey('netstack') -or $PSBoundParameters.ContainsKey('ccalgo')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.netstack.set.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.network.ip.route.ipv4{
<#
.SYNOPSIS
Add IPv4 route to the VMkernel.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER gateway
The Ipv4 address of the gateway through which a route to be added.

.PARAMETER netstack
The network stack instance; if unspecified, use the default netstack instance

.PARAMETER network
The Ipv4 address and prefix length of the network to add the route to. Specify 'default' to indicate the default network.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$netstack,
	[Parameter(Mandatory=$true)]
	[string]$gateway,
	[Parameter(Mandatory=$true)]
	[string]$network,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.route.ipv4.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.route.ipv4.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.route.ipv4.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.route.ipv4.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('netstack')){
					if($HashTable.containskey('netstack')){
						$HashTable.netstack = $netstack
					}
					Else{
						Write-error "The parameter netstack is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('gateway')){
					if($HashTable.containskey('gateway')){
						$HashTable.gateway = $gateway
					}
					Else{
						Write-error "The parameter gateway is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('network')){
					if($HashTable.containskey('network')){
						$HashTable.network = $network
					}
					Else{
						Write-error "The parameter network is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.route.ipv4.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('netstack') -or $PSBoundParameters.ContainsKey('gateway') -or $PSBoundParameters.ContainsKey('network')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.route.ipv4.add.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.ip.route.ipv4{
<#
.SYNOPSIS
List configured IPv4 routes

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER netstack
The network stack instance; if unspecified, use the default netstack instance

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$netstack,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.route.ipv4.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.route.ipv4.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.route.ipv4.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.route.ipv4.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('netstack')){
					if($HashTable.containskey('netstack')){
						$HashTable.netstack = $netstack
					}
					Else{
						Write-error "The parameter netstack is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.route.ipv4.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('netstack')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.route.ipv4.list.invoke()
				}
			}
		}
	}
}

function remove-EsxCLI.network.ip.route.ipv4{
<#
.SYNOPSIS
Remove IPv4 route

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER gateway
The Ipv4 address of the gateway through which a route to be removed

.PARAMETER netstack
The network stack instance; if unspecified, use the default netstack instance

.PARAMETER network
The Ipv4 address and prefix length of the network to remove the route from. Specify 'default' to indicate the default network.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$netstack,
	[Parameter(Mandatory=$true)]
	[string]$gateway,
	[Parameter(Mandatory=$true)]
	[string]$network,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.route.ipv4.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.route.ipv4.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.route.ipv4.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.route.ipv4.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('netstack')){
					if($HashTable.containskey('netstack')){
						$HashTable.netstack = $netstack
					}
					Else{
						Write-error "The parameter netstack is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('gateway')){
					if($HashTable.containskey('gateway')){
						$HashTable.gateway = $gateway
					}
					Else{
						Write-error "The parameter gateway is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('network')){
					if($HashTable.containskey('network')){
						$HashTable.network = $network
					}
					Else{
						Write-error "The parameter network is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.route.ipv4.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('netstack') -or $PSBoundParameters.ContainsKey('gateway') -or $PSBoundParameters.ContainsKey('network')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.route.ipv4.remove.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.network.ip.route.ipv6{
<#
.SYNOPSIS
Add IPv6 route to the VMkernel.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER gateway
The Ipv6 address of the gateway through which a route to be added.

.PARAMETER netstack
The network stack instance; if unspecified, use the default netstack instance

.PARAMETER network
The Ipv6 address and prefix length of the network to add the route to. Specify 'default' to indicate the default network.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$netstack,
	[Parameter(Mandatory=$true)]
	[string]$gateway,
	[Parameter(Mandatory=$true)]
	[string]$network,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.route.ipv6.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.route.ipv6.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.route.ipv6.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.route.ipv6.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('netstack')){
					if($HashTable.containskey('netstack')){
						$HashTable.netstack = $netstack
					}
					Else{
						Write-error "The parameter netstack is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('gateway')){
					if($HashTable.containskey('gateway')){
						$HashTable.gateway = $gateway
					}
					Else{
						Write-error "The parameter gateway is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('network')){
					if($HashTable.containskey('network')){
						$HashTable.network = $network
					}
					Else{
						Write-error "The parameter network is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.route.ipv6.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('netstack') -or $PSBoundParameters.ContainsKey('gateway') -or $PSBoundParameters.ContainsKey('network')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.route.ipv6.add.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.ip.route.ipv6{
<#
.SYNOPSIS
List configured IPv6 routes

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER netstack
The network stack instance; if unspecified, use the default netstack instance

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$netstack,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.route.ipv6.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.route.ipv6.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.route.ipv6.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.route.ipv6.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('netstack')){
					if($HashTable.containskey('netstack')){
						$HashTable.netstack = $netstack
					}
					Else{
						Write-error "The parameter netstack is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.route.ipv6.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('netstack')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.route.ipv6.list.invoke()
				}
			}
		}
	}
}

function remove-EsxCLI.network.ip.route.ipv6{
<#
.SYNOPSIS
Remove IPv6 route from the VMkernel

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER gateway
The Ipv6 address of the gateway through which a route to be removed

.PARAMETER netstack
The network stack instance; if unspecified, use the default netstack instance

.PARAMETER network
The Ipv6 address and prefix length of the network to remove the route from. Specify 'default' to indicate the default network.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$netstack,
	[Parameter(Mandatory=$true)]
	[string]$gateway,
	[Parameter(Mandatory=$true)]
	[string]$network,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.ip.route.ipv6.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.ip.route.ipv6.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.ip.route.ipv6.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.ip.route.ipv6.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('netstack')){
					if($HashTable.containskey('netstack')){
						$HashTable.netstack = $netstack
					}
					Else{
						Write-error "The parameter netstack is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('gateway')){
					if($HashTable.containskey('gateway')){
						$HashTable.gateway = $gateway
					}
					Else{
						Write-error "The parameter gateway is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('network')){
					if($HashTable.containskey('network')){
						$HashTable.network = $network
					}
					Else{
						Write-error "The parameter network is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.ip.route.ipv6.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('netstack') -or $PSBoundParameters.ContainsKey('gateway') -or $PSBoundParameters.ContainsKey('network')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.ip.route.ipv6.remove.invoke()
				}
			}
		}
	}
}

function down-EsxCLI.network.nic{
<#
.SYNOPSIS
Bring down the specified network device.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER nicname
The name of the NIC to configured. This must be one of the cards listed in the nic list command.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$nicname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.nic.down){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.nic.down is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.nic.down | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.nic.down.CreateArgs()
				if($PSBoundParameters.ContainsKey('nicname')){
					if($HashTable.containskey('nicname')){
						$HashTable.nicname = $nicname
					}
					Else{
						Write-error "The parameter nicname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.nic.down.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('nicname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.nic.down.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.network.nic{
<#
.SYNOPSIS
Get the generic configuration of a network device

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER nicname
The name of the NIC to configured. This must be one of the cards listed in the nic list command.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$nicname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.nic.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.nic.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.nic.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.nic.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('nicname')){
					if($HashTable.containskey('nicname')){
						$HashTable.nicname = $nicname
					}
					Else{
						Write-error "The parameter nicname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.nic.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('nicname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.nic.get.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.nic{
<#
.SYNOPSIS
This command will list the Physical NICs currently installed and loaded on the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.nic.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.nic.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.network.nic.list.invoke()
		}
	}
}

function set-EsxCLI.network.nic{
<#
.SYNOPSIS
Set the general options for the specified ethernet device.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER auto
Set the speed and duplexity settings to autonegotiate.

.PARAMETER duplex
The duplex to set this NIC to. Acceptable values are : [full, half]

.PARAMETER messagelevel
Sets the driver message level. Meaning differ per driver.

.PARAMETER nicname
The name of the NIC to configured. This must be one of the cards listed in the nic list command.

.PARAMETER phyaddress
Set the PHY address of the device

.PARAMETER port
Selects device port. Available device ports are 
    aui: Select AUI (Attachment Unit Interface) as the device port
    bnc: Select BNC (Bayonet Neill-Concelman) as the device port
    da: Select DA (Direct Attach copper) as the device port
    fibre: Select fibre as the device port
    mii: Select MII (Media Independent Interface) as the device port
    tp: Select TP (Twisted Pair) as the device port

.PARAMETER speed
The speed to set this NIC to, in Mbps. Acceptable values are : [10, 100, 1000, 2500, 5000, 10000, 20000, 25000, 40000, 50000, 56000, 100000]

.PARAMETER transceivertype
Selects transeiver type. Currently only internal and external can be specified, in the future future types might be added. Available transeiver types are 
    external: Set the transceiver type to external
    internal: Set the transceiver type to internal

.PARAMETER wakeonlan
Sets Wake-on-LAN options. Not all devices support this. The argument to this option is a string of characters specifying which options to enable. 
p Wake on phy activity
u Wake on unicast messages
m Wake on multicast messages
b Wake on broadcast messages
a Wake on ARP
g Wake on MagicPacket(tm)
s Enable SecureOn(tm) password for MagicPacket(tm)

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$transceivertype,
	[long]$messagelevel,
	[long]$speed,
	[boolean]$auto,
	[string]$port,
	[long]$phyaddress,
	[string]$duplex,
	[string]$wakeonlan,
	[Parameter(Mandatory=$true)]
	[string]$nicname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.nic.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.nic.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.nic.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.nic.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('transceivertype')){
					if($HashTable.containskey('transceivertype')){
						$HashTable.transceivertype = $transceivertype
					}
					Else{
						Write-error "The parameter transceivertype is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('messagelevel')){
					if($HashTable.containskey('messagelevel')){
						$HashTable.messagelevel = $messagelevel
					}
					Else{
						Write-error "The parameter messagelevel is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('speed')){
					if($HashTable.containskey('speed')){
						$HashTable.speed = $speed
					}
					Else{
						Write-error "The parameter speed is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('auto')){
					if($HashTable.containskey('auto')){
						$HashTable.auto = $auto
					}
					Else{
						Write-error "The parameter auto is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('port')){
					if($HashTable.containskey('port')){
						$HashTable.port = $port
					}
					Else{
						Write-error "The parameter port is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('phyaddress')){
					if($HashTable.containskey('phyaddress')){
						$HashTable.phyaddress = $phyaddress
					}
					Else{
						Write-error "The parameter phyaddress is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('duplex')){
					if($HashTable.containskey('duplex')){
						$HashTable.duplex = $duplex
					}
					Else{
						Write-error "The parameter duplex is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('wakeonlan')){
					if($HashTable.containskey('wakeonlan')){
						$HashTable.wakeonlan = $wakeonlan
					}
					Else{
						Write-error "The parameter wakeonlan is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('nicname')){
					if($HashTable.containskey('nicname')){
						$HashTable.nicname = $nicname
					}
					Else{
						Write-error "The parameter nicname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.nic.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('transceivertype') -or $PSBoundParameters.ContainsKey('messagelevel') -or $PSBoundParameters.ContainsKey('speed') -or $PSBoundParameters.ContainsKey('auto') -or $PSBoundParameters.ContainsKey('port') -or $PSBoundParameters.ContainsKey('phyaddress') -or $PSBoundParameters.ContainsKey('duplex') -or $PSBoundParameters.ContainsKey('wakeonlan') -or $PSBoundParameters.ContainsKey('nicname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.nic.set.invoke()
				}
			}
		}
	}
}

function up-EsxCLI.network.nic{
<#
.SYNOPSIS
Bring up the specified network device.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER nicname
The name of the NIC to configured. This must be one of the cards listed in the nic list command.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$nicname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.nic.up){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.nic.up is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.nic.up | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.nic.up.CreateArgs()
				if($PSBoundParameters.ContainsKey('nicname')){
					if($HashTable.containskey('nicname')){
						$HashTable.nicname = $nicname
					}
					Else{
						Write-error "The parameter nicname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.nic.up.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('nicname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.nic.up.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.network.nic.coalesce{
<#
.SYNOPSIS
Get coalesce parameters

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER vmnic
The name of pnic to get coalesce parameters

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$vmnic,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.nic.coalesce.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.nic.coalesce.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.nic.coalesce.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.nic.coalesce.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('vmnic')){
					if($HashTable.containskey('vmnic')){
						$HashTable.vmnic = $vmnic
					}
					Else{
						Write-error "The parameter vmnic is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.nic.coalesce.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vmnic')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.nic.coalesce.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.network.nic.coalesce{
<#
.SYNOPSIS
Set coalesce parameters on a nic

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adaptiverx
enable or disable adaptive RX algorithm in driver.

.PARAMETER adaptivetx
enable or disable adaptive TX algorithm in driver.

.PARAMETER rxmaxframes
Maximum number of RX frames driver to process before interrupting.

.PARAMETER rxusecs
Number of microseconds driver to wait for RX before interrupting.

.PARAMETER sampleinterval
Packet rate sampling internal in seconds for the adaptive coalescing algorithm in driver.

.PARAMETER txmaxframes
Maximum number of completed TX frames driver to process before interrupting.

.PARAMETER txusecs
Number of microseconds driver to wait for completed TX before interrupting.

.PARAMETER vmnic
Name of vmnic to set coalesce parameters.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[long]$txmaxframes,
	[long]$rxusecs,
	[boolean]$adaptivetx,
	[Parameter(Mandatory=$true)]
	[string]$vmnic,
	[long]$rxmaxframes,
	[long]$txusecs,
	[boolean]$adaptiverx,
	[long]$sampleinterval,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.nic.coalesce.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.nic.coalesce.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.nic.coalesce.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.nic.coalesce.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('txmaxframes')){
					if($HashTable.containskey('txmaxframes')){
						$HashTable.txmaxframes = $txmaxframes
					}
					Else{
						Write-error "The parameter txmaxframes is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('rxusecs')){
					if($HashTable.containskey('rxusecs')){
						$HashTable.rxusecs = $rxusecs
					}
					Else{
						Write-error "The parameter rxusecs is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('adaptivetx')){
					if($HashTable.containskey('adaptivetx')){
						$HashTable.adaptivetx = $adaptivetx
					}
					Else{
						Write-error "The parameter adaptivetx is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vmnic')){
					if($HashTable.containskey('vmnic')){
						$HashTable.vmnic = $vmnic
					}
					Else{
						Write-error "The parameter vmnic is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('rxmaxframes')){
					if($HashTable.containskey('rxmaxframes')){
						$HashTable.rxmaxframes = $rxmaxframes
					}
					Else{
						Write-error "The parameter rxmaxframes is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('txusecs')){
					if($HashTable.containskey('txusecs')){
						$HashTable.txusecs = $txusecs
					}
					Else{
						Write-error "The parameter txusecs is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('adaptiverx')){
					if($HashTable.containskey('adaptiverx')){
						$HashTable.adaptiverx = $adaptiverx
					}
					Else{
						Write-error "The parameter adaptiverx is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('sampleinterval')){
					if($HashTable.containskey('sampleinterval')){
						$HashTable.sampleinterval = $sampleinterval
					}
					Else{
						Write-error "The parameter sampleinterval is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.nic.coalesce.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('txmaxframes') -or $PSBoundParameters.ContainsKey('rxusecs') -or $PSBoundParameters.ContainsKey('adaptivetx') -or $PSBoundParameters.ContainsKey('vmnic') -or $PSBoundParameters.ContainsKey('rxmaxframes') -or $PSBoundParameters.ContainsKey('txusecs') -or $PSBoundParameters.ContainsKey('adaptiverx') -or $PSBoundParameters.ContainsKey('sampleinterval')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.nic.coalesce.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.network.nic.cso{
<#
.SYNOPSIS
Get checksum offload settings

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER vmnic
The name of pnic to get CSO settings

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$vmnic,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.nic.cso.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.nic.cso.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.nic.cso.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.nic.cso.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('vmnic')){
					if($HashTable.containskey('vmnic')){
						$HashTable.vmnic = $vmnic
					}
					Else{
						Write-error "The parameter vmnic is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.nic.cso.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vmnic')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.nic.cso.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.network.nic.cso{
<#
.SYNOPSIS
Set checksum offload settings on a nic

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER enable
RX/TX checksum offload

.PARAMETER vmnic
Name of vmnic to set offload settings.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$vmnic,
	[Parameter(Mandatory=$true)]
	[long]$enable,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.nic.cso.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.nic.cso.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.nic.cso.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.nic.cso.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('vmnic')){
					if($HashTable.containskey('vmnic')){
						$HashTable.vmnic = $vmnic
					}
					Else{
						Write-error "The parameter vmnic is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('enable')){
					if($HashTable.containskey('enable')){
						$HashTable.enable = $enable
					}
					Else{
						Write-error "The parameter enable is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.nic.cso.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vmnic') -or $PSBoundParameters.ContainsKey('enable')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.nic.cso.set.invoke()
				}
			}
		}
	}
}

function change-EsxCLI.network.nic.eeprom{
<#
.SYNOPSIS
Change EEPROM on a nic

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER file
File name of new EEPROM content

.PARAMETER magic
Magic key of EEPROM

.PARAMETER offset
Offset of EEPROM to change

.PARAMETER value
New EEPROM value in double word

.PARAMETER vmnic
Name of vmnic to change EEPROM.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$file,
	[long]$offset,
	[Parameter(Mandatory=$true)]
	[long]$magic,
	[Parameter(Mandatory=$true)]
	[string]$vmnic,
	[long]$value,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.nic.eeprom.change){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.nic.eeprom.change is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.nic.eeprom.change | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.nic.eeprom.change.CreateArgs()
				if($PSBoundParameters.ContainsKey('file')){
					if($HashTable.containskey('file')){
						$HashTable.file = $file
					}
					Else{
						Write-error "The parameter file is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('offset')){
					if($HashTable.containskey('offset')){
						$HashTable.offset = $offset
					}
					Else{
						Write-error "The parameter offset is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('magic')){
					if($HashTable.containskey('magic')){
						$HashTable.magic = $magic
					}
					Else{
						Write-error "The parameter magic is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vmnic')){
					if($HashTable.containskey('vmnic')){
						$HashTable.vmnic = $vmnic
					}
					Else{
						Write-error "The parameter vmnic is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('value')){
					if($HashTable.containskey('value')){
						$HashTable.value = $value
					}
					Else{
						Write-error "The parameter value is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.nic.eeprom.change.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('file') -or $PSBoundParameters.ContainsKey('offset') -or $PSBoundParameters.ContainsKey('magic') -or $PSBoundParameters.ContainsKey('vmnic') -or $PSBoundParameters.ContainsKey('value')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.nic.eeprom.change.invoke()
				}
			}
		}
	}
}

function dump-EsxCLI.network.nic.eeprom{
<#
.SYNOPSIS
Dump device EEPROM

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER length
Bytes of EEPROM to dump

.PARAMETER offset
Offset of EEPROM starting to dump

.PARAMETER vmnic
The name of pnic to dump EEPROM

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[long]$offset,
	[Parameter(Mandatory=$true)]
	[string]$vmnic,
	[long]$length,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.nic.eeprom.dump){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.nic.eeprom.dump is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.nic.eeprom.dump | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.nic.eeprom.dump.CreateArgs()
				if($PSBoundParameters.ContainsKey('offset')){
					if($HashTable.containskey('offset')){
						$HashTable.offset = $offset
					}
					Else{
						Write-error "The parameter offset is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vmnic')){
					if($HashTable.containskey('vmnic')){
						$HashTable.vmnic = $vmnic
					}
					Else{
						Write-error "The parameter vmnic is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('length')){
					if($HashTable.containskey('length')){
						$HashTable.length = $length
					}
					Else{
						Write-error "The parameter length is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.nic.eeprom.dump.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('offset') -or $PSBoundParameters.ContainsKey('vmnic') -or $PSBoundParameters.ContainsKey('length')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.nic.eeprom.dump.invoke()
				}
			}
		}
	}
}

function restart-EsxCLI.network.nic.negotiate{
<#
.SYNOPSIS
Restart N-Way negotiation on a nic

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER vmnic
Name of vmnic to restart negotiation

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$vmnic,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.nic.negotiate.restart){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.nic.negotiate.restart is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.nic.negotiate.restart | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.nic.negotiate.restart.CreateArgs()
				if($PSBoundParameters.ContainsKey('vmnic')){
					if($HashTable.containskey('vmnic')){
						$HashTable.vmnic = $vmnic
					}
					Else{
						Write-error "The parameter vmnic is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.nic.negotiate.restart.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vmnic')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.nic.negotiate.restart.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.nic.pauseParams{
<#
.SYNOPSIS
List pause parameters of all NICs

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER nicname
The name of the NIC whose pause parameters should be retrieved.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$nicname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.nic.pauseParams.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.nic.pauseParams.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.nic.pauseParams.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.nic.pauseParams.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('nicname')){
					if($HashTable.containskey('nicname')){
						$HashTable.nicname = $nicname
					}
					Else{
						Write-error "The parameter nicname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.nic.pauseParams.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('nicname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.nic.pauseParams.list.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.network.nic.pauseParams{
<#
.SYNOPSIS
Set pause parameters for a NIC

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER auto
Enable/disable auto negotiation.

.PARAMETER nicname
Name of NIC whose pause parameters should be set.

.PARAMETER rx
Enable/disable pause RX flow control.

.PARAMETER tx
Enable/disable pause TX flow control.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$nicname,
	[boolean]$tx,
	[boolean]$auto,
	[boolean]$rx,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.nic.pauseParams.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.nic.pauseParams.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.nic.pauseParams.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.nic.pauseParams.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('nicname')){
					if($HashTable.containskey('nicname')){
						$HashTable.nicname = $nicname
					}
					Else{
						Write-error "The parameter nicname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('tx')){
					if($HashTable.containskey('tx')){
						$HashTable.tx = $tx
					}
					Else{
						Write-error "The parameter tx is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('auto')){
					if($HashTable.containskey('auto')){
						$HashTable.auto = $auto
					}
					Else{
						Write-error "The parameter auto is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('rx')){
					if($HashTable.containskey('rx')){
						$HashTable.rx = $rx
					}
					Else{
						Write-error "The parameter rx is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.nic.pauseParams.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('nicname') -or $PSBoundParameters.ContainsKey('tx') -or $PSBoundParameters.ContainsKey('auto') -or $PSBoundParameters.ContainsKey('rx')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.nic.pauseParams.set.invoke()
				}
			}
		}
	}
}

function dump-EsxCLI.network.nic.register{
<#
.SYNOPSIS
Dump device registers

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER vmnic
The name of pnic to dump registers

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$vmnic,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.nic.register.dump){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.nic.register.dump is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.nic.register.dump | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.nic.register.dump.CreateArgs()
				if($PSBoundParameters.ContainsKey('vmnic')){
					if($HashTable.containskey('vmnic')){
						$HashTable.vmnic = $vmnic
					}
					Else{
						Write-error "The parameter vmnic is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.nic.register.dump.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vmnic')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.nic.register.dump.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.network.nic.ring.current{
<#
.SYNOPSIS
Get current RX/TX ring buffer parameters of a NIC

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER nicname
The name of the NIC whose current RX/TX ring buffer parameters should be retrieved.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$nicname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.nic.ring.current.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.nic.ring.current.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.nic.ring.current.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.nic.ring.current.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('nicname')){
					if($HashTable.containskey('nicname')){
						$HashTable.nicname = $nicname
					}
					Else{
						Write-error "The parameter nicname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.nic.ring.current.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('nicname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.nic.ring.current.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.network.nic.ring.current{
<#
.SYNOPSIS
Set current RX/TX ring buffer parameters of a NIC

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER nicname
The name of the NIC whose current RX/TX ring buffer parameters should be set.

.PARAMETER rx
Number of ring entries for the RX ring.

.PARAMETER rxjumbo
Number of ring entries for the RX jumbo ring.

.PARAMETER rxmini
Number of ring entries for the RX mini ring.

.PARAMETER tx
Number of ring entries for the TX ring.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$nicname,
	[long]$tx,
	[long]$rxjumbo,
	[long]$rxmini,
	[long]$rx,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.nic.ring.current.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.nic.ring.current.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.nic.ring.current.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.nic.ring.current.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('nicname')){
					if($HashTable.containskey('nicname')){
						$HashTable.nicname = $nicname
					}
					Else{
						Write-error "The parameter nicname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('tx')){
					if($HashTable.containskey('tx')){
						$HashTable.tx = $tx
					}
					Else{
						Write-error "The parameter tx is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('rxjumbo')){
					if($HashTable.containskey('rxjumbo')){
						$HashTable.rxjumbo = $rxjumbo
					}
					Else{
						Write-error "The parameter rxjumbo is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('rxmini')){
					if($HashTable.containskey('rxmini')){
						$HashTable.rxmini = $rxmini
					}
					Else{
						Write-error "The parameter rxmini is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('rx')){
					if($HashTable.containskey('rx')){
						$HashTable.rx = $rx
					}
					Else{
						Write-error "The parameter rx is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.nic.ring.current.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('nicname') -or $PSBoundParameters.ContainsKey('tx') -or $PSBoundParameters.ContainsKey('rxjumbo') -or $PSBoundParameters.ContainsKey('rxmini') -or $PSBoundParameters.ContainsKey('rx')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.nic.ring.current.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.network.nic.ring.preset{
<#
.SYNOPSIS
Get preset RX/TX ring buffer parameters of a NIC

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER nicname
The name of the NIC whose preset RX/TX ring buffer parameters should be retrieved.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$nicname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.nic.ring.preset.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.nic.ring.preset.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.nic.ring.preset.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.nic.ring.preset.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('nicname')){
					if($HashTable.containskey('nicname')){
						$HashTable.nicname = $nicname
					}
					Else{
						Write-error "The parameter nicname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.nic.ring.preset.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('nicname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.nic.ring.preset.get.invoke()
				}
			}
		}
	}
}

function run-EsxCLI.network.nic.selftest{
<#
.SYNOPSIS
Run self test

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER online
Performing limited set of tests do not inetrrupt normal adapter operation, default is offline

.PARAMETER vmnic
The name of pnic to dump EEPROM

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[long]$online,
	[Parameter(Mandatory=$true)]
	[string]$vmnic,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.nic.selftest.run){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.nic.selftest.run is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.nic.selftest.run | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.nic.selftest.run.CreateArgs()
				if($PSBoundParameters.ContainsKey('online')){
					if($HashTable.containskey('online')){
						$HashTable.online = $online
					}
					Else{
						Write-error "The parameter online is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vmnic')){
					if($HashTable.containskey('vmnic')){
						$HashTable.vmnic = $vmnic
					}
					Else{
						Write-error "The parameter vmnic is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.nic.selftest.run.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('online') -or $PSBoundParameters.ContainsKey('vmnic')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.nic.selftest.run.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.network.nic.sg{
<#
.SYNOPSIS
Get scatter-gather settings

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER vmnic
The name of pnic to get scatter-gather settings

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$vmnic,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.nic.sg.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.nic.sg.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.nic.sg.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.nic.sg.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('vmnic')){
					if($HashTable.containskey('vmnic')){
						$HashTable.vmnic = $vmnic
					}
					Else{
						Write-error "The parameter vmnic is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.nic.sg.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vmnic')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.nic.sg.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.network.nic.sg{
<#
.SYNOPSIS
Set scatter-gatter settings on a nic

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER enable
Enable/disable sacatter-gather

.PARAMETER vmnic
Name of vmnic to configure scatter-gather settings.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$vmnic,
	[Parameter(Mandatory=$true)]
	[long]$enable,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.nic.sg.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.nic.sg.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.nic.sg.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.nic.sg.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('vmnic')){
					if($HashTable.containskey('vmnic')){
						$HashTable.vmnic = $vmnic
					}
					Else{
						Write-error "The parameter vmnic is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('enable')){
					if($HashTable.containskey('enable')){
						$HashTable.enable = $enable
					}
					Else{
						Write-error "The parameter enable is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.nic.sg.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vmnic') -or $PSBoundParameters.ContainsKey('enable')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.nic.sg.set.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.nic.software{
<#
.SYNOPSIS
List software simulation settings of all physical NICs currently installed and loaded on the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.nic.software.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.nic.software.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.network.nic.software.list.invoke()
		}
	}
}

function set-EsxCLI.network.nic.software{
<#
.SYNOPSIS
Enable and disable software simulation settings on a NIC.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER geneveoffload
Configure Geneve encapsulation offload software simulation.

.PARAMETER highdma
Configure high DMA software simulation.

.PARAMETER ipv4cso
Configure IPv4 checksum offload software simulation.

.PARAMETER ipv4tso
Configure IPv4 TCP segmentation offload software simulation.

.PARAMETER ipv6cso
Configure IPv6 checksum offload software simulation.

.PARAMETER ipv6csoext
Configure IPv6 extend header checksum offload software simulation.

.PARAMETER ipv6tso
Configure IPv6 TCP segmentation offload software simulation.

.PARAMETER ipv6tsoext
Configure IPv6 extend header TCP segmentation offload software simulation.

.PARAMETER obo
Configure offset based encapsulation offload software simulation.

.PARAMETER sg
Configure scatter gather software simulation.

.PARAMETER sgsp
Configure scatter gather span multiple pages software simulation.

.PARAMETER tagging
Configure TX VLAN tagging software simulation.

.PARAMETER untagging
Configure RX VLAN untagging software simulation.

.PARAMETER vmnic
Name of the vmnic whose software similation settings should be updated.

.PARAMETER vxlanencap
Configure VXLAN encapsulation offload software simulation.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$obo,
	[boolean]$ipv6csoext,
	[boolean]$sg,
	[boolean]$ipv4cso,
	[boolean]$geneveoffload,
	[Parameter(Mandatory=$true)]
	[string]$vmnic,
	[boolean]$untagging,
	[boolean]$ipv6tsoext,
	[boolean]$ipv6tso,
	[boolean]$vxlanencap,
	[boolean]$tagging,
	[boolean]$ipv6cso,
	[boolean]$sgsp,
	[boolean]$highdma,
	[boolean]$ipv4tso,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.nic.software.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.nic.software.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.nic.software.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.nic.software.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('obo')){
					if($HashTable.containskey('obo')){
						$HashTable.obo = $obo
					}
					Else{
						Write-error "The parameter obo is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ipv6csoext')){
					if($HashTable.containskey('ipv6csoext')){
						$HashTable.ipv6csoext = $ipv6csoext
					}
					Else{
						Write-error "The parameter ipv6csoext is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('sg')){
					if($HashTable.containskey('sg')){
						$HashTable.sg = $sg
					}
					Else{
						Write-error "The parameter sg is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ipv4cso')){
					if($HashTable.containskey('ipv4cso')){
						$HashTable.ipv4cso = $ipv4cso
					}
					Else{
						Write-error "The parameter ipv4cso is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('geneveoffload')){
					if($HashTable.containskey('geneveoffload')){
						$HashTable.geneveoffload = $geneveoffload
					}
					Else{
						Write-error "The parameter geneveoffload is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vmnic')){
					if($HashTable.containskey('vmnic')){
						$HashTable.vmnic = $vmnic
					}
					Else{
						Write-error "The parameter vmnic is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('untagging')){
					if($HashTable.containskey('untagging')){
						$HashTable.untagging = $untagging
					}
					Else{
						Write-error "The parameter untagging is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ipv6tsoext')){
					if($HashTable.containskey('ipv6tsoext')){
						$HashTable.ipv6tsoext = $ipv6tsoext
					}
					Else{
						Write-error "The parameter ipv6tsoext is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ipv6tso')){
					if($HashTable.containskey('ipv6tso')){
						$HashTable.ipv6tso = $ipv6tso
					}
					Else{
						Write-error "The parameter ipv6tso is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vxlanencap')){
					if($HashTable.containskey('vxlanencap')){
						$HashTable.vxlanencap = $vxlanencap
					}
					Else{
						Write-error "The parameter vxlanencap is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('tagging')){
					if($HashTable.containskey('tagging')){
						$HashTable.tagging = $tagging
					}
					Else{
						Write-error "The parameter tagging is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ipv6cso')){
					if($HashTable.containskey('ipv6cso')){
						$HashTable.ipv6cso = $ipv6cso
					}
					Else{
						Write-error "The parameter ipv6cso is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('sgsp')){
					if($HashTable.containskey('sgsp')){
						$HashTable.sgsp = $sgsp
					}
					Else{
						Write-error "The parameter sgsp is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('highdma')){
					if($HashTable.containskey('highdma')){
						$HashTable.highdma = $highdma
					}
					Else{
						Write-error "The parameter highdma is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ipv4tso')){
					if($HashTable.containskey('ipv4tso')){
						$HashTable.ipv4tso = $ipv4tso
					}
					Else{
						Write-error "The parameter ipv4tso is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.nic.software.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('obo') -or $PSBoundParameters.ContainsKey('ipv6csoext') -or $PSBoundParameters.ContainsKey('sg') -or $PSBoundParameters.ContainsKey('ipv4cso') -or $PSBoundParameters.ContainsKey('geneveoffload') -or $PSBoundParameters.ContainsKey('vmnic') -or $PSBoundParameters.ContainsKey('untagging') -or $PSBoundParameters.ContainsKey('ipv6tsoext') -or $PSBoundParameters.ContainsKey('ipv6tso') -or $PSBoundParameters.ContainsKey('vxlanencap') -or $PSBoundParameters.ContainsKey('tagging') -or $PSBoundParameters.ContainsKey('ipv6cso') -or $PSBoundParameters.ContainsKey('sgsp') -or $PSBoundParameters.ContainsKey('highdma') -or $PSBoundParameters.ContainsKey('ipv4tso')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.nic.software.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.network.nic.stats{
<#
.SYNOPSIS
Get NIC statistics for a given interface.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER nicname
Name of the NIC to get statistics from.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$nicname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.nic.stats.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.nic.stats.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.nic.stats.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.nic.stats.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('nicname')){
					if($HashTable.containskey('nicname')){
						$HashTable.nicname = $nicname
					}
					Else{
						Write-error "The parameter nicname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.nic.stats.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('nicname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.nic.stats.get.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.network.nic.tso{
<#
.SYNOPSIS
Get TCP segmentation offload settings

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER vmnic
The name of pnic to get TSO settings

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$vmnic,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.nic.tso.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.nic.tso.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.nic.tso.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.nic.tso.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('vmnic')){
					if($HashTable.containskey('vmnic')){
						$HashTable.vmnic = $vmnic
					}
					Else{
						Write-error "The parameter vmnic is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.nic.tso.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vmnic')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.nic.tso.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.network.nic.tso{
<#
.SYNOPSIS
Set TCP segmentation offload settings on a nic

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER enable
TCP segmentation offload

.PARAMETER vmnic
Name of vmnic to set TSO settings.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$vmnic,
	[Parameter(Mandatory=$true)]
	[long]$enable,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.nic.tso.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.nic.tso.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.nic.tso.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.nic.tso.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('vmnic')){
					if($HashTable.containskey('vmnic')){
						$HashTable.vmnic = $vmnic
					}
					Else{
						Write-error "The parameter vmnic is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('enable')){
					if($HashTable.containskey('enable')){
						$HashTable.enable = $enable
					}
					Else{
						Write-error "The parameter enable is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.nic.tso.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vmnic') -or $PSBoundParameters.ContainsKey('enable')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.nic.tso.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.network.nic.vlan.stats{
<#
.SYNOPSIS
List VLAN statistics for active VLAN's on the NIC.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER nicname
Name of the NIC to get statistics from.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$nicname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.nic.vlan.stats.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.nic.vlan.stats.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.nic.vlan.stats.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.nic.vlan.stats.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('nicname')){
					if($HashTable.containskey('nicname')){
						$HashTable.nicname = $nicname
					}
					Else{
						Write-error "The parameter nicname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.nic.vlan.stats.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('nicname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.nic.vlan.stats.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.network.nic.vlan.stats{
<#
.SYNOPSIS
Enable/disable VLAN statistics collection on the NIC.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER enabled
Whether to enable or disable VLAN statistics

.PARAMETER nicname
Name of the NIC to get statistics from.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[boolean]$enabled,
	[Parameter(Mandatory=$true)]
	[string]$nicname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.nic.vlan.stats.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.nic.vlan.stats.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.nic.vlan.stats.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.nic.vlan.stats.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('enabled')){
					if($HashTable.containskey('enabled')){
						$HashTable.enabled = $enabled
					}
					Else{
						Write-error "The parameter enabled is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('nicname')){
					if($HashTable.containskey('nicname')){
						$HashTable.nicname = $nicname
					}
					Else{
						Write-error "The parameter nicname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.nic.vlan.stats.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('enabled') -or $PSBoundParameters.ContainsKey('nicname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.nic.vlan.stats.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.network.port.filter.stats{
<#
.SYNOPSIS
Filter statistics for a given port.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER portid
Port ID for the port to get filter statistics.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[long]$portid,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.port.filter.stats.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.port.filter.stats.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.port.filter.stats.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.port.filter.stats.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('portid')){
					if($HashTable.containskey('portid')){
						$HashTable.portid = $portid
					}
					Else{
						Write-error "The parameter portid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.port.filter.stats.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('portid')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.port.filter.stats.get.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.network.port.stats{
<#
.SYNOPSIS
Packet statistics for a given port.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER portid
Port ID for the port to get statistics.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[long]$portid,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.port.stats.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.port.stats.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.port.stats.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.port.stats.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('portid')){
					if($HashTable.containskey('portid')){
						$HashTable.portid = $portid
					}
					Else{
						Write-error "The parameter portid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.port.stats.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('portid')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.port.stats.get.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.sriovnic{
<#
.SYNOPSIS
This command will list the SRIOV Enabled NICs (PFs) currently installed and loaded on the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.sriovnic.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.sriovnic.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.network.sriovnic.list.invoke()
		}
	}
}

function list-EsxCLI.network.sriovnic.vf{
<#
.SYNOPSIS
Get the generic configuration of VFs for SRIOV NIC.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER nicname
The name of the SRIOV NIC to configured. This must be one of the cards listed in the sriovNic list command.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$nicname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.sriovnic.vf.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.sriovnic.vf.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.sriovnic.vf.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.sriovnic.vf.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('nicname')){
					if($HashTable.containskey('nicname')){
						$HashTable.nicname = $nicname
					}
					Else{
						Write-error "The parameter nicname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.sriovnic.vf.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('nicname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.sriovnic.vf.list.invoke()
				}
			}
		}
	}
}

function stats-EsxCLI.network.sriovnic.vf{
<#
.SYNOPSIS
Get statistics for given VF of a SRIOV NIC.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER nicname
The name of the SRIOV NIC. This must be one of the cards listed in the sriovNic list command.

.PARAMETER vfid
The VF ID of the virtual function whose stats are to be collected. This must be one of the VF IDs listed in the sriovnic vf list command.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[long]$vfid,
	[Parameter(Mandatory=$true)]
	[string]$nicname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.sriovnic.vf.stats){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.sriovnic.vf.stats is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.sriovnic.vf.stats | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.sriovnic.vf.stats.CreateArgs()
				if($PSBoundParameters.ContainsKey('vfid')){
					if($HashTable.containskey('vfid')){
						$HashTable.vfid = $vfid
					}
					Else{
						Write-error "The parameter vfid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('nicname')){
					if($HashTable.containskey('nicname')){
						$HashTable.nicname = $nicname
					}
					Else{
						Write-error "The parameter nicname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.sriovnic.vf.stats.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vfid') -or $PSBoundParameters.ContainsKey('nicname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.sriovnic.vf.stats.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.vm{
<#
.SYNOPSIS
List networking information for the VM's that have active ports.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vm.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vm.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.network.vm.list.invoke()
		}
	}
}

function list-EsxCLI.network.vm.port{
<#
.SYNOPSIS
List of active ports for a given VM.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER worldid
World ID of the VM for listing ports.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[long]$worldid,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vm.port.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vm.port.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vm.port.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vm.port.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('worldid')){
					if($HashTable.containskey('worldid')){
						$HashTable.worldid = $worldid
					}
					Else{
						Write-error "The parameter worldid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vm.port.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('worldid')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vm.port.list.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.vswitch.dvs.vmware{
<#
.SYNOPSIS
List the VMware vSphere Distributed Switch currently configured on the ESXi host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER vdsname
Limit the output of this command to only vDS with the given name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$vdsname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.dvs.vmware.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.dvs.vmware.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.dvs.vmware.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.dvs.vmware.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('vdsname')){
					if($HashTable.containskey('vdsname')){
						$HashTable.vdsname = $vdsname
					}
					Else{
						Write-error "The parameter vdsname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.dvs.vmware.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vdsname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.dvs.vmware.list.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.network.vswitch.dvs.vmware.lacp.config{
<#
.SYNOPSIS
Get LACP configuration on DVS

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER dvs
The name of DVS to get configuration on

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$dvs,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.dvs.vmware.lacp.config.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.dvs.vmware.lacp.config.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.dvs.vmware.lacp.config.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.dvs.vmware.lacp.config.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('dvs')){
					if($HashTable.containskey('dvs')){
						$HashTable.dvs = $dvs
					}
					Else{
						Write-error "The parameter dvs is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.dvs.vmware.lacp.config.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('dvs')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.dvs.vmware.lacp.config.get.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.network.vswitch.dvs.vmware.lacp.stats{
<#
.SYNOPSIS
Get LACP stats on DVS uplinks

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER dvs
The name of DVS to get configuration on

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$dvs,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.dvs.vmware.lacp.stats.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.dvs.vmware.lacp.stats.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.dvs.vmware.lacp.stats.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.dvs.vmware.lacp.stats.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('dvs')){
					if($HashTable.containskey('dvs')){
						$HashTable.dvs = $dvs
					}
					Else{
						Write-error "The parameter dvs is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.dvs.vmware.lacp.stats.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('dvs')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.dvs.vmware.lacp.stats.get.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.network.vswitch.dvs.vmware.lacp.status{
<#
.SYNOPSIS
Get LACP status on DVS

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER dvs
The name of DVS to get configuration on

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$dvs,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.dvs.vmware.lacp.status.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.dvs.vmware.lacp.status.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.dvs.vmware.lacp.status.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.dvs.vmware.lacp.status.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('dvs')){
					if($HashTable.containskey('dvs')){
						$HashTable.dvs = $dvs
					}
					Else{
						Write-error "The parameter dvs is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.dvs.vmware.lacp.status.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('dvs')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.dvs.vmware.lacp.status.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.network.vswitch.dvs.vmware.lacp.timeout{
<#
.SYNOPSIS
Set long/short timeout for vmnics in one LACP LAG

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER lagid
The ID of LAG to be configured.

.PARAMETER nicname
The nic name. If it is set, then only this vmnic in the lag will be configured.

.PARAMETER timeout
Set long or short timeout: 1 for short timeout and 0 for long timeout.

.PARAMETER vds
The name of VDS.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$nicname,
	[Parameter(Mandatory=$true)]
	[long]$lagid,
	[Parameter(Mandatory=$true)]
	[boolean]$timeout,
	[Parameter(Mandatory=$true)]
	[string]$vds,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.dvs.vmware.lacp.timeout.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.dvs.vmware.lacp.timeout.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.dvs.vmware.lacp.timeout.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.dvs.vmware.lacp.timeout.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('nicname')){
					if($HashTable.containskey('nicname')){
						$HashTable.nicname = $nicname
					}
					Else{
						Write-error "The parameter nicname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('lagid')){
					if($HashTable.containskey('lagid')){
						$HashTable.lagid = $lagid
					}
					Else{
						Write-error "The parameter lagid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('timeout')){
					if($HashTable.containskey('timeout')){
						$HashTable.timeout = $timeout
					}
					Else{
						Write-error "The parameter timeout is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vds')){
					if($HashTable.containskey('vds')){
						$HashTable.vds = $vds
					}
					Else{
						Write-error "The parameter vds is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.dvs.vmware.lacp.timeout.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('nicname') -or $PSBoundParameters.ContainsKey('lagid') -or $PSBoundParameters.ContainsKey('timeout') -or $PSBoundParameters.ContainsKey('vds')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.dvs.vmware.lacp.timeout.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.network.vswitch.dvs.vmware.vxlan{
<#
.SYNOPSIS
Get VXLAN global states on the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.dvs.vmware.vxlan.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.dvs.vmware.vxlan.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.network.vswitch.dvs.vmware.vxlan.get.invoke()
		}
	}
}

function list-EsxCLI.network.vswitch.dvs.vmware.vxlan{
<#
.SYNOPSIS
Get VXLAN switches info on the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER vdsname
The VDS Name used to list VXLAN DVSwitch info

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$vdsname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.dvs.vmware.vxlan.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.dvs.vmware.vxlan.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.dvs.vmware.vxlan.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.dvs.vmware.vxlan.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('vdsname')){
					if($HashTable.containskey('vdsname')){
						$HashTable.vdsname = $vdsname
					}
					Else{
						Write-error "The parameter vdsname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.dvs.vmware.vxlan.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vdsname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.dvs.vmware.vxlan.list.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.network.vswitch.dvs.vmware.vxlan.config.stats{
<#
.SYNOPSIS
Get VXLAN statistics config.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.dvs.vmware.vxlan.config.stats.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.dvs.vmware.vxlan.config.stats.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.network.vswitch.dvs.vmware.vxlan.config.stats.get.invoke()
		}
	}
}

function set-EsxCLI.network.vswitch.dvs.vmware.vxlan.config.stats{
<#
.SYNOPSIS
Config VXLAN statistics.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER level
Set to 0 to disable statistics; otherwise enable statistics.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[long]$level,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.dvs.vmware.vxlan.config.stats.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.dvs.vmware.vxlan.config.stats.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.dvs.vmware.vxlan.config.stats.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.dvs.vmware.vxlan.config.stats.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('level')){
					if($HashTable.containskey('level')){
						$HashTable.level = $level
					}
					Else{
						Write-error "The parameter level is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.dvs.vmware.vxlan.config.stats.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('level')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.dvs.vmware.vxlan.config.stats.set.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.vswitch.dvs.vmware.vxlan.network{
<#
.SYNOPSIS
Get VXLAN network info with specified VDS.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER vdsname
The VDS name used to list VXLAN network info

.PARAMETER vxlanid
The VXLAN ID used to list VXLAN network info

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[long]$vxlanid,
	[Parameter(Mandatory=$true)]
	[string]$vdsname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.dvs.vmware.vxlan.network.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.dvs.vmware.vxlan.network.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.dvs.vmware.vxlan.network.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.dvs.vmware.vxlan.network.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('vxlanid')){
					if($HashTable.containskey('vxlanid')){
						$HashTable.vxlanid = $vxlanid
					}
					Else{
						Write-error "The parameter vxlanid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vdsname')){
					if($HashTable.containskey('vdsname')){
						$HashTable.vdsname = $vdsname
					}
					Else{
						Write-error "The parameter vdsname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.dvs.vmware.vxlan.network.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vxlanid') -or $PSBoundParameters.ContainsKey('vdsname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.dvs.vmware.vxlan.network.list.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.vswitch.dvs.vmware.vxlan.network.arp{
<#
.SYNOPSIS
Dump VXLAN network ARP table of specified VDS

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER vdsname
The VDS name used to list VXLAN network ARP table

.PARAMETER vxlanid
The VXLAN ID used to list VXLAN network ARP table

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[long]$vxlanid,
	[Parameter(Mandatory=$true)]
	[string]$vdsname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.dvs.vmware.vxlan.network.arp.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.dvs.vmware.vxlan.network.arp.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.dvs.vmware.vxlan.network.arp.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.dvs.vmware.vxlan.network.arp.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('vxlanid')){
					if($HashTable.containskey('vxlanid')){
						$HashTable.vxlanid = $vxlanid
					}
					Else{
						Write-error "The parameter vxlanid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vdsname')){
					if($HashTable.containskey('vdsname')){
						$HashTable.vdsname = $vdsname
					}
					Else{
						Write-error "The parameter vdsname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.dvs.vmware.vxlan.network.arp.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vxlanid') -or $PSBoundParameters.ContainsKey('vdsname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.dvs.vmware.vxlan.network.arp.list.invoke()
				}
			}
		}
	}
}

function reset-EsxCLI.network.vswitch.dvs.vmware.vxlan.network.arp{
<#
.SYNOPSIS
Reset VXLAN network ARP table

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER vdsname
The VDS name used to reset VXLAN network ARP table

.PARAMETER vxlanid
The VXLAN ID used to reset VXLAN network ARP table

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[long]$vxlanid,
	[Parameter(Mandatory=$true)]
	[string]$vdsname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.dvs.vmware.vxlan.network.arp.reset){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.dvs.vmware.vxlan.network.arp.reset is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.dvs.vmware.vxlan.network.arp.reset | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.dvs.vmware.vxlan.network.arp.reset.CreateArgs()
				if($PSBoundParameters.ContainsKey('vxlanid')){
					if($HashTable.containskey('vxlanid')){
						$HashTable.vxlanid = $vxlanid
					}
					Else{
						Write-error "The parameter vxlanid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vdsname')){
					if($HashTable.containskey('vdsname')){
						$HashTable.vdsname = $vdsname
					}
					Else{
						Write-error "The parameter vdsname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.dvs.vmware.vxlan.network.arp.reset.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vxlanid') -or $PSBoundParameters.ContainsKey('vdsname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.dvs.vmware.vxlan.network.arp.reset.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.vswitch.dvs.vmware.vxlan.network.mac{
<#
.SYNOPSIS
Dump VXLAN network MAC table of specified VDS

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER vdsname
The VDS name used to list VXLAN network MAC table

.PARAMETER vxlanid
The VXLAN ID used to list VXLAN network MAC table

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[long]$vxlanid,
	[Parameter(Mandatory=$true)]
	[string]$vdsname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.dvs.vmware.vxlan.network.mac.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.dvs.vmware.vxlan.network.mac.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.dvs.vmware.vxlan.network.mac.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.dvs.vmware.vxlan.network.mac.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('vxlanid')){
					if($HashTable.containskey('vxlanid')){
						$HashTable.vxlanid = $vxlanid
					}
					Else{
						Write-error "The parameter vxlanid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vdsname')){
					if($HashTable.containskey('vdsname')){
						$HashTable.vdsname = $vdsname
					}
					Else{
						Write-error "The parameter vdsname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.dvs.vmware.vxlan.network.mac.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vxlanid') -or $PSBoundParameters.ContainsKey('vdsname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.dvs.vmware.vxlan.network.mac.list.invoke()
				}
			}
		}
	}
}

function reset-EsxCLI.network.vswitch.dvs.vmware.vxlan.network.mac{
<#
.SYNOPSIS
Reset VXLAN network MAC table

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER vdsname
The VDS name used to reset VXLAN network MAC table

.PARAMETER vxlanid
The VXLAN ID used to reset VXLAN network MAC table

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[long]$vxlanid,
	[Parameter(Mandatory=$true)]
	[string]$vdsname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.dvs.vmware.vxlan.network.mac.reset){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.dvs.vmware.vxlan.network.mac.reset is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.dvs.vmware.vxlan.network.mac.reset | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.dvs.vmware.vxlan.network.mac.reset.CreateArgs()
				if($PSBoundParameters.ContainsKey('vxlanid')){
					if($HashTable.containskey('vxlanid')){
						$HashTable.vxlanid = $vxlanid
					}
					Else{
						Write-error "The parameter vxlanid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vdsname')){
					if($HashTable.containskey('vdsname')){
						$HashTable.vdsname = $vdsname
					}
					Else{
						Write-error "The parameter vdsname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.dvs.vmware.vxlan.network.mac.reset.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vxlanid') -or $PSBoundParameters.ContainsKey('vdsname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.dvs.vmware.vxlan.network.mac.reset.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.vswitch.dvs.vmware.vxlan.network.port{
<#
.SYNOPSIS
Get VXLAN network info with specified VDS.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER vdsname
The VDS name used to list VXLAN network info

.PARAMETER vdsportid
The VDS Port ID used to list VXLAN network info

.PARAMETER vxlanid
The VXLAN ID used to list VXLAN network info

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[long]$vxlanid,
	[string]$vdsportid,
	[Parameter(Mandatory=$true)]
	[string]$vdsname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.dvs.vmware.vxlan.network.port.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.dvs.vmware.vxlan.network.port.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.dvs.vmware.vxlan.network.port.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.dvs.vmware.vxlan.network.port.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('vxlanid')){
					if($HashTable.containskey('vxlanid')){
						$HashTable.vxlanid = $vxlanid
					}
					Else{
						Write-error "The parameter vxlanid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vdsportid')){
					if($HashTable.containskey('vdsportid')){
						$HashTable.vdsportid = $vdsportid
					}
					Else{
						Write-error "The parameter vdsportid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vdsname')){
					if($HashTable.containskey('vdsname')){
						$HashTable.vdsname = $vdsname
					}
					Else{
						Write-error "The parameter vdsname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.dvs.vmware.vxlan.network.port.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vxlanid') -or $PSBoundParameters.ContainsKey('vdsportid') -or $PSBoundParameters.ContainsKey('vdsname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.dvs.vmware.vxlan.network.port.list.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.vswitch.dvs.vmware.vxlan.network.port.stats{
<#
.SYNOPSIS
Get VXLAN port statistics info.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER vdsname
The VDS name used to get VXLAN port statistics info

.PARAMETER vdsportid
The VDS Port ID used to get VXLAN port statistics info

.PARAMETER vxlanid
The VXLAN ID used to get VXLAN port statistics info

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[long]$vxlanid,
	[Parameter(Mandatory=$true)]
	[string]$vdsportid,
	[Parameter(Mandatory=$true)]
	[string]$vdsname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.dvs.vmware.vxlan.network.port.stats.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.dvs.vmware.vxlan.network.port.stats.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.dvs.vmware.vxlan.network.port.stats.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.dvs.vmware.vxlan.network.port.stats.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('vxlanid')){
					if($HashTable.containskey('vxlanid')){
						$HashTable.vxlanid = $vxlanid
					}
					Else{
						Write-error "The parameter vxlanid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vdsportid')){
					if($HashTable.containskey('vdsportid')){
						$HashTable.vdsportid = $vdsportid
					}
					Else{
						Write-error "The parameter vdsportid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vdsname')){
					if($HashTable.containskey('vdsname')){
						$HashTable.vdsname = $vdsname
					}
					Else{
						Write-error "The parameter vdsname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.dvs.vmware.vxlan.network.port.stats.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vxlanid') -or $PSBoundParameters.ContainsKey('vdsportid') -or $PSBoundParameters.ContainsKey('vdsname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.dvs.vmware.vxlan.network.port.stats.list.invoke()
				}
			}
		}
	}
}

function reset-EsxCLI.network.vswitch.dvs.vmware.vxlan.network.port.stats{
<#
.SYNOPSIS
Reset VXLAN DVSwitch statistics info.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER vdsname
The VDS name used to reset VXLAN port statistics info

.PARAMETER vdsportid
The VDS Port ID used to reset VXLAN port statistics info

.PARAMETER vxlanid
The VXLAN ID used to reset VXLAN port statistics info

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[long]$vxlanid,
	[Parameter(Mandatory=$true)]
	[string]$vdsportid,
	[Parameter(Mandatory=$true)]
	[string]$vdsname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.dvs.vmware.vxlan.network.port.stats.reset){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.dvs.vmware.vxlan.network.port.stats.reset is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.dvs.vmware.vxlan.network.port.stats.reset | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.dvs.vmware.vxlan.network.port.stats.reset.CreateArgs()
				if($PSBoundParameters.ContainsKey('vxlanid')){
					if($HashTable.containskey('vxlanid')){
						$HashTable.vxlanid = $vxlanid
					}
					Else{
						Write-error "The parameter vxlanid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vdsportid')){
					if($HashTable.containskey('vdsportid')){
						$HashTable.vdsportid = $vdsportid
					}
					Else{
						Write-error "The parameter vdsportid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vdsname')){
					if($HashTable.containskey('vdsname')){
						$HashTable.vdsname = $vdsname
					}
					Else{
						Write-error "The parameter vdsname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.dvs.vmware.vxlan.network.port.stats.reset.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vxlanid') -or $PSBoundParameters.ContainsKey('vdsportid') -or $PSBoundParameters.ContainsKey('vdsname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.dvs.vmware.vxlan.network.port.stats.reset.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.vswitch.dvs.vmware.vxlan.network.stats{
<#
.SYNOPSIS
Get VXLAN network statistics info.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER vdsname
The VDS name used to get VXLAN network statistics info

.PARAMETER vxlanid
The VXLAN ID used to get VXLAN network statistics info

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[long]$vxlanid,
	[Parameter(Mandatory=$true)]
	[string]$vdsname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.dvs.vmware.vxlan.network.stats.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.dvs.vmware.vxlan.network.stats.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.dvs.vmware.vxlan.network.stats.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.dvs.vmware.vxlan.network.stats.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('vxlanid')){
					if($HashTable.containskey('vxlanid')){
						$HashTable.vxlanid = $vxlanid
					}
					Else{
						Write-error "The parameter vxlanid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vdsname')){
					if($HashTable.containskey('vdsname')){
						$HashTable.vdsname = $vdsname
					}
					Else{
						Write-error "The parameter vdsname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.dvs.vmware.vxlan.network.stats.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vxlanid') -or $PSBoundParameters.ContainsKey('vdsname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.dvs.vmware.vxlan.network.stats.list.invoke()
				}
			}
		}
	}
}

function reset-EsxCLI.network.vswitch.dvs.vmware.vxlan.network.stats{
<#
.SYNOPSIS
Reset VXLAN DVSwitch statistics info.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER vdsname
The VDS name used to reset VXLAN network statistics info

.PARAMETER vxlanid
The VXLAN ID used to reset VXLAN network statistics info

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[long]$vxlanid,
	[Parameter(Mandatory=$true)]
	[string]$vdsname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.dvs.vmware.vxlan.network.stats.reset){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.dvs.vmware.vxlan.network.stats.reset is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.dvs.vmware.vxlan.network.stats.reset | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.dvs.vmware.vxlan.network.stats.reset.CreateArgs()
				if($PSBoundParameters.ContainsKey('vxlanid')){
					if($HashTable.containskey('vxlanid')){
						$HashTable.vxlanid = $vxlanid
					}
					Else{
						Write-error "The parameter vxlanid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vdsname')){
					if($HashTable.containskey('vdsname')){
						$HashTable.vdsname = $vdsname
					}
					Else{
						Write-error "The parameter vdsname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.dvs.vmware.vxlan.network.stats.reset.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vxlanid') -or $PSBoundParameters.ContainsKey('vdsname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.dvs.vmware.vxlan.network.stats.reset.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.vswitch.dvs.vmware.vxlan.network.vtep{
<#
.SYNOPSIS
Get VXLAN network VTEP table info with specified VDS.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER segmentid
Display VTEP info for only one Segment ID

.PARAMETER vdsname
The VDS name used to list VXLAN network info

.PARAMETER vtepip
Display VTEP info for only one VTEP IP

.PARAMETER vxlanid
The VXLAN ID used to list VXLAN network info

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$vtepip,
	[Parameter(Mandatory=$true)]
	[long]$vxlanid,
	[Parameter(Mandatory=$true)]
	[string]$vdsname,
	[string]$segmentid,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.dvs.vmware.vxlan.network.vtep.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.dvs.vmware.vxlan.network.vtep.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.dvs.vmware.vxlan.network.vtep.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.dvs.vmware.vxlan.network.vtep.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('vtepip')){
					if($HashTable.containskey('vtepip')){
						$HashTable.vtepip = $vtepip
					}
					Else{
						Write-error "The parameter vtepip is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vxlanid')){
					if($HashTable.containskey('vxlanid')){
						$HashTable.vxlanid = $vxlanid
					}
					Else{
						Write-error "The parameter vxlanid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vdsname')){
					if($HashTable.containskey('vdsname')){
						$HashTable.vdsname = $vdsname
					}
					Else{
						Write-error "The parameter vdsname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('segmentid')){
					if($HashTable.containskey('segmentid')){
						$HashTable.segmentid = $segmentid
					}
					Else{
						Write-error "The parameter segmentid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.dvs.vmware.vxlan.network.vtep.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vtepip') -or $PSBoundParameters.ContainsKey('vxlanid') -or $PSBoundParameters.ContainsKey('vdsname') -or $PSBoundParameters.ContainsKey('segmentid')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.dvs.vmware.vxlan.network.vtep.list.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.vswitch.dvs.vmware.vxlan.stats{
<#
.SYNOPSIS
Get VXLAN DVSwitch statistics info.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER vdsname
The VDS name used to list VXLAN DVSwitch statistics info

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$vdsname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.dvs.vmware.vxlan.stats.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.dvs.vmware.vxlan.stats.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.dvs.vmware.vxlan.stats.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.dvs.vmware.vxlan.stats.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('vdsname')){
					if($HashTable.containskey('vdsname')){
						$HashTable.vdsname = $vdsname
					}
					Else{
						Write-error "The parameter vdsname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.dvs.vmware.vxlan.stats.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vdsname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.dvs.vmware.vxlan.stats.list.invoke()
				}
			}
		}
	}
}

function reset-EsxCLI.network.vswitch.dvs.vmware.vxlan.stats{
<#
.SYNOPSIS
Reset VXLAN DVSwitch statistics info.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER vdsname
The VDS name used to reset VXLAN DVSwitch statistics info

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$vdsname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.dvs.vmware.vxlan.stats.reset){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.dvs.vmware.vxlan.stats.reset is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.dvs.vmware.vxlan.stats.reset | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.dvs.vmware.vxlan.stats.reset.CreateArgs()
				if($PSBoundParameters.ContainsKey('vdsname')){
					if($HashTable.containskey('vdsname')){
						$HashTable.vdsname = $vdsname
					}
					Else{
						Write-error "The parameter vdsname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.dvs.vmware.vxlan.stats.reset.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vdsname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.dvs.vmware.vxlan.stats.reset.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.vswitch.dvs.vmware.vxlan.vmknic{
<#
.SYNOPSIS
Get VXLAN network info with specified VDS.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER endpointid
The endpoint ID used to list VXLAN vmknic info

.PARAMETER vdsname
The VDS name used to list VXLAN vmknic info

.PARAMETER vmknicip
The vmknic IP used to list VXLAN vmknic info

.PARAMETER vmknicname
The vmknic name used to list VXLAN vmknic info

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$vmknicname,
	[long]$endpointid,
	[string]$vmknicip,
	[Parameter(Mandatory=$true)]
	[string]$vdsname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.dvs.vmware.vxlan.vmknic.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.dvs.vmware.vxlan.vmknic.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.dvs.vmware.vxlan.vmknic.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.dvs.vmware.vxlan.vmknic.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('vmknicname')){
					if($HashTable.containskey('vmknicname')){
						$HashTable.vmknicname = $vmknicname
					}
					Else{
						Write-error "The parameter vmknicname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('endpointid')){
					if($HashTable.containskey('endpointid')){
						$HashTable.endpointid = $endpointid
					}
					Else{
						Write-error "The parameter endpointid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vmknicip')){
					if($HashTable.containskey('vmknicip')){
						$HashTable.vmknicip = $vmknicip
					}
					Else{
						Write-error "The parameter vmknicip is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vdsname')){
					if($HashTable.containskey('vdsname')){
						$HashTable.vdsname = $vdsname
					}
					Else{
						Write-error "The parameter vdsname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.dvs.vmware.vxlan.vmknic.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vmknicname') -or $PSBoundParameters.ContainsKey('endpointid') -or $PSBoundParameters.ContainsKey('vmknicip') -or $PSBoundParameters.ContainsKey('vdsname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.dvs.vmware.vxlan.vmknic.list.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.vswitch.dvs.vmware.vxlan.vmknic.multicastgroup{
<#
.SYNOPSIS
Get VXLAN vmknic multicast group info.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER vdsname
The VDS name used to get VXLAN vmknic multicast group info

.PARAMETER vmknicid
The vmknic ID used to get VXLAN vmknic multicast group info

.PARAMETER vmknicip
The vmknic IP used to get VXLAN vmknic multicast group info

.PARAMETER vmknicname
The vmknic name used to get VXLAN vmknic multicast group info

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$vmknicname,
	[long]$vmknicid,
	[string]$vmknicip,
	[Parameter(Mandatory=$true)]
	[string]$vdsname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.dvs.vmware.vxlan.vmknic.multicastgroup.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.dvs.vmware.vxlan.vmknic.multicastgroup.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.dvs.vmware.vxlan.vmknic.multicastgroup.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.dvs.vmware.vxlan.vmknic.multicastgroup.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('vmknicname')){
					if($HashTable.containskey('vmknicname')){
						$HashTable.vmknicname = $vmknicname
					}
					Else{
						Write-error "The parameter vmknicname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vmknicid')){
					if($HashTable.containskey('vmknicid')){
						$HashTable.vmknicid = $vmknicid
					}
					Else{
						Write-error "The parameter vmknicid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vmknicip')){
					if($HashTable.containskey('vmknicip')){
						$HashTable.vmknicip = $vmknicip
					}
					Else{
						Write-error "The parameter vmknicip is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vdsname')){
					if($HashTable.containskey('vdsname')){
						$HashTable.vdsname = $vdsname
					}
					Else{
						Write-error "The parameter vdsname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.dvs.vmware.vxlan.vmknic.multicastgroup.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vmknicname') -or $PSBoundParameters.ContainsKey('vmknicid') -or $PSBoundParameters.ContainsKey('vmknicip') -or $PSBoundParameters.ContainsKey('vdsname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.dvs.vmware.vxlan.vmknic.multicastgroup.list.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.vswitch.dvs.vmware.vxlan.vmknic.stats{
<#
.SYNOPSIS
Get VXLAN vmknic statistics info.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER endpointid
The endpoint ID used to get VXLAN vmknic statistics info

.PARAMETER vdsname
The VDS name used to get VXLAN vmknic statistics info

.PARAMETER vmknicip
The vmknic IP used to get VXLAN vmknic statistics info

.PARAMETER vmknicname
The vmknic name used to get VXLAN vmknic statistics info

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$vmknicname,
	[long]$endpointid,
	[string]$vmknicip,
	[Parameter(Mandatory=$true)]
	[string]$vdsname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.dvs.vmware.vxlan.vmknic.stats.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.dvs.vmware.vxlan.vmknic.stats.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.dvs.vmware.vxlan.vmknic.stats.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.dvs.vmware.vxlan.vmknic.stats.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('vmknicname')){
					if($HashTable.containskey('vmknicname')){
						$HashTable.vmknicname = $vmknicname
					}
					Else{
						Write-error "The parameter vmknicname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('endpointid')){
					if($HashTable.containskey('endpointid')){
						$HashTable.endpointid = $endpointid
					}
					Else{
						Write-error "The parameter endpointid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vmknicip')){
					if($HashTable.containskey('vmknicip')){
						$HashTable.vmknicip = $vmknicip
					}
					Else{
						Write-error "The parameter vmknicip is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vdsname')){
					if($HashTable.containskey('vdsname')){
						$HashTable.vdsname = $vdsname
					}
					Else{
						Write-error "The parameter vdsname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.dvs.vmware.vxlan.vmknic.stats.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vmknicname') -or $PSBoundParameters.ContainsKey('endpointid') -or $PSBoundParameters.ContainsKey('vmknicip') -or $PSBoundParameters.ContainsKey('vdsname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.dvs.vmware.vxlan.vmknic.stats.list.invoke()
				}
			}
		}
	}
}

function reset-EsxCLI.network.vswitch.dvs.vmware.vxlan.vmknic.stats{
<#
.SYNOPSIS
Reset VXLAN vmknic statistics info.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER endpointid
The endpoint ID used to reset VXLAN vmknic statistics info

.PARAMETER vdsname
The VDS name used to reset VXLAN vmknic statistics info

.PARAMETER vmknicip
The vmknic IP used to reset VXLAN vmknic statistics info

.PARAMETER vmknicname
The vmknic name used to reset VXLAN vmknic statistics info

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$vmknicname,
	[long]$endpointid,
	[string]$vmknicip,
	[Parameter(Mandatory=$true)]
	[string]$vdsname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.dvs.vmware.vxlan.vmknic.stats.reset){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.dvs.vmware.vxlan.vmknic.stats.reset is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.dvs.vmware.vxlan.vmknic.stats.reset | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.dvs.vmware.vxlan.vmknic.stats.reset.CreateArgs()
				if($PSBoundParameters.ContainsKey('vmknicname')){
					if($HashTable.containskey('vmknicname')){
						$HashTable.vmknicname = $vmknicname
					}
					Else{
						Write-error "The parameter vmknicname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('endpointid')){
					if($HashTable.containskey('endpointid')){
						$HashTable.endpointid = $endpointid
					}
					Else{
						Write-error "The parameter endpointid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vmknicip')){
					if($HashTable.containskey('vmknicip')){
						$HashTable.vmknicip = $vmknicip
					}
					Else{
						Write-error "The parameter vmknicip is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vdsname')){
					if($HashTable.containskey('vdsname')){
						$HashTable.vdsname = $vdsname
					}
					Else{
						Write-error "The parameter vdsname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.dvs.vmware.vxlan.vmknic.stats.reset.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vmknicname') -or $PSBoundParameters.ContainsKey('endpointid') -or $PSBoundParameters.ContainsKey('vmknicip') -or $PSBoundParameters.ContainsKey('vdsname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.dvs.vmware.vxlan.vmknic.stats.reset.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.network.vswitch.standard{
<#
.SYNOPSIS
Add a new virtual switch to the ESXi networking system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER ports
The number of ports to to give this newly created virtual switch. Maximum ports per virtual switch is 4096. If no value is given the default value(128) is used. The number of ports is limited by the number of already allocated ports on the host. The system wide port count cannot be greater than 4608.

.PARAMETER vswitchname
The name of the virtual switch to create.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[long]$ports,
	[Parameter(Mandatory=$true)]
	[string]$vswitchname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.standard.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.standard.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.standard.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.standard.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('ports')){
					if($HashTable.containskey('ports')){
						$HashTable.ports = $ports
					}
					Else{
						Write-error "The parameter ports is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vswitchname')){
					if($HashTable.containskey('vswitchname')){
						$HashTable.vswitchname = $vswitchname
					}
					Else{
						Write-error "The parameter vswitchname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.standard.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('ports') -or $PSBoundParameters.ContainsKey('vswitchname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.standard.add.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.vswitch.standard{
<#
.SYNOPSIS
List the virtual switches current on the ESXi host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER vswitchname
Limit the output of this command to only virtual switches with the given name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$vswitchname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.standard.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.standard.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.standard.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.standard.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('vswitchname')){
					if($HashTable.containskey('vswitchname')){
						$HashTable.vswitchname = $vswitchname
					}
					Else{
						Write-error "The parameter vswitchname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.standard.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vswitchname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.standard.list.invoke()
				}
			}
		}
	}
}

function remove-EsxCLI.network.vswitch.standard{
<#
.SYNOPSIS
Remove a virtual switch from the ESXi networking system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER vswitchname
The name of the virtual switch to remove.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$vswitchname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.standard.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.standard.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.standard.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.standard.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('vswitchname')){
					if($HashTable.containskey('vswitchname')){
						$HashTable.vswitchname = $vswitchname
					}
					Else{
						Write-error "The parameter vswitchname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.standard.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vswitchname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.standard.remove.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.network.vswitch.standard{
<#
.SYNOPSIS
This command sets the MTU size and CDP status of a given virtual switch.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER cdpstatus
The CDP status of the given virtual switch. It can be 'down', 'listen', 'advertise' or 'both'

.PARAMETER mtu
The MTU size of the given virtual switch.

.PARAMETER vswitchname
The name of virtual switch to apply the configurations.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$vswitchname,
	[long]$mtu,
	[string]$cdpstatus,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.standard.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.standard.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.standard.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.standard.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('vswitchname')){
					if($HashTable.containskey('vswitchname')){
						$HashTable.vswitchname = $vswitchname
					}
					Else{
						Write-error "The parameter vswitchname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('mtu')){
					if($HashTable.containskey('mtu')){
						$HashTable.mtu = $mtu
					}
					Else{
						Write-error "The parameter mtu is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('cdpstatus')){
					if($HashTable.containskey('cdpstatus')){
						$HashTable.cdpstatus = $cdpstatus
					}
					Else{
						Write-error "The parameter cdpstatus is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.standard.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vswitchname') -or $PSBoundParameters.ContainsKey('mtu') -or $PSBoundParameters.ContainsKey('cdpstatus')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.standard.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.network.vswitch.standard.policy.failover{
<#
.SYNOPSIS
Get the failover policy settings governing the given virtual switch

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER vswitchname
The name of the virtual switch to use when fetching the switch failover policy.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$vswitchname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.standard.policy.failover.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.standard.policy.failover.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.standard.policy.failover.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.standard.policy.failover.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('vswitchname')){
					if($HashTable.containskey('vswitchname')){
						$HashTable.vswitchname = $vswitchname
					}
					Else{
						Write-error "The parameter vswitchname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.standard.policy.failover.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vswitchname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.standard.policy.failover.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.network.vswitch.standard.policy.failover{
<#
.SYNOPSIS
Configure the Failover policy for a virtual switch.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER activeuplinks
Configure the list of active adapters and their failover order. This list must be a comma seperated list of values with the uplink name and no spaces. Example:  --active-uplinks=vmnic0,vmnic3,vmnic7,vmnic1

.PARAMETER failback
Configure whether a NIC will be used immediately when it comes back in service after a failover

.PARAMETER failuredetection
Set the method of determining how a network outage is detected. 
    beacon: Detect failures based on active beaconing to the vswitch
    link: Detect failures based on the NIC link state

.PARAMETER loadbalancing
Set the load balancing policy for this policy. This can be one of the following options: 
    explicit: Always use the highest order uplink from the list of active adapters which pass failover criteria.
    iphash: Route based on hashing the src and destination IP addresses
    mac: Route based on the MAC address of the packet source.
    portid: Route based on the originating virtual port ID.

.PARAMETER notifyswitches
Indicate whether to send a notification to physical switches on failover

.PARAMETER standbyuplinks
Configure the list of standby adapters and their failover order. This list must be a comma seperated list of values with the uplink name and no spaces. Example:  --standby-uplinks=vmnic2,vmnic4,vmnic8,vmnic6,vmnic11

.PARAMETER vswitchname
The name of the virtual switch to use when configuring the switch failover policy.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$activeuplinks,
	[string]$loadbalancing,
	[boolean]$notifyswitches,
	[Parameter(Mandatory=$true)]
	[string]$vswitchname,
	[string]$standbyuplinks,
	[boolean]$failback,
	[string]$failuredetection,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.standard.policy.failover.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.standard.policy.failover.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.standard.policy.failover.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.standard.policy.failover.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('activeuplinks')){
					if($HashTable.containskey('activeuplinks')){
						$HashTable.activeuplinks = $activeuplinks
					}
					Else{
						Write-error "The parameter activeuplinks is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('loadbalancing')){
					if($HashTable.containskey('loadbalancing')){
						$HashTable.loadbalancing = $loadbalancing
					}
					Else{
						Write-error "The parameter loadbalancing is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('notifyswitches')){
					if($HashTable.containskey('notifyswitches')){
						$HashTable.notifyswitches = $notifyswitches
					}
					Else{
						Write-error "The parameter notifyswitches is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vswitchname')){
					if($HashTable.containskey('vswitchname')){
						$HashTable.vswitchname = $vswitchname
					}
					Else{
						Write-error "The parameter vswitchname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('standbyuplinks')){
					if($HashTable.containskey('standbyuplinks')){
						$HashTable.standbyuplinks = $standbyuplinks
					}
					Else{
						Write-error "The parameter standbyuplinks is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('failback')){
					if($HashTable.containskey('failback')){
						$HashTable.failback = $failback
					}
					Else{
						Write-error "The parameter failback is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('failuredetection')){
					if($HashTable.containskey('failuredetection')){
						$HashTable.failuredetection = $failuredetection
					}
					Else{
						Write-error "The parameter failuredetection is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.standard.policy.failover.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('activeuplinks') -or $PSBoundParameters.ContainsKey('loadbalancing') -or $PSBoundParameters.ContainsKey('notifyswitches') -or $PSBoundParameters.ContainsKey('vswitchname') -or $PSBoundParameters.ContainsKey('standbyuplinks') -or $PSBoundParameters.ContainsKey('failback') -or $PSBoundParameters.ContainsKey('failuredetection')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.standard.policy.failover.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.network.vswitch.standard.policy.security{
<#
.SYNOPSIS
Get the Security Policy governing the given virtual switch.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER vswitchname
The name of the virtual switch to use when fetching the network security policy.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$vswitchname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.standard.policy.security.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.standard.policy.security.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.standard.policy.security.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.standard.policy.security.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('vswitchname')){
					if($HashTable.containskey('vswitchname')){
						$HashTable.vswitchname = $vswitchname
					}
					Else{
						Write-error "The parameter vswitchname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.standard.policy.security.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vswitchname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.standard.policy.security.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.network.vswitch.standard.policy.security{
<#
.SYNOPSIS
Set the security policy for a given virtual switch

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER allowforgedtransmits
Allow ports on the virtual switch to send packets with forged source information.

.PARAMETER allowmacchange
Allow ports on the virtual switch to change their MAC address.

.PARAMETER allowpromiscuous
Allow ports on the virtual switch to enter promiscuous mode.

.PARAMETER vswitchname
The name of the virtual switch to use when setting the switch security policy.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$vswitchname,
	[boolean]$allowmacchange,
	[boolean]$allowpromiscuous,
	[boolean]$allowforgedtransmits,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.standard.policy.security.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.standard.policy.security.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.standard.policy.security.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.standard.policy.security.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('vswitchname')){
					if($HashTable.containskey('vswitchname')){
						$HashTable.vswitchname = $vswitchname
					}
					Else{
						Write-error "The parameter vswitchname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('allowmacchange')){
					if($HashTable.containskey('allowmacchange')){
						$HashTable.allowmacchange = $allowmacchange
					}
					Else{
						Write-error "The parameter allowmacchange is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('allowpromiscuous')){
					if($HashTable.containskey('allowpromiscuous')){
						$HashTable.allowpromiscuous = $allowpromiscuous
					}
					Else{
						Write-error "The parameter allowpromiscuous is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('allowforgedtransmits')){
					if($HashTable.containskey('allowforgedtransmits')){
						$HashTable.allowforgedtransmits = $allowforgedtransmits
					}
					Else{
						Write-error "The parameter allowforgedtransmits is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.standard.policy.security.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vswitchname') -or $PSBoundParameters.ContainsKey('allowmacchange') -or $PSBoundParameters.ContainsKey('allowpromiscuous') -or $PSBoundParameters.ContainsKey('allowforgedtransmits')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.standard.policy.security.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.network.vswitch.standard.policy.shaping{
<#
.SYNOPSIS
Get the shaping policy settings for the given virtual switch

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER vswitchname
The name of the virtual switch to use when fetching the switch shaping policy.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$vswitchname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.standard.policy.shaping.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.standard.policy.shaping.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.standard.policy.shaping.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.standard.policy.shaping.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('vswitchname')){
					if($HashTable.containskey('vswitchname')){
						$HashTable.vswitchname = $vswitchname
					}
					Else{
						Write-error "The parameter vswitchname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.standard.policy.shaping.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vswitchname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.standard.policy.shaping.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.network.vswitch.standard.policy.shaping{
<#
.SYNOPSIS
Set the shaping policy settings for the given virtual switch

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER avgbandwidth
The averge bandwidth allowed for this shaping policy. This value is in Kbps (1 Kbps = 1000 bits/s)

.PARAMETER burstsize
The largest burst size allowed for this shaping policy. This value is in Kib (1 Kib = 1024 bits)

.PARAMETER enabled
Indicate whether to enable traffic shaping on this policy. If this is true then the --avg-bandwidth, --peak-bandwidth and --burst-size options are required.

.PARAMETER peakbandwidth
The peak bandwidth allowed for this shaping policy. This value is in Kbps (1 Kbps = 1000 bits/s)

.PARAMETER vswitchname
The name of the virtual switch to use when setting the switch shaping policy.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$enabled,
	[long]$burstsize,
	[long]$avgbandwidth,
	[Parameter(Mandatory=$true)]
	[string]$vswitchname,
	[long]$peakbandwidth,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.standard.policy.shaping.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.standard.policy.shaping.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.standard.policy.shaping.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.standard.policy.shaping.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('enabled')){
					if($HashTable.containskey('enabled')){
						$HashTable.enabled = $enabled
					}
					Else{
						Write-error "The parameter enabled is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('burstsize')){
					if($HashTable.containskey('burstsize')){
						$HashTable.burstsize = $burstsize
					}
					Else{
						Write-error "The parameter burstsize is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('avgbandwidth')){
					if($HashTable.containskey('avgbandwidth')){
						$HashTable.avgbandwidth = $avgbandwidth
					}
					Else{
						Write-error "The parameter avgbandwidth is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vswitchname')){
					if($HashTable.containskey('vswitchname')){
						$HashTable.vswitchname = $vswitchname
					}
					Else{
						Write-error "The parameter vswitchname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('peakbandwidth')){
					if($HashTable.containskey('peakbandwidth')){
						$HashTable.peakbandwidth = $peakbandwidth
					}
					Else{
						Write-error "The parameter peakbandwidth is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.standard.policy.shaping.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('enabled') -or $PSBoundParameters.ContainsKey('burstsize') -or $PSBoundParameters.ContainsKey('avgbandwidth') -or $PSBoundParameters.ContainsKey('vswitchname') -or $PSBoundParameters.ContainsKey('peakbandwidth')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.standard.policy.shaping.set.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.network.vswitch.standard.portgroup{
<#
.SYNOPSIS
Allows the addition of a standard port group to a virtual switch.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER portgroupname
The name of the port group to add

.PARAMETER vswitchname
The virtual switch to add the port group to.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$portgroupname,
	[Parameter(Mandatory=$true)]
	[string]$vswitchname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.standard.portgroup.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.standard.portgroup.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.standard.portgroup.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.standard.portgroup.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('portgroupname')){
					if($HashTable.containskey('portgroupname')){
						$HashTable.portgroupname = $portgroupname
					}
					Else{
						Write-error "The parameter portgroupname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vswitchname')){
					if($HashTable.containskey('vswitchname')){
						$HashTable.vswitchname = $vswitchname
					}
					Else{
						Write-error "The parameter vswitchname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.standard.portgroup.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('portgroupname') -or $PSBoundParameters.ContainsKey('vswitchname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.standard.portgroup.add.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.network.vswitch.standard.portgroup{
<#
.SYNOPSIS
List all of the port groups currently on the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.standard.portgroup.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.standard.portgroup.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.network.vswitch.standard.portgroup.list.invoke()
		}
	}
}

function remove-EsxCLI.network.vswitch.standard.portgroup{
<#
.SYNOPSIS
Remove a port group from the given virtual switch

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER portgroupname


.PARAMETER vswitchname


.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$portgroupname,
	[Parameter(Mandatory=$true)]
	[string]$vswitchname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.standard.portgroup.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.standard.portgroup.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.standard.portgroup.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.standard.portgroup.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('portgroupname')){
					if($HashTable.containskey('portgroupname')){
						$HashTable.portgroupname = $portgroupname
					}
					Else{
						Write-error "The parameter portgroupname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vswitchname')){
					if($HashTable.containskey('vswitchname')){
						$HashTable.vswitchname = $vswitchname
					}
					Else{
						Write-error "The parameter vswitchname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.standard.portgroup.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('portgroupname') -or $PSBoundParameters.ContainsKey('vswitchname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.standard.portgroup.remove.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.network.vswitch.standard.portgroup{
<#
.SYNOPSIS
Set the vlan id for the given port group

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER portgroupname
The name of the port group to set vlan id for.

.PARAMETER vlanid
The vlan id for this port group. This value is in the range (0 - 4095)

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[long]$vlanid,
	[Parameter(Mandatory=$true)]
	[string]$portgroupname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.standard.portgroup.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.standard.portgroup.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.standard.portgroup.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.standard.portgroup.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('vlanid')){
					if($HashTable.containskey('vlanid')){
						$HashTable.vlanid = $vlanid
					}
					Else{
						Write-error "The parameter vlanid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('portgroupname')){
					if($HashTable.containskey('portgroupname')){
						$HashTable.portgroupname = $portgroupname
					}
					Else{
						Write-error "The parameter portgroupname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.standard.portgroup.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vlanid') -or $PSBoundParameters.ContainsKey('portgroupname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.standard.portgroup.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.network.vswitch.standard.portgroup.policy.failover{
<#
.SYNOPSIS
Get the network failover policy settings governing the given port group

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER portgroupname
The name of the port group to use when fetching the port group failover policy.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$portgroupname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.standard.portgroup.policy.failover.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.standard.portgroup.policy.failover.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.standard.portgroup.policy.failover.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.standard.portgroup.policy.failover.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('portgroupname')){
					if($HashTable.containskey('portgroupname')){
						$HashTable.portgroupname = $portgroupname
					}
					Else{
						Write-error "The parameter portgroupname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.standard.portgroup.policy.failover.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('portgroupname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.standard.portgroup.policy.failover.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.network.vswitch.standard.portgroup.policy.failover{
<#
.SYNOPSIS
Configure the Failover policy for a port group. These setting may potentially override virtual switch settings.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER activeuplinks
Configure the list of active adapters and their failover order. This list must be a comma seperated list of values with the uplink name and no spaces. Example:  --active-uplinks=vmnic0,vmnic3,vmnic7,vmnic1

.PARAMETER failback
Configure whether a NIC will be used immediately when it comes back in service after a failover

.PARAMETER failuredetection
Set the method of determining how a network outage is detected. 
    beacon: Detect failures based on active beaconing to the vswitch
    link: Detect failures based on the NIC link state

.PARAMETER loadbalancing
Set the load balancing policy for this policy. This can be one of the following options: 
    explicit: Always use the highest order uplink from the list of active adapters which pass failover criteria.
    iphash: Route based on hashing the src and destination IP addresses
    mac: Route based on the MAC address of the packet source.
    portid: Route based on the originating virtual port ID.

.PARAMETER notifyswitches
Indicate whether to send a notification to physical switches on failover

.PARAMETER portgroupname
The name of the port group to set failover policy for.

.PARAMETER standbyuplinks
Configure the list of standby adapters and their failover order. This list must be a comma seperated list of values with the uplink name and no spaces. Example:  --standby-uplinks=vmnic2,vmnic4,vmnic8,vmnic6,vmnic11

.PARAMETER usevswitch
Reset all values for this policy to use parent virtual switch's settings instead of overriding the settings for the port group. Using this in conjunction with other settings will first reset all of the fields to use the virtual switch setting and then apply the other options after the reset.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$activeuplinks,
	[string]$loadbalancing,
	[boolean]$notifyswitches,
	[Parameter(Mandatory=$true)]
	[string]$portgroupname,
	[string]$standbyuplinks,
	[boolean]$failback,
	[boolean]$usevswitch,
	[string]$failuredetection,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.standard.portgroup.policy.failover.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.standard.portgroup.policy.failover.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.standard.portgroup.policy.failover.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.standard.portgroup.policy.failover.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('activeuplinks')){
					if($HashTable.containskey('activeuplinks')){
						$HashTable.activeuplinks = $activeuplinks
					}
					Else{
						Write-error "The parameter activeuplinks is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('loadbalancing')){
					if($HashTable.containskey('loadbalancing')){
						$HashTable.loadbalancing = $loadbalancing
					}
					Else{
						Write-error "The parameter loadbalancing is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('notifyswitches')){
					if($HashTable.containskey('notifyswitches')){
						$HashTable.notifyswitches = $notifyswitches
					}
					Else{
						Write-error "The parameter notifyswitches is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('portgroupname')){
					if($HashTable.containskey('portgroupname')){
						$HashTable.portgroupname = $portgroupname
					}
					Else{
						Write-error "The parameter portgroupname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('standbyuplinks')){
					if($HashTable.containskey('standbyuplinks')){
						$HashTable.standbyuplinks = $standbyuplinks
					}
					Else{
						Write-error "The parameter standbyuplinks is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('failback')){
					if($HashTable.containskey('failback')){
						$HashTable.failback = $failback
					}
					Else{
						Write-error "The parameter failback is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('usevswitch')){
					if($HashTable.containskey('usevswitch')){
						$HashTable.usevswitch = $usevswitch
					}
					Else{
						Write-error "The parameter usevswitch is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('failuredetection')){
					if($HashTable.containskey('failuredetection')){
						$HashTable.failuredetection = $failuredetection
					}
					Else{
						Write-error "The parameter failuredetection is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.standard.portgroup.policy.failover.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('activeuplinks') -or $PSBoundParameters.ContainsKey('loadbalancing') -or $PSBoundParameters.ContainsKey('notifyswitches') -or $PSBoundParameters.ContainsKey('portgroupname') -or $PSBoundParameters.ContainsKey('standbyuplinks') -or $PSBoundParameters.ContainsKey('failback') -or $PSBoundParameters.ContainsKey('usevswitch') -or $PSBoundParameters.ContainsKey('failuredetection')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.standard.portgroup.policy.failover.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.network.vswitch.standard.portgroup.policy.security{
<#
.SYNOPSIS
Get the Security Policy governing the given port group.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER portgroupname
The name of the port group to use when fetching the network security policy.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$portgroupname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.standard.portgroup.policy.security.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.standard.portgroup.policy.security.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.standard.portgroup.policy.security.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.standard.portgroup.policy.security.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('portgroupname')){
					if($HashTable.containskey('portgroupname')){
						$HashTable.portgroupname = $portgroupname
					}
					Else{
						Write-error "The parameter portgroupname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.standard.portgroup.policy.security.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('portgroupname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.standard.portgroup.policy.security.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.network.vswitch.standard.portgroup.policy.security{
<#
.SYNOPSIS
Set the security policy for a given port group

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER allowforgedtransmits
Allow ports on the virtual switch to send packets with forged source information.

.PARAMETER allowmacchange
Allow ports on the virtual switch to change their MAC address.

.PARAMETER allowpromiscuous
Allow ports on the virtual switch to enter promiscuous mode.

.PARAMETER portgroupname
The name of the port group to set security policy for.

.PARAMETER usevswitch
Reset all values for this policy to use parent virtual switch's settings instead of overriding the settings for the port group.   Using this in conjunction with other settings will first reset all of the fields to use the virtual switch setting and then apply the other options after the reset.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$portgroupname,
	[boolean]$usevswitch,
	[boolean]$allowmacchange,
	[boolean]$allowpromiscuous,
	[boolean]$allowforgedtransmits,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.standard.portgroup.policy.security.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.standard.portgroup.policy.security.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.standard.portgroup.policy.security.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.standard.portgroup.policy.security.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('portgroupname')){
					if($HashTable.containskey('portgroupname')){
						$HashTable.portgroupname = $portgroupname
					}
					Else{
						Write-error "The parameter portgroupname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('usevswitch')){
					if($HashTable.containskey('usevswitch')){
						$HashTable.usevswitch = $usevswitch
					}
					Else{
						Write-error "The parameter usevswitch is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('allowmacchange')){
					if($HashTable.containskey('allowmacchange')){
						$HashTable.allowmacchange = $allowmacchange
					}
					Else{
						Write-error "The parameter allowmacchange is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('allowpromiscuous')){
					if($HashTable.containskey('allowpromiscuous')){
						$HashTable.allowpromiscuous = $allowpromiscuous
					}
					Else{
						Write-error "The parameter allowpromiscuous is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('allowforgedtransmits')){
					if($HashTable.containskey('allowforgedtransmits')){
						$HashTable.allowforgedtransmits = $allowforgedtransmits
					}
					Else{
						Write-error "The parameter allowforgedtransmits is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.standard.portgroup.policy.security.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('portgroupname') -or $PSBoundParameters.ContainsKey('usevswitch') -or $PSBoundParameters.ContainsKey('allowmacchange') -or $PSBoundParameters.ContainsKey('allowpromiscuous') -or $PSBoundParameters.ContainsKey('allowforgedtransmits')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.standard.portgroup.policy.security.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.network.vswitch.standard.portgroup.policy.shaping{
<#
.SYNOPSIS
Get the network shaping policy settings governing the given port group

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER portgroupname
The name of the port group to use when fetching the port group shaping policy.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$portgroupname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.standard.portgroup.policy.shaping.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.standard.portgroup.policy.shaping.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.standard.portgroup.policy.shaping.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.standard.portgroup.policy.shaping.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('portgroupname')){
					if($HashTable.containskey('portgroupname')){
						$HashTable.portgroupname = $portgroupname
					}
					Else{
						Write-error "The parameter portgroupname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.standard.portgroup.policy.shaping.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('portgroupname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.standard.portgroup.policy.shaping.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.network.vswitch.standard.portgroup.policy.shaping{
<#
.SYNOPSIS
Set the shaping policy settings for the given port group

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER avgbandwidth
The averge bandwidth allowed for this shaping policy. This value is in Kbps (1 Kbps = 1000 bits/s)

.PARAMETER burstsize
The largest burst size allowed for this shaping policy. This value is in Kib (1 Kib = 1024 bits)

.PARAMETER enabled
Indicate whether to enable traffic shaping on this policy. If this is true then the --avg-bandwidth, --peak-bandwidth and --burst-size options are required.

.PARAMETER peakbandwidth
The peak bandwidth allowed for this shaping policy. This value is in Kbps (1 Kbps = 1000 bits/s)

.PARAMETER portgroupname
The name of the port group to set shaping policy for.

.PARAMETER usevswitch
Reset all values for this policy to use parent virtual switch's settings instead of overriding the settings for the port group. Using this in conjunction with other settings will first reset all of the fields to use the virtual switch setting and then apply the other options after the reset.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$enabled,
	[Parameter(Mandatory=$true)]
	[string]$portgroupname,
	[long]$avgbandwidth,
	[long]$peakbandwidth,
	[boolean]$usevswitch,
	[long]$burstsize,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.standard.portgroup.policy.shaping.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.standard.portgroup.policy.shaping.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.standard.portgroup.policy.shaping.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.standard.portgroup.policy.shaping.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('enabled')){
					if($HashTable.containskey('enabled')){
						$HashTable.enabled = $enabled
					}
					Else{
						Write-error "The parameter enabled is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('portgroupname')){
					if($HashTable.containskey('portgroupname')){
						$HashTable.portgroupname = $portgroupname
					}
					Else{
						Write-error "The parameter portgroupname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('avgbandwidth')){
					if($HashTable.containskey('avgbandwidth')){
						$HashTable.avgbandwidth = $avgbandwidth
					}
					Else{
						Write-error "The parameter avgbandwidth is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('peakbandwidth')){
					if($HashTable.containskey('peakbandwidth')){
						$HashTable.peakbandwidth = $peakbandwidth
					}
					Else{
						Write-error "The parameter peakbandwidth is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('usevswitch')){
					if($HashTable.containskey('usevswitch')){
						$HashTable.usevswitch = $usevswitch
					}
					Else{
						Write-error "The parameter usevswitch is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('burstsize')){
					if($HashTable.containskey('burstsize')){
						$HashTable.burstsize = $burstsize
					}
					Else{
						Write-error "The parameter burstsize is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.standard.portgroup.policy.shaping.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('enabled') -or $PSBoundParameters.ContainsKey('portgroupname') -or $PSBoundParameters.ContainsKey('avgbandwidth') -or $PSBoundParameters.ContainsKey('peakbandwidth') -or $PSBoundParameters.ContainsKey('usevswitch') -or $PSBoundParameters.ContainsKey('burstsize')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.standard.portgroup.policy.shaping.set.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.network.vswitch.standard.uplink{
<#
.SYNOPSIS
Add an uplink to the given virtual switch. Note if this virtual switch has a NIC teaming policy assigned to it then the policy must also be modified to enable use of this uplink on this virtual switch

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER uplinkname
The name of the uplink to add to the virtual switch.

.PARAMETER vswitchname
The name of the virtual switch to add an uplink to.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$vswitchname,
	[Parameter(Mandatory=$true)]
	[string]$uplinkname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.standard.uplink.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.standard.uplink.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.standard.uplink.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.standard.uplink.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('vswitchname')){
					if($HashTable.containskey('vswitchname')){
						$HashTable.vswitchname = $vswitchname
					}
					Else{
						Write-error "The parameter vswitchname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('uplinkname')){
					if($HashTable.containskey('uplinkname')){
						$HashTable.uplinkname = $uplinkname
					}
					Else{
						Write-error "The parameter uplinkname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.standard.uplink.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vswitchname') -or $PSBoundParameters.ContainsKey('uplinkname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.standard.uplink.add.invoke()
				}
			}
		}
	}
}

function remove-EsxCLI.network.vswitch.standard.uplink{
<#
.SYNOPSIS
Remove an uplink from the given virtual switch. Note if this virtual switch has a NIC teaming policy assigned to it then the policy must also be modified to disable use of this uplink on this virtual switch

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER uplinkname
The name of the uplink to remove from the virtual switch.

.PARAMETER vswitchname
The name of the virtual switch to remove an uplink from.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$vswitchname,
	[Parameter(Mandatory=$true)]
	[string]$uplinkname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.network.vswitch.standard.uplink.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.network.vswitch.standard.uplink.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.network.vswitch.standard.uplink.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.network.vswitch.standard.uplink.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('vswitchname')){
					if($HashTable.containskey('vswitchname')){
						$HashTable.vswitchname = $vswitchname
					}
					Else{
						Write-error "The parameter vswitchname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('uplinkname')){
					if($HashTable.containskey('uplinkname')){
						$HashTable.uplinkname = $uplinkname
					}
					Else{
						Write-error "The parameter uplinkname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.network.vswitch.standard.uplink.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('vswitchname') -or $PSBoundParameters.ContainsKey('uplinkname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.network.vswitch.standard.uplink.remove.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.rdma.device{
<#
.SYNOPSIS
List the logical RDMA devices currently registered on the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.rdma.device.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.rdma.device.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.rdma.device.list.invoke()
		}
	}
}

function get-EsxCLI.rdma.device.stats{
<#
.SYNOPSIS
Get statistics for a given RDMA device.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER device
Name of the RDMA device.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$device,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.rdma.device.stats.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.rdma.device.stats.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.rdma.device.stats.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.rdma.device.stats.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.rdma.device.stats.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('device')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.rdma.device.stats.get.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.rdma.device.vmknic{
<#
.SYNOPSIS
List the vmknics associated with RDMA devices.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER device
Name of the RDMA device whose vmknics to display.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$device,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.rdma.device.vmknic.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.rdma.device.vmknic.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.rdma.device.vmknic.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.rdma.device.vmknic.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.rdma.device.vmknic.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('device')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.rdma.device.vmknic.list.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.sched.reliablemem{
<#
.SYNOPSIS
Check if the system is currently aware of reliable memory.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.sched.reliablemem.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.sched.reliablemem.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.sched.reliablemem.get.invoke()
		}
	}
}

function get-EsxCLI.sched.swap.system{
<#
.SYNOPSIS
Get current state of the options of the system-wide shared swap space.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.sched.swap.system.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.sched.swap.system.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.sched.swap.system.get.invoke()
		}
	}
}

function set-EsxCLI.sched.swap.system{
<#
.SYNOPSIS
Change the configuration of system-wide shared swap space.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER datastoreenabled
If the datastore option should be enabled or not.

.PARAMETER datastorename
The name of the datastore used by the datastore option.

.PARAMETER datastoreorder
The order of the datastore option in the preference of the options

.PARAMETER hostcacheenabled
If the host cache option should be enabled or not.

.PARAMETER hostcacheorder
The order of the host cache option in the preference of the options.

.PARAMETER hostlocalswapenabled
If the host local swap option should be enabled or not.

.PARAMETER hostlocalswaporder
The order of the host local swap option in the preference of the options.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$datastoreenabled,
	[long]$hostcacheorder,
	[long]$hostlocalswaporder,
	[string]$datastorename,
	[boolean]$hostcacheenabled,
	[long]$datastoreorder,
	[boolean]$hostlocalswapenabled,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.sched.swap.system.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.sched.swap.system.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.sched.swap.system.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.sched.swap.system.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('datastoreenabled')){
					if($HashTable.containskey('datastoreenabled')){
						$HashTable.datastoreenabled = $datastoreenabled
					}
					Else{
						Write-error "The parameter datastoreenabled is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('hostcacheorder')){
					if($HashTable.containskey('hostcacheorder')){
						$HashTable.hostcacheorder = $hostcacheorder
					}
					Else{
						Write-error "The parameter hostcacheorder is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('hostlocalswaporder')){
					if($HashTable.containskey('hostlocalswaporder')){
						$HashTable.hostlocalswaporder = $hostlocalswaporder
					}
					Else{
						Write-error "The parameter hostlocalswaporder is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('datastorename')){
					if($HashTable.containskey('datastorename')){
						$HashTable.datastorename = $datastorename
					}
					Else{
						Write-error "The parameter datastorename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('hostcacheenabled')){
					if($HashTable.containskey('hostcacheenabled')){
						$HashTable.hostcacheenabled = $hostcacheenabled
					}
					Else{
						Write-error "The parameter hostcacheenabled is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('datastoreorder')){
					if($HashTable.containskey('datastoreorder')){
						$HashTable.datastoreorder = $datastoreorder
					}
					Else{
						Write-error "The parameter datastoreorder is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('hostlocalswapenabled')){
					if($HashTable.containskey('hostlocalswapenabled')){
						$HashTable.hostlocalswapenabled = $hostlocalswapenabled
					}
					Else{
						Write-error "The parameter hostlocalswapenabled is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.sched.swap.system.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('datastoreenabled') -or $PSBoundParameters.ContainsKey('hostcacheorder') -or $PSBoundParameters.ContainsKey('hostlocalswaporder') -or $PSBoundParameters.ContainsKey('datastorename') -or $PSBoundParameters.ContainsKey('hostcacheenabled') -or $PSBoundParameters.ContainsKey('datastoreorder') -or $PSBoundParameters.ContainsKey('hostlocalswapenabled')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.sched.swap.system.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.software.acceptance{
<#
.SYNOPSIS
Gets the host acceptance level. This controls what VIBs will be allowed on a host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.software.acceptance.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.software.acceptance.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.software.acceptance.get.invoke()
		}
	}
}

function set-EsxCLI.software.acceptance{
<#
.SYNOPSIS
Sets the host acceptance level. This controls what VIBs will be allowed on a host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER level
Specifies the acceptance level to set. Should be one of VMwareCertified / VMwareAccepted / PartnerSupported / CommunitySupported.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$level,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.software.acceptance.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.software.acceptance.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.software.acceptance.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.software.acceptance.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('level')){
					if($HashTable.containskey('level')){
						$HashTable.level = $level
					}
					Else{
						Write-error "The parameter level is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.software.acceptance.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('level')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.software.acceptance.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.software.profile{
<#
.SYNOPSIS
Display the installed image profile.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER rebootingimage
Displays information for the ESXi image which becomes active after a reboot, or nothing if the pending-reboot image has not been created yet.  If not specified, information from the current ESXi image in memory will be returned.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$rebootingimage,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.software.profile.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.software.profile.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.software.profile.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.software.profile.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('rebootingimage')){
					if($HashTable.containskey('rebootingimage')){
						$HashTable.rebootingimage = $rebootingimage
					}
					Else{
						Write-error "The parameter rebootingimage is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.software.profile.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('rebootingimage')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.software.profile.get.invoke()
				}
			}
		}
	}
}

function install-EsxCLI.software.profile{
<#
.SYNOPSIS
Installs or applies an image profile from a depot to this host. This command completely replaces the installed image with the image defined by the new image profile, and may result in the loss of installed VIBs. The common vibs between host and image profile will be skipped. To preserve installed VIBs, use profile update instead. WARNING: If your installation requires a reboot, you need to disable HA first.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER depot
Specifies full remote URLs of the depot index.xml or server file path pointing to an offline bundle .zip file.

.PARAMETER dryrun
Performs a dry-run only. Report the VIB-level operations that would be performed, but do not change anything in the system.

.PARAMETER force
Bypasses checks for package dependencies, conflicts, obsolescence, and acceptance levels. Really not recommended unless you know what you are doing. Use of this option will result in a warning being displayed in the vSphere Client.  Use this option only when instructed to do so by VMware Technical Support.

.PARAMETER maintenancemode
Pretends that maintenance mode is in effect. Otherwise, installation will stop for live installs that require maintenance mode. This flag has no effect for reboot required remediations.

.PARAMETER noliveinstall
Forces an install to /altbootbank even if the VIBs are eligible for live installation or removal. Will cause installation to be skipped on PXE-booted hosts.

.PARAMETER nosigcheck
Bypasses acceptance level verification, including signing. Use of this option poses a large security risk and will result in a SECURITY ALERT warning being displayed in the vSphere Client.

.PARAMETER oktoremove
Allows the removal of installed VIBs as part of applying the image profile. If not specified, esxcli will error out if applying the image profile results in the removal of installed VIBs.

.PARAMETER profile2
Specifies the name of the image profile to install.

.PARAMETER proxy
Specifies a proxy server to use for HTTP, FTP, and HTTPS connections. The format is proxy-url:port.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$dryrun,
	[boolean]$oktoremove,
	[Parameter(Mandatory=$true)]
	[string[]]$depot,
	[boolean]$nosigcheck,
	[boolean]$noliveinstall,
	[boolean]$maintenancemode,
	[boolean]$force,
	[string]$proxy,
	[Parameter(Mandatory=$true)]
	[string]$profile2,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.software.profile.install){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.software.profile.install is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.software.profile.install | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.software.profile.install.CreateArgs()
				if($PSBoundParameters.ContainsKey('dryrun')){
					if($HashTable.containskey('dryrun')){
						$HashTable.dryrun = $dryrun
					}
					Else{
						Write-error "The parameter dryrun is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('oktoremove')){
					if($HashTable.containskey('oktoremove')){
						$HashTable.oktoremove = $oktoremove
					}
					Else{
						Write-error "The parameter oktoremove is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('depot')){
					if($HashTable.containskey('depot')){
						$HashTable.depot = $depot
					}
					Else{
						Write-error "The parameter depot is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('nosigcheck')){
					if($HashTable.containskey('nosigcheck')){
						$HashTable.nosigcheck = $nosigcheck
					}
					Else{
						Write-error "The parameter nosigcheck is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('noliveinstall')){
					if($HashTable.containskey('noliveinstall')){
						$HashTable.noliveinstall = $noliveinstall
					}
					Else{
						Write-error "The parameter noliveinstall is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('maintenancemode')){
					if($HashTable.containskey('maintenancemode')){
						$HashTable.maintenancemode = $maintenancemode
					}
					Else{
						Write-error "The parameter maintenancemode is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('force')){
					if($HashTable.containskey('force')){
						$HashTable.force = $force
					}
					Else{
						Write-error "The parameter force is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('proxy')){
					if($HashTable.containskey('proxy')){
						$HashTable.proxy = $proxy
					}
					Else{
						Write-error "The parameter proxy is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('profile2')){
					if($HashTable.containskey('profile')){
						$HashTable.profile = $profile2
					}
					Else{
						Write-error "The parameter profile2 is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.software.profile.install.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('dryrun') -or $PSBoundParameters.ContainsKey('oktoremove') -or $PSBoundParameters.ContainsKey('depot') -or $PSBoundParameters.ContainsKey('nosigcheck') -or $PSBoundParameters.ContainsKey('noliveinstall') -or $PSBoundParameters.ContainsKey('maintenancemode') -or $PSBoundParameters.ContainsKey('force') -or $PSBoundParameters.ContainsKey('proxy') -or $PSBoundParameters.ContainsKey('profile2')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.software.profile.install.invoke()
				}
			}
		}
	}
}

function update-EsxCLI.software.profile{
<#
.SYNOPSIS
Updates the host with VIBs from an image profile in a depot. Installed VIBs may be upgraded (or downgraded if --allow-downgrades is specified), but they will not be removed. Any VIBs in the image profile which are not related to any installed VIBs will be added to the host. WARNING: If your installation requires a reboot, you need to disable HA first.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER allowdowngrades
If this option is specified, then the VIBs from the image profile which update, downgrade, or are new to the host will be installed. If the option is not specified, then the VIBs which update or are new to the host will be installed.

.PARAMETER depot
Specifies full remote URLs of the depot index.xml or server file path pointing to an offline bundle .zip file.

.PARAMETER dryrun
Performs a dry-run only. Report the VIB-level operations that would be performed, but do not change anything in the system.

.PARAMETER force
Bypasses checks for package dependencies, conflicts, obsolescence, and acceptance levels. Really not recommended unless you know what you are doing. Use of this option will result in a warning being displayed in the vSphere Client.  Use this option only when instructed to do so by VMware Technical Support.

.PARAMETER maintenancemode
Pretends that maintenance mode is in effect. Otherwise, installation will stop for live installs that require maintenance mode. This flag has no effect for reboot required remediations.

.PARAMETER noliveinstall
Forces an install to /altbootbank even if the VIBs are eligible for live installation or removal. Will cause installation to be skipped on PXE-booted hosts.

.PARAMETER nosigcheck
Bypasses acceptance level verification, including signing. Use of this option poses a large security risk and will result in a SECURITY ALERT warning being displayed in the vSphere Client.

.PARAMETER profile2
Specifies the name of the image profile to update the host with.

.PARAMETER proxy
Specifies a proxy server to use for HTTP, FTP, and HTTPS connections. The format is proxy-url:port.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$dryrun,
	[boolean]$maintenancemode,
	[Parameter(Mandatory=$true)]
	[string[]]$depot,
	[boolean]$nosigcheck,
	[boolean]$noliveinstall,
	[boolean]$allowdowngrades,
	[boolean]$force,
	[string]$proxy,
	[Parameter(Mandatory=$true)]
	[string]$profile2,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.software.profile.update){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.software.profile.update is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.software.profile.update | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.software.profile.update.CreateArgs()
				if($PSBoundParameters.ContainsKey('dryrun')){
					if($HashTable.containskey('dryrun')){
						$HashTable.dryrun = $dryrun
					}
					Else{
						Write-error "The parameter dryrun is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('maintenancemode')){
					if($HashTable.containskey('maintenancemode')){
						$HashTable.maintenancemode = $maintenancemode
					}
					Else{
						Write-error "The parameter maintenancemode is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('depot')){
					if($HashTable.containskey('depot')){
						$HashTable.depot = $depot
					}
					Else{
						Write-error "The parameter depot is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('nosigcheck')){
					if($HashTable.containskey('nosigcheck')){
						$HashTable.nosigcheck = $nosigcheck
					}
					Else{
						Write-error "The parameter nosigcheck is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('noliveinstall')){
					if($HashTable.containskey('noliveinstall')){
						$HashTable.noliveinstall = $noliveinstall
					}
					Else{
						Write-error "The parameter noliveinstall is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('allowdowngrades')){
					if($HashTable.containskey('allowdowngrades')){
						$HashTable.allowdowngrades = $allowdowngrades
					}
					Else{
						Write-error "The parameter allowdowngrades is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('force')){
					if($HashTable.containskey('force')){
						$HashTable.force = $force
					}
					Else{
						Write-error "The parameter force is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('proxy')){
					if($HashTable.containskey('proxy')){
						$HashTable.proxy = $proxy
					}
					Else{
						Write-error "The parameter proxy is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('profile2')){
					if($HashTable.containskey('profile')){
						$HashTable.profile = $profile2
					}
					Else{
						Write-error "The parameter profile2 is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.software.profile.update.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('dryrun') -or $PSBoundParameters.ContainsKey('maintenancemode') -or $PSBoundParameters.ContainsKey('depot') -or $PSBoundParameters.ContainsKey('nosigcheck') -or $PSBoundParameters.ContainsKey('noliveinstall') -or $PSBoundParameters.ContainsKey('allowdowngrades') -or $PSBoundParameters.ContainsKey('force') -or $PSBoundParameters.ContainsKey('proxy') -or $PSBoundParameters.ContainsKey('profile2')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.software.profile.update.invoke()
				}
			}
		}
	}
}

function validate-EsxCLI.software.profile{
<#
.SYNOPSIS
Validates the current image profile on the host against an image profile in a depot.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER depot
Specifies full remote URLs of the depot index.xml or server file path pointing to an offline bundle .zip file.

.PARAMETER profile2
Specifies the name of the image profile to validate the host with.

.PARAMETER proxy
Specifies a proxy server to use for HTTP, FTP, and HTTPS connections. The format is proxy-url:port.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string[]]$depot,
	[Parameter(Mandatory=$true)]
	[string]$profile2,
	[string]$proxy,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.software.profile.validate){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.software.profile.validate is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.software.profile.validate | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.software.profile.validate.CreateArgs()
				if($PSBoundParameters.ContainsKey('depot')){
					if($HashTable.containskey('depot')){
						$HashTable.depot = $depot
					}
					Else{
						Write-error "The parameter depot is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('profile2')){
					if($HashTable.containskey('profile')){
						$HashTable.profile = $profile2
					}
					Else{
						Write-error "The parameter profile2 is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('proxy')){
					if($HashTable.containskey('proxy')){
						$HashTable.proxy = $proxy
					}
					Else{
						Write-error "The parameter proxy is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.software.profile.validate.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('depot') -or $PSBoundParameters.ContainsKey('profile2') -or $PSBoundParameters.ContainsKey('proxy')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.software.profile.validate.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.software.sources.profile{
<#
.SYNOPSIS
Display details about an image profile from the depot.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER depot
Specifies full remote URLs of the depot index.xml or server file path pointing to an offline bundle .zip file.

.PARAMETER profile2
Specifies the name of the image profile to display.

.PARAMETER proxy
Specifies a proxy server to use for HTTP, FTP, and HTTPS connections. The format is proxy-url:port.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string[]]$depot,
	[Parameter(Mandatory=$true)]
	[string]$profile2,
	[string]$proxy,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.software.sources.profile.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.software.sources.profile.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.software.sources.profile.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.software.sources.profile.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('depot')){
					if($HashTable.containskey('depot')){
						$HashTable.depot = $depot
					}
					Else{
						Write-error "The parameter depot is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('profile2')){
					if($HashTable.containskey('profile')){
						$HashTable.profile = $profile2
					}
					Else{
						Write-error "The parameter profile2 is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('proxy')){
					if($HashTable.containskey('proxy')){
						$HashTable.proxy = $proxy
					}
					Else{
						Write-error "The parameter proxy is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.software.sources.profile.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('depot') -or $PSBoundParameters.ContainsKey('profile2') -or $PSBoundParameters.ContainsKey('proxy')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.software.sources.profile.get.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.software.sources.profile{
<#
.SYNOPSIS
List all the image profiles in a depot.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER depot
Specifies full remote URLs of the depot index.xml or server file path pointing to an offline bundle .zip file.

.PARAMETER proxy
Specifies a proxy server to use for HTTP, FTP, and HTTPS connections. The format is proxy-url:port.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$proxy,
	[Parameter(Mandatory=$true)]
	[string[]]$depot,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.software.sources.profile.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.software.sources.profile.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.software.sources.profile.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.software.sources.profile.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('proxy')){
					if($HashTable.containskey('proxy')){
						$HashTable.proxy = $proxy
					}
					Else{
						Write-error "The parameter proxy is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('depot')){
					if($HashTable.containskey('depot')){
						$HashTable.depot = $depot
					}
					Else{
						Write-error "The parameter depot is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.software.sources.profile.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('proxy') -or $PSBoundParameters.ContainsKey('depot')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.software.sources.profile.list.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.software.sources.vib{
<#
.SYNOPSIS
Displays detailed information about one or more VIB packages in the depot

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER depot
Specifies full remote URLs of the depot index.xml or server file path pointing to an offline bundle .zip file.

.PARAMETER proxy
Specifies a proxy server to use for HTTP, FTP, and HTTPS connections. The format is proxy-url:port.

.PARAMETER vibname
Specifies one or more VIBs in the depot to display more information about. If this option is not specified, then all of the VIB packages from the depot will be displayed. Must be one of the following forms: name, name:version, vendor:name, or vendor:name:version.

.PARAMETER viburl
Specifies one or more URLs to VIB packages to display information about. http:, https:, ftp:, and file: are all supported.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string[]]$depot,
	[string]$proxy,
	[string[]]$vibname,
	[string[]]$viburl,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.software.sources.vib.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.software.sources.vib.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.software.sources.vib.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.software.sources.vib.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('depot')){
					if($HashTable.containskey('depot')){
						$HashTable.depot = $depot
					}
					Else{
						Write-error "The parameter depot is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('proxy')){
					if($HashTable.containskey('proxy')){
						$HashTable.proxy = $proxy
					}
					Else{
						Write-error "The parameter proxy is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vibname')){
					if($HashTable.containskey('vibname')){
						$HashTable.vibname = $vibname
					}
					Else{
						Write-error "The parameter vibname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('viburl')){
					if($HashTable.containskey('viburl')){
						$HashTable.viburl = $viburl
					}
					Else{
						Write-error "The parameter viburl is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.software.sources.vib.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('depot') -or $PSBoundParameters.ContainsKey('proxy') -or $PSBoundParameters.ContainsKey('vibname') -or $PSBoundParameters.ContainsKey('viburl')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.software.sources.vib.get.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.software.sources.vib{
<#
.SYNOPSIS
List all the VIBs from depots.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER depot
Specifies full remote URLs of the depot index.xml or server file path pointing to an offline bundle .zip file.

.PARAMETER proxy
Specifies a proxy server to use for HTTP, FTP, and HTTPS connections. The format is proxy-url:port.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$proxy,
	[Parameter(Mandatory=$true)]
	[string[]]$depot,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.software.sources.vib.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.software.sources.vib.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.software.sources.vib.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.software.sources.vib.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('proxy')){
					if($HashTable.containskey('proxy')){
						$HashTable.proxy = $proxy
					}
					Else{
						Write-error "The parameter proxy is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('depot')){
					if($HashTable.containskey('depot')){
						$HashTable.depot = $depot
					}
					Else{
						Write-error "The parameter depot is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.software.sources.vib.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('proxy') -or $PSBoundParameters.ContainsKey('depot')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.software.sources.vib.list.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.software.vib{
<#
.SYNOPSIS
Displays detailed information about one or more installed VIBs

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER rebootingimage
Displays information for the ESXi image which becomes active after a reboot, or nothing if the pending-reboot image has not been created yet. If not specified, information from the current ESXi image in memory will be returned.

.PARAMETER vibname
Specifies one or more installed VIBs to display more information about. If this option is not specified, then all of the installed VIBs will be displayed. Must be one of the following forms: name, name:version, vendor:name, or vendor:name:version.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$rebootingimage,
	[string[]]$vibname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.software.vib.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.software.vib.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.software.vib.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.software.vib.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('rebootingimage')){
					if($HashTable.containskey('rebootingimage')){
						$HashTable.rebootingimage = $rebootingimage
					}
					Else{
						Write-error "The parameter rebootingimage is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vibname')){
					if($HashTable.containskey('vibname')){
						$HashTable.vibname = $vibname
					}
					Else{
						Write-error "The parameter vibname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.software.vib.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('rebootingimage') -or $PSBoundParameters.ContainsKey('vibname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.software.vib.get.invoke()
				}
			}
		}
	}
}

function install-EsxCLI.software.vib{
<#
.SYNOPSIS
Installs VIB packages from a URL or depot. VIBs may be installed, upgraded, or downgraded. WARNING: If your installation requires a reboot, you need to disable HA first.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER depot
Specifies full remote URLs of the depot index.xml or server file path pointing to an offline bundle .zip file.

.PARAMETER dryrun
Performs a dry-run only. Report the VIB-level operations that would be performed, but do not change anything in the system.

.PARAMETER force
Bypasses checks for package dependencies, conflicts, obsolescence, and acceptance levels. Really not recommended unless you know what you are doing. Use of this option will result in a warning being displayed in the vSphere Client.  Use this option only when instructed to do so by VMware Technical Support.

.PARAMETER maintenancemode
Pretends that maintenance mode is in effect. Otherwise, installation will stop for live installs that require maintenance mode. This flag has no effect for reboot required remediations.

.PARAMETER noliveinstall
Forces an install to /altbootbank even if the VIBs are eligible for live installation or removal. Will cause installation to be skipped on PXE-booted hosts.

.PARAMETER nosigcheck
Bypasses acceptance level verification, including signing. Use of this option poses a large security risk and will result in a SECURITY ALERT warning being displayed in the vSphere Client.

.PARAMETER proxy
Specifies a proxy server to use for HTTP, FTP, and HTTPS connections. The format is proxy-url:port.

.PARAMETER vibname
Specifies VIBs from a depot, using one of the following forms: name, name:version, vendor:name, or vendor:name:version.

.PARAMETER viburl
Specifies one or more URLs to VIB packages to install. http:, https:, ftp:, and file: are all supported.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string[]]$viburl,
	[boolean]$dryrun,
	[string[]]$depot,
	[boolean]$nosigcheck,
	[boolean]$noliveinstall,
	[string[]]$vibname,
	[boolean]$maintenancemode,
	[boolean]$force,
	[string]$proxy,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.software.vib.install){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.software.vib.install is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.software.vib.install | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.software.vib.install.CreateArgs()
				if($PSBoundParameters.ContainsKey('viburl')){
					if($HashTable.containskey('viburl')){
						$HashTable.viburl = $viburl
					}
					Else{
						Write-error "The parameter viburl is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('dryrun')){
					if($HashTable.containskey('dryrun')){
						$HashTable.dryrun = $dryrun
					}
					Else{
						Write-error "The parameter dryrun is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('depot')){
					if($HashTable.containskey('depot')){
						$HashTable.depot = $depot
					}
					Else{
						Write-error "The parameter depot is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('nosigcheck')){
					if($HashTable.containskey('nosigcheck')){
						$HashTable.nosigcheck = $nosigcheck
					}
					Else{
						Write-error "The parameter nosigcheck is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('noliveinstall')){
					if($HashTable.containskey('noliveinstall')){
						$HashTable.noliveinstall = $noliveinstall
					}
					Else{
						Write-error "The parameter noliveinstall is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vibname')){
					if($HashTable.containskey('vibname')){
						$HashTable.vibname = $vibname
					}
					Else{
						Write-error "The parameter vibname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('maintenancemode')){
					if($HashTable.containskey('maintenancemode')){
						$HashTable.maintenancemode = $maintenancemode
					}
					Else{
						Write-error "The parameter maintenancemode is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('force')){
					if($HashTable.containskey('force')){
						$HashTable.force = $force
					}
					Else{
						Write-error "The parameter force is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('proxy')){
					if($HashTable.containskey('proxy')){
						$HashTable.proxy = $proxy
					}
					Else{
						Write-error "The parameter proxy is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.software.vib.install.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('viburl') -or $PSBoundParameters.ContainsKey('dryrun') -or $PSBoundParameters.ContainsKey('depot') -or $PSBoundParameters.ContainsKey('nosigcheck') -or $PSBoundParameters.ContainsKey('noliveinstall') -or $PSBoundParameters.ContainsKey('vibname') -or $PSBoundParameters.ContainsKey('maintenancemode') -or $PSBoundParameters.ContainsKey('force') -or $PSBoundParameters.ContainsKey('proxy')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.software.vib.install.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.software.vib{
<#
.SYNOPSIS
Lists the installed VIB packages

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER rebootingimage
Displays information for the ESXi image which becomes active after a reboot, or nothing if the pending-reboot image has not been created yet. If not specified, information from the current ESXi image in memory will be returned.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$rebootingimage,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.software.vib.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.software.vib.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.software.vib.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.software.vib.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('rebootingimage')){
					if($HashTable.containskey('rebootingimage')){
						$HashTable.rebootingimage = $rebootingimage
					}
					Else{
						Write-error "The parameter rebootingimage is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.software.vib.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('rebootingimage')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.software.vib.list.invoke()
				}
			}
		}
	}
}

function remove-EsxCLI.software.vib{
<#
.SYNOPSIS
Removes VIB packages from the host. WARNING: If your installation requires a reboot, you need to disable HA first.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER dryrun
Performs a dry-run only. Report the VIB-level operations that would be performed, but do not change anything in the system.

.PARAMETER force
Bypasses checks for package dependencies, conflicts, obsolescence, and acceptance levels. Really not recommended unless you know what you are doing. Use of this option will result in a warning being displayed in the vSphere Client.  Use this option only when instructed to do so by VMware Technical Support.

.PARAMETER maintenancemode
Pretends that maintenance mode is in effect. Otherwise, remove will stop for live removes that require maintenance mode. This flag has no effect for reboot required remediations.

.PARAMETER noliveinstall
Forces an remove to /altbootbank even if the VIBs are eligible for live removal. Will cause installation to be skipped on PXE-booted hosts.

.PARAMETER vibname
Specifies one or more VIBs on the host to remove. Must be one of the following forms: name, name:version, vendor:name, vendor:name:version.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$dryrun,
	[boolean]$maintenancemode,
	[Parameter(Mandatory=$true)]
	[string[]]$vibname,
	[boolean]$noliveinstall,
	[boolean]$force,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.software.vib.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.software.vib.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.software.vib.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.software.vib.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('dryrun')){
					if($HashTable.containskey('dryrun')){
						$HashTable.dryrun = $dryrun
					}
					Else{
						Write-error "The parameter dryrun is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('maintenancemode')){
					if($HashTable.containskey('maintenancemode')){
						$HashTable.maintenancemode = $maintenancemode
					}
					Else{
						Write-error "The parameter maintenancemode is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vibname')){
					if($HashTable.containskey('vibname')){
						$HashTable.vibname = $vibname
					}
					Else{
						Write-error "The parameter vibname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('noliveinstall')){
					if($HashTable.containskey('noliveinstall')){
						$HashTable.noliveinstall = $noliveinstall
					}
					Else{
						Write-error "The parameter noliveinstall is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('force')){
					if($HashTable.containskey('force')){
						$HashTable.force = $force
					}
					Else{
						Write-error "The parameter force is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.software.vib.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('dryrun') -or $PSBoundParameters.ContainsKey('maintenancemode') -or $PSBoundParameters.ContainsKey('vibname') -or $PSBoundParameters.ContainsKey('noliveinstall') -or $PSBoundParameters.ContainsKey('force')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.software.vib.remove.invoke()
				}
			}
		}
	}
}

function update-EsxCLI.software.vib{
<#
.SYNOPSIS
Update installed VIBs to newer VIB packages. No new VIBs will be installed, only updates. WARNING: If your installation requires a reboot, you need to disable HA first.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER depot
Specifies full remote URLs of the depot index.xml or server file path pointing to an offline bundle .zip file.

.PARAMETER dryrun
Performs a dry-run only. Report the VIB-level operations that would be performed, but do not change anything in the system.

.PARAMETER force
Bypasses checks for package dependencies, conflicts, obsolescence, and acceptance levels. Really not recommended unless you know what you are doing.  Use of this option will result in a warning being displayed in the vSphere Client.  Use this option only when instructed to do so by VMware Technical Support.

.PARAMETER maintenancemode
Pretends that maintenance mode is in effect. Otherwise, installation will stop for live installs that require maintenance mode. This flag has no effect for reboot required remediations.

.PARAMETER noliveinstall
Forces an install to /altbootbank even if the VIBs are eligible for live installation or removal. Will cause installation to be skipped on PXE-booted hosts.

.PARAMETER nosigcheck
Bypasses acceptance level verification, including signing. Use of this option poses a large security risk and will result in a SECURITY ALERT warning being displayed in the vSphere Client.

.PARAMETER proxy
Specifies a proxy server to use for HTTP, FTP, and HTTPS connections. The format is proxy-url:port.

.PARAMETER vibname
Specifies VIBs from a depot, using one of the following forms: name, name:version, vendor:name, or vendor:name:version. VIB packages which are not updates will be skipped.

.PARAMETER viburl
Specifies one or more URLs to VIB packages to update to. http:, https:, ftp:, and file: are all supported. VIB packages which are not updates will be skipped.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string[]]$viburl,
	[boolean]$dryrun,
	[string[]]$depot,
	[boolean]$nosigcheck,
	[boolean]$noliveinstall,
	[string[]]$vibname,
	[boolean]$maintenancemode,
	[boolean]$force,
	[string]$proxy,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.software.vib.update){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.software.vib.update is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.software.vib.update | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.software.vib.update.CreateArgs()
				if($PSBoundParameters.ContainsKey('viburl')){
					if($HashTable.containskey('viburl')){
						$HashTable.viburl = $viburl
					}
					Else{
						Write-error "The parameter viburl is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('dryrun')){
					if($HashTable.containskey('dryrun')){
						$HashTable.dryrun = $dryrun
					}
					Else{
						Write-error "The parameter dryrun is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('depot')){
					if($HashTable.containskey('depot')){
						$HashTable.depot = $depot
					}
					Else{
						Write-error "The parameter depot is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('nosigcheck')){
					if($HashTable.containskey('nosigcheck')){
						$HashTable.nosigcheck = $nosigcheck
					}
					Else{
						Write-error "The parameter nosigcheck is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('noliveinstall')){
					if($HashTable.containskey('noliveinstall')){
						$HashTable.noliveinstall = $noliveinstall
					}
					Else{
						Write-error "The parameter noliveinstall is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vibname')){
					if($HashTable.containskey('vibname')){
						$HashTable.vibname = $vibname
					}
					Else{
						Write-error "The parameter vibname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('maintenancemode')){
					if($HashTable.containskey('maintenancemode')){
						$HashTable.maintenancemode = $maintenancemode
					}
					Else{
						Write-error "The parameter maintenancemode is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('force')){
					if($HashTable.containskey('force')){
						$HashTable.force = $force
					}
					Else{
						Write-error "The parameter force is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('proxy')){
					if($HashTable.containskey('proxy')){
						$HashTable.proxy = $proxy
					}
					Else{
						Write-error "The parameter proxy is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.software.vib.update.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('viburl') -or $PSBoundParameters.ContainsKey('dryrun') -or $PSBoundParameters.ContainsKey('depot') -or $PSBoundParameters.ContainsKey('nosigcheck') -or $PSBoundParameters.ContainsKey('noliveinstall') -or $PSBoundParameters.ContainsKey('vibname') -or $PSBoundParameters.ContainsKey('maintenancemode') -or $PSBoundParameters.ContainsKey('force') -or $PSBoundParameters.ContainsKey('proxy')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.software.vib.update.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.core.adapter{
<#
.SYNOPSIS
List all the SCSI Host Bus Adapters on the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.adapter.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.adapter.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.storage.core.adapter.list.invoke()
		}
	}
}

function rescan-EsxCLI.storage.core.adapter{
<#
.SYNOPSIS
Rescan SCSI HBAs to search for new Devices, remove DEAD paths and update path state. This operation will also run an claim operation equivalent to the claimrule run command and a filesystem rescan.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
Select the adapter to use when rescanning SCSI adapters. This must be a SCSI HBA name as shown in the adapter list command. This cannot be used with the --all option

.PARAMETER all
Indicate the rescan should rescan all adapters instead of a specific one.

.PARAMETER skipclaim
By default after an add operation a claiming session is run to find new devices and have them be claimed by the appropriate Multipath Plugin. Passing this flag will skip that claiming session.

.PARAMETER skipfsscan
This option is deprecated as no filesystem scan is performed by default

.PARAMETER type
Specify the type of rescan to perform. Available types are 
    add: Perform rescan and only add new devices if any.
    all: Perform rescan and do all opertaions (this is the default action.)
    delete: Perform rescan and only delete DEAD devices.
    update: Rescan existing paths only and update path states.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$all,
	[string]$adapter,
	[boolean]$skipfsscan,
	[string]$type,
	[boolean]$skipclaim,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.adapter.rescan){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.adapter.rescan is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.adapter.rescan | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.adapter.rescan.CreateArgs()
				if($PSBoundParameters.ContainsKey('all')){
					if($HashTable.containskey('all')){
						$HashTable.all = $all
					}
					Else{
						Write-error "The parameter all is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('skipfsscan')){
					if($HashTable.containskey('skipfsscan')){
						$HashTable.skipfsscan = $skipfsscan
					}
					Else{
						Write-error "The parameter skipfsscan is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('type')){
					if($HashTable.containskey('type')){
						$HashTable.type = $type
					}
					Else{
						Write-error "The parameter type is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('skipclaim')){
					if($HashTable.containskey('skipclaim')){
						$HashTable.skipclaim = $skipclaim
					}
					Else{
						Write-error "The parameter skipclaim is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.adapter.rescan.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('all') -or $PSBoundParameters.ContainsKey('adapter') -or $PSBoundParameters.ContainsKey('skipfsscan') -or $PSBoundParameters.ContainsKey('type') -or $PSBoundParameters.ContainsKey('skipclaim')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.adapter.rescan.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.storage.core.adapter.stats{
<#
.SYNOPSIS
List the SCSI stats for the SCSI Host Bus Adapters in the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
Limit the stats output to one adapter

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.adapter.stats.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.adapter.stats.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.adapter.stats.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.adapter.stats.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.adapter.stats.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.adapter.stats.get.invoke()
				}
			}
		}
	}
}

function autoclaim-EsxCLI.storage.core.claiming{
<#
.SYNOPSIS
Control the automatic PSA (path/device) claiming code allowing the disabling of the automatic claiming process or re-enabling of the claiming process if it was previously disabled. By default the automatic PSA claiming process is on and should not be disabled by users unless specifically instructed to do so.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER claimruleclass
Indicate the claim rule class to use in this operation [MP, Filter, VAAI, all].

.PARAMETER enabled
Set the autoclaiming enabled state for a givenPSA plugin type in the VMkernel. Default is to have this process enabled. This should not be changed by users unless specifically instructed to do so.

.PARAMETER wait
If the --wait flag is provided then the autoclaim enable will wait for paths to 'settle' before running the claim operation.  This means that the system is reasonably sure that all paths on the system have appeared before enabling autoclaim.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[boolean]$enabled,
	[boolean]$wait,
	[string]$claimruleclass,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.claiming.autoclaim){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.claiming.autoclaim is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.claiming.autoclaim | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.claiming.autoclaim.CreateArgs()
				if($PSBoundParameters.ContainsKey('enabled')){
					if($HashTable.containskey('enabled')){
						$HashTable.enabled = $enabled
					}
					Else{
						Write-error "The parameter enabled is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('wait')){
					if($HashTable.containskey('wait')){
						$HashTable.wait = $wait
					}
					Else{
						Write-error "The parameter wait is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('claimruleclass')){
					if($HashTable.containskey('claimruleclass')){
						$HashTable.claimruleclass = $claimruleclass
					}
					Else{
						Write-error "The parameter claimruleclass is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.claiming.autoclaim.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('enabled') -or $PSBoundParameters.ContainsKey('wait') -or $PSBoundParameters.ContainsKey('claimruleclass')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.claiming.autoclaim.invoke()
				}
			}
		}
	}
}

function reclaim-EsxCLI.storage.core.claiming{
<#
.SYNOPSIS
Attempt to unclaim all paths to a device and then run the loaded claimrules on each of the paths unclaimed to attempt to reclaim them.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER device
Reclaim requires the name of a device on which all paths will be unclaimed and then reclaimed.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$device,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.claiming.reclaim){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.claiming.reclaim is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.claiming.reclaim | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.claiming.reclaim.CreateArgs()
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.claiming.reclaim.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('device')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.claiming.reclaim.invoke()
				}
			}
		}
	}
}

function unclaim-EsxCLI.storage.core.claiming{
<#
.SYNOPSIS
1) Unclaim a path or set of paths, disassociating them from a PSA plugin. NOTES:  It is normal for path claiming to fail especially when unclaiming by plugin or adapter. Only inactive paths with no I/O  will be able to be unclaimed. Typically the ESXi USB partition and devices with VMFS volumes on them will not be unclaimable. Also NOTE unclaiming will not persist and periodic path claiming will reclaim these paths in the near future unless claim rules are configured to mask the path. 2) Detach a (set of) filter(s) from one or more devices.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
If the --type paramter is 'location' this value indicates the name of the host bus adapter for the paths you wish to unclaim. This parameter can be omitted to indicate unclaiming should be run on paths from all adapters.

.PARAMETER channel
If the --type parameter is 'location' this value indicates the value of the SCSI channel number for the paths you wish to unclaim. This parameter can be omitted to indicate unclaiming should be run on paths with any channel number.

.PARAMETER claimruleclass
Indicate the claim rule class to use in this operation [MP, Filter].

.PARAMETER device
If the --type parameter is 'device' attempt to unclaim all paths to a specific device (for multipathing plugins) or unclaim the device itself (for filter plugins). NOTE. For paths, if there are any active I/O operations on this device, at least 1 path will fail to unclaim.

.PARAMETER driver
If the --type parameter is 'driver' attempt to unclaim all paths provided by a specific HBA driver.

.PARAMETER lun
If the --type paramter is 'location' this value indicates the value of the SCSI Logical Unit Number (LUN) for the paths you wish to unclaim. This parameter can be omitted to indicate unclaiming should be run on paths with any Logical Unit Number.

.PARAMETER model
If the --type parameter is 'vendor' attempt to unclaim all paths to devices with specific model info (for multipathing plugins) or unclaim the device itself (for filter plugins). NOTE. For paths, if there are any active I/O operations on this device, at least 1 path will fail to unclaim.

.PARAMETER path
If the --type parameter is 'path' attempt to unclaim a specific path given its path UID or runtime name.

.PARAMETER plugin
If the --type parameter is 'plugin' attempt to unclaim all paths on for a given multipath plugin OR all devices attached to a filter plugin.

.PARAMETER target
If the --type paramter is 'location' this value indicates the value of the SCSI target number for the paths you wish to unclaim. This parameter can be omitted to indicate unclaiming should be run on paths with any target number.

.PARAMETER type
Indicate the type of unclaim you wish to perform. Valid values for this paramter are  [location, path, driver, device, plugin, vendor]

.PARAMETER vendor
If the --type parameter is 'vendor' attempt to unclaim all paths to devices with specific vendor info (for multipathing plugins) or unclaim the device itself (for filter plugins). NOTE. For paths, if there are any active I/O operations on this device, at least 1 path will fail to unclaim.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$driver,
	[string]$model,
	[string]$path,
	[long]$target,
	[long]$lun,
	[string]$claimruleclass,
	[Parameter(Mandatory=$true)]
	[string]$type,
	[string]$device,
	[string]$vendor,
	[string]$plugin,
	[long]$channel,
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.claiming.unclaim){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.claiming.unclaim is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.claiming.unclaim | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.claiming.unclaim.CreateArgs()
				if($PSBoundParameters.ContainsKey('driver')){
					if($HashTable.containskey('driver')){
						$HashTable.driver = $driver
					}
					Else{
						Write-error "The parameter driver is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('model')){
					if($HashTable.containskey('model')){
						$HashTable.model = $model
					}
					Else{
						Write-error "The parameter model is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('path')){
					if($HashTable.containskey('path')){
						$HashTable.path = $path
					}
					Else{
						Write-error "The parameter path is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('target')){
					if($HashTable.containskey('target')){
						$HashTable.target = $target
					}
					Else{
						Write-error "The parameter target is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('lun')){
					if($HashTable.containskey('lun')){
						$HashTable.lun = $lun
					}
					Else{
						Write-error "The parameter lun is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('claimruleclass')){
					if($HashTable.containskey('claimruleclass')){
						$HashTable.claimruleclass = $claimruleclass
					}
					Else{
						Write-error "The parameter claimruleclass is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('type')){
					if($HashTable.containskey('type')){
						$HashTable.type = $type
					}
					Else{
						Write-error "The parameter type is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vendor')){
					if($HashTable.containskey('vendor')){
						$HashTable.vendor = $vendor
					}
					Else{
						Write-error "The parameter vendor is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('plugin')){
					if($HashTable.containskey('plugin')){
						$HashTable.plugin = $plugin
					}
					Else{
						Write-error "The parameter plugin is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('channel')){
					if($HashTable.containskey('channel')){
						$HashTable.channel = $channel
					}
					Else{
						Write-error "The parameter channel is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.claiming.unclaim.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('driver') -or $PSBoundParameters.ContainsKey('model') -or $PSBoundParameters.ContainsKey('path') -or $PSBoundParameters.ContainsKey('target') -or $PSBoundParameters.ContainsKey('lun') -or $PSBoundParameters.ContainsKey('claimruleclass') -or $PSBoundParameters.ContainsKey('type') -or $PSBoundParameters.ContainsKey('device') -or $PSBoundParameters.ContainsKey('vendor') -or $PSBoundParameters.ContainsKey('plugin') -or $PSBoundParameters.ContainsKey('channel') -or $PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.claiming.unclaim.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.storage.core.claimrule{
<#
.SYNOPSIS
Add a claimrule to the set of claimrules on the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
Indicate the adapter of the paths to use in this operation.

.PARAMETER autoassign
The system will auto assign a rule id.

.PARAMETER channel
Indicate the channel of the paths to use in this operation.

.PARAMETER claimruleclass
Indicate the claim rule class to use in this operation [MP, Filter, VAAI].

.PARAMETER device
Indicate the Device Uid to use for this operation.

.PARAMETER driver
Indicate the driver of the paths to use in this operation.

.PARAMETER force
Force claim rules to ignore validity checks and install the rule anyway.

.PARAMETER ifunset
Execute this command if this advanced user variable is not set to 1

.PARAMETER iqn
Indicate the iSCSI Qualified Name for the target to use in this operation.

.PARAMETER lun
Indicate the LUN of the paths to use in this operation.

.PARAMETER model
Indicate the model of the paths to use in this operation.

.PARAMETER plugin
Indicate which PSA plugin to use for this operation.

.PARAMETER rule
Indicate the rule ID to use for this operation.

.PARAMETER target
Indicate the target of the paths to use in this operation.

.PARAMETER transport
Indicate the transport of the paths to use in this operation.  Valid Values are:  [block, fc, iscsi, iscsivendor, ide, sas, sata, usb, parallel, unknown]

.PARAMETER type
Indicate which type of matching used for claim/unclaim or claimrule. Valid values are:  [vendor, location, driver, transport, device, target]

.PARAMETER vendor
Indicate the vendor of the paths to user in this operation.

.PARAMETER wwnn
Indicate the World-Wide Node Number for the target to use in this operation.

.PARAMETER wwpn
Indicate the World-Wide Port Number for the target to use in this operation.

.PARAMETER xcopymaxtransfersize
Maximum transfer size in MB to use for XCOPY commands if admin wants to use a transfer size different than array reported. This option only takes effect when --xcopy-use-array-values is specified.

.PARAMETER xcopyusearrayvalues
Use array reported values for XCOPY commands.

.PARAMETER xcopyusemultisegs
Use multiple segments for XCOPY commandsThis option only takes effect when --xcopy-use-array-values is specified.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$xcopyusemultisegs,
	[long]$lun,
	[string]$claimruleclass,
	[long]$target,
	[boolean]$xcopyusearrayvalues,
	[string]$wwpn,
	[string]$vendor,
	[long]$rule,
	[Parameter(Mandatory=$true)]
	[string]$type,
	[boolean]$force,
	[string]$ifunset,
	[Parameter(Mandatory=$true)]
	[string]$plugin,
	[string]$wwnn,
	[long]$channel,
	[string]$device,
	[long]$xcopymaxtransfersize,
	[boolean]$autoassign,
	[string]$driver,
	[string]$iqn,
	[string]$adapter,
	[string]$model,
	[string]$transport,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.claimrule.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.claimrule.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.claimrule.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.claimrule.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('xcopyusemultisegs')){
					if($HashTable.containskey('xcopyusemultisegs')){
						$HashTable.xcopyusemultisegs = $xcopyusemultisegs
					}
					Else{
						Write-error "The parameter xcopyusemultisegs is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('lun')){
					if($HashTable.containskey('lun')){
						$HashTable.lun = $lun
					}
					Else{
						Write-error "The parameter lun is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('claimruleclass')){
					if($HashTable.containskey('claimruleclass')){
						$HashTable.claimruleclass = $claimruleclass
					}
					Else{
						Write-error "The parameter claimruleclass is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('target')){
					if($HashTable.containskey('target')){
						$HashTable.target = $target
					}
					Else{
						Write-error "The parameter target is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('xcopyusearrayvalues')){
					if($HashTable.containskey('xcopyusearrayvalues')){
						$HashTable.xcopyusearrayvalues = $xcopyusearrayvalues
					}
					Else{
						Write-error "The parameter xcopyusearrayvalues is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('wwpn')){
					if($HashTable.containskey('wwpn')){
						$HashTable.wwpn = $wwpn
					}
					Else{
						Write-error "The parameter wwpn is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vendor')){
					if($HashTable.containskey('vendor')){
						$HashTable.vendor = $vendor
					}
					Else{
						Write-error "The parameter vendor is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('rule')){
					if($HashTable.containskey('rule')){
						$HashTable.rule = $rule
					}
					Else{
						Write-error "The parameter rule is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('type')){
					if($HashTable.containskey('type')){
						$HashTable.type = $type
					}
					Else{
						Write-error "The parameter type is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('force')){
					if($HashTable.containskey('force')){
						$HashTable.force = $force
					}
					Else{
						Write-error "The parameter force is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ifunset')){
					if($HashTable.containskey('ifunset')){
						$HashTable.ifunset = $ifunset
					}
					Else{
						Write-error "The parameter ifunset is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('plugin')){
					if($HashTable.containskey('plugin')){
						$HashTable.plugin = $plugin
					}
					Else{
						Write-error "The parameter plugin is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('wwnn')){
					if($HashTable.containskey('wwnn')){
						$HashTable.wwnn = $wwnn
					}
					Else{
						Write-error "The parameter wwnn is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('channel')){
					if($HashTable.containskey('channel')){
						$HashTable.channel = $channel
					}
					Else{
						Write-error "The parameter channel is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('xcopymaxtransfersize')){
					if($HashTable.containskey('xcopymaxtransfersize')){
						$HashTable.xcopymaxtransfersize = $xcopymaxtransfersize
					}
					Else{
						Write-error "The parameter xcopymaxtransfersize is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('autoassign')){
					if($HashTable.containskey('autoassign')){
						$HashTable.autoassign = $autoassign
					}
					Else{
						Write-error "The parameter autoassign is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('driver')){
					if($HashTable.containskey('driver')){
						$HashTable.driver = $driver
					}
					Else{
						Write-error "The parameter driver is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('iqn')){
					if($HashTable.containskey('iqn')){
						$HashTable.iqn = $iqn
					}
					Else{
						Write-error "The parameter iqn is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('model')){
					if($HashTable.containskey('model')){
						$HashTable.model = $model
					}
					Else{
						Write-error "The parameter model is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('transport')){
					if($HashTable.containskey('transport')){
						$HashTable.transport = $transport
					}
					Else{
						Write-error "The parameter transport is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.claimrule.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('xcopyusemultisegs') -or $PSBoundParameters.ContainsKey('lun') -or $PSBoundParameters.ContainsKey('claimruleclass') -or $PSBoundParameters.ContainsKey('target') -or $PSBoundParameters.ContainsKey('xcopyusearrayvalues') -or $PSBoundParameters.ContainsKey('wwpn') -or $PSBoundParameters.ContainsKey('vendor') -or $PSBoundParameters.ContainsKey('rule') -or $PSBoundParameters.ContainsKey('type') -or $PSBoundParameters.ContainsKey('force') -or $PSBoundParameters.ContainsKey('ifunset') -or $PSBoundParameters.ContainsKey('plugin') -or $PSBoundParameters.ContainsKey('wwnn') -or $PSBoundParameters.ContainsKey('channel') -or $PSBoundParameters.ContainsKey('device') -or $PSBoundParameters.ContainsKey('xcopymaxtransfersize') -or $PSBoundParameters.ContainsKey('autoassign') -or $PSBoundParameters.ContainsKey('driver') -or $PSBoundParameters.ContainsKey('iqn') -or $PSBoundParameters.ContainsKey('adapter') -or $PSBoundParameters.ContainsKey('model') -or $PSBoundParameters.ContainsKey('transport')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.claimrule.add.invoke()
				}
			}
		}
	}
}

function convert-EsxCLI.storage.core.claimrule{
<#
.SYNOPSIS
Convert ESX 3.x style /adv/Disk/MaskLUNs LUN masks to Claim Rule format.
WARNING: This conversion will not work for all input MaskLUNs variations! Please inspect the list of generated claim rules carefuly, then if the suggested LUN mask claim rules are correct use the --commit parameter to write the list to the config file.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER commit
Force LUN mask config changes to be saved. If this parameter is omitted, config file changes will not be saved.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$commit,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.claimrule.convert){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.claimrule.convert is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.claimrule.convert | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.claimrule.convert.CreateArgs()
				if($PSBoundParameters.ContainsKey('commit')){
					if($HashTable.containskey('commit')){
						$HashTable.commit = $commit
					}
					Else{
						Write-error "The parameter commit is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.claimrule.convert.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('commit')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.claimrule.convert.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.core.claimrule{
<#
.SYNOPSIS
List all the claimrules on the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER claimruleclass
Indicate the claim rule class to use in this operation [MP, Filter, VAAI, all].

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$claimruleclass,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.claimrule.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.claimrule.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.claimrule.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.claimrule.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('claimruleclass')){
					if($HashTable.containskey('claimruleclass')){
						$HashTable.claimruleclass = $claimruleclass
					}
					Else{
						Write-error "The parameter claimruleclass is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.claimrule.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('claimruleclass')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.claimrule.list.invoke()
				}
			}
		}
	}
}

function load-EsxCLI.storage.core.claimrule{
<#
.SYNOPSIS
Load path claiming rules from config file into the VMkernel.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER claimruleclass
Indicate the claim rule class to use in this operation [MP, Filter, VAAI, all].

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$claimruleclass,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.claimrule.load){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.claimrule.load is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.claimrule.load | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.claimrule.load.CreateArgs()
				if($PSBoundParameters.ContainsKey('claimruleclass')){
					if($HashTable.containskey('claimruleclass')){
						$HashTable.claimruleclass = $claimruleclass
					}
					Else{
						Write-error "The parameter claimruleclass is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.claimrule.load.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('claimruleclass')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.claimrule.load.invoke()
				}
			}
		}
	}
}

function move-EsxCLI.storage.core.claimrule{
<#
.SYNOPSIS
Move a claimrule from one rule id to another

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER claimruleclass
Indicate the claim rule class to use in this operation [MP, Filter, VAAI].

.PARAMETER newrule
Indicate the new rule id you wish to apply to the rule given by the --rule parameter.

.PARAMETER rule
Indicate the rule ID to use for this operation.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[long]$rule,
	[Parameter(Mandatory=$true)]
	[long]$newrule,
	[string]$claimruleclass,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.claimrule.move){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.claimrule.move is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.claimrule.move | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.claimrule.move.CreateArgs()
				if($PSBoundParameters.ContainsKey('rule')){
					if($HashTable.containskey('rule')){
						$HashTable.rule = $rule
					}
					Else{
						Write-error "The parameter rule is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('newrule')){
					if($HashTable.containskey('newrule')){
						$HashTable.newrule = $newrule
					}
					Else{
						Write-error "The parameter newrule is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('claimruleclass')){
					if($HashTable.containskey('claimruleclass')){
						$HashTable.claimruleclass = $claimruleclass
					}
					Else{
						Write-error "The parameter claimruleclass is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.claimrule.move.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('rule') -or $PSBoundParameters.ContainsKey('newrule') -or $PSBoundParameters.ContainsKey('claimruleclass')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.claimrule.move.invoke()
				}
			}
		}
	}
}

function remove-EsxCLI.storage.core.claimrule{
<#
.SYNOPSIS
Delete a claimrule to the set of claimrules on the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER claimruleclass
Indicate the claim rule class to use in this operation [MP, Filter, VAAI].

.PARAMETER plugin
Indicate the plugin to use for this operation.

.PARAMETER rule
Indicate the rule ID to use for this operation.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[long]$rule,
	[string]$plugin,
	[string]$claimruleclass,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.claimrule.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.claimrule.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.claimrule.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.claimrule.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('rule')){
					if($HashTable.containskey('rule')){
						$HashTable.rule = $rule
					}
					Else{
						Write-error "The parameter rule is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('plugin')){
					if($HashTable.containskey('plugin')){
						$HashTable.plugin = $plugin
					}
					Else{
						Write-error "The parameter plugin is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('claimruleclass')){
					if($HashTable.containskey('claimruleclass')){
						$HashTable.claimruleclass = $claimruleclass
					}
					Else{
						Write-error "The parameter claimruleclass is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.claimrule.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('rule') -or $PSBoundParameters.ContainsKey('plugin') -or $PSBoundParameters.ContainsKey('claimruleclass')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.claimrule.remove.invoke()
				}
			}
		}
	}
}

function run-EsxCLI.storage.core.claimrule{
<#
.SYNOPSIS
Execute path claiming rules.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
If the --type parameter is 'location' this value indicates the name of the host bus adapter for the paths you wish to run claim rules on. This parameter can be omitted to indicate claim rules should be run on paths from all adapters.

.PARAMETER channel
If the --type parameter is 'location' this value indicates the value of the SCSI channel number for the paths you wish to run claim rules on. This parameter can be omitted to indicate claim rules should be run on paths with any channel number.

.PARAMETER claimruleclass
Indicate the claim rule class to use in this operation [MP, Filter].

.PARAMETER device
Indicate the Device Uid to use for this operation.

.PARAMETER lun
If the --type paramter is 'location' this value indicates the value of the SCSI Logical Unit Number (LUN) for the paths you wish to run claim rules on. This parameter can be omitted to indicate claim rules should be run on paths with any Logical Unit Number.

.PARAMETER path
If the --type paramter is 'path' this value indicates the unique path identifier (UID) or the runtime name of a path which you wish to run claim rules on.

.PARAMETER target
If the --type parameter is 'location' this value indicates the value of the SCSI target number for the paths you wish to run claim rules on. This parameter can be omitted to indicate claim rules should be run on paths with any target number.

.PARAMETER type
Indicate the type of claim run you wish to perform. By default the value of 'all' will be used indicating you wish to run claim rules without restricting the run to specific paths or SCSI addresses. Valid values for this parameter are  [location, path, device, all]

.PARAMETER wait
If the --wait flag is provided then the claim command will wait until device registration has completed to return. This option is only valid when used with the --all option.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$wait,
	[string]$path,
	[string]$type,
	[string]$claimruleclass,
	[string]$device,
	[long]$lun,
	[long]$target,
	[long]$channel,
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.claimrule.run){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.claimrule.run is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.claimrule.run | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.claimrule.run.CreateArgs()
				if($PSBoundParameters.ContainsKey('wait')){
					if($HashTable.containskey('wait')){
						$HashTable.wait = $wait
					}
					Else{
						Write-error "The parameter wait is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('path')){
					if($HashTable.containskey('path')){
						$HashTable.path = $path
					}
					Else{
						Write-error "The parameter path is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('type')){
					if($HashTable.containskey('type')){
						$HashTable.type = $type
					}
					Else{
						Write-error "The parameter type is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('claimruleclass')){
					if($HashTable.containskey('claimruleclass')){
						$HashTable.claimruleclass = $claimruleclass
					}
					Else{
						Write-error "The parameter claimruleclass is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('lun')){
					if($HashTable.containskey('lun')){
						$HashTable.lun = $lun
					}
					Else{
						Write-error "The parameter lun is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('target')){
					if($HashTable.containskey('target')){
						$HashTable.target = $target
					}
					Else{
						Write-error "The parameter target is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('channel')){
					if($HashTable.containskey('channel')){
						$HashTable.channel = $channel
					}
					Else{
						Write-error "The parameter channel is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.claimrule.run.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('wait') -or $PSBoundParameters.ContainsKey('path') -or $PSBoundParameters.ContainsKey('type') -or $PSBoundParameters.ContainsKey('claimruleclass') -or $PSBoundParameters.ContainsKey('device') -or $PSBoundParameters.ContainsKey('lun') -or $PSBoundParameters.ContainsKey('target') -or $PSBoundParameters.ContainsKey('channel') -or $PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.claimrule.run.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.core.device{
<#
.SYNOPSIS
List the devices currently registered with the PSA.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER device
Filter the output of this command to only show a single device.

.PARAMETER excludeoffline
If set this flag will exclude the offline devices

.PARAMETER peonly
If set this flag will list the mount points of pe type.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$device,
	[boolean]$excludeoffline,
	[boolean]$peonly,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.device.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.device.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.device.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.device.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('excludeoffline')){
					if($HashTable.containskey('excludeoffline')){
						$HashTable.excludeoffline = $excludeoffline
					}
					Else{
						Write-error "The parameter excludeoffline is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('peonly')){
					if($HashTable.containskey('peonly')){
						$HashTable.peonly = $peonly
					}
					Else{
						Write-error "The parameter peonly is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.device.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('device') -or $PSBoundParameters.ContainsKey('excludeoffline') -or $PSBoundParameters.ContainsKey('peonly')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.device.list.invoke()
				}
			}
		}
	}
}

function purge-EsxCLI.storage.core.device{
<#
.SYNOPSIS
Removes storage devices which have not been seen in some time interval.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER interval
Timeout interval (in days) for storage device removal. If a storage device has not been seen for the specified number of days, it will be removed. If not specified, the advanced setting '/Scsi/LunCleanupInterval' will be used (see esxcli system settings advanced list and esxcli system settings advanced set).

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[long]$interval,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.device.purge){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.device.purge is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.device.purge | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.device.purge.CreateArgs()
				if($PSBoundParameters.ContainsKey('interval')){
					if($HashTable.containskey('interval')){
						$HashTable.interval = $interval
					}
					Else{
						Write-error "The parameter interval is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.device.purge.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('interval')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.device.purge.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.storage.core.device{
<#
.SYNOPSIS
Provide control to allow a user to modify a SCSI device's state.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER dataintegrityenabled
Enable / Disable device data integrity 0 -> Protection disabled 1 -> Protection enabled.Please refer to ESX release notes for more Information

.PARAMETER defaultname
Set the default display name for the device. If there is an existing user defined name it will be changed.

.PARAMETER device
The device upon which to operate. This can be any of the UIDs that a device reports.

.PARAMETER force
Force the device state to be set.

.PARAMETER ledduration
Set the duration of LED in seconds. If not specified, use maximum duration that hardware can support.

.PARAMETER ledstate
Set the disk LED state. Valid values are: 
    error: Turn on error LED.
    locator: Turn on locator LED.
    off: Turn off LED.

.PARAMETER maxqueuedepth
Set device's max queue depth.

.PARAMETER name
The new name to assign the given device.

.PARAMETER nopersist
Set device state non-peristently; state is lost after reboot.

.PARAMETER queuefullsamplesize
Set device's queue full sample size. IO samples to monitor for detecting non-transient queue full condition. Should be non zero to enable queue depth throttling.

.PARAMETER queuefullthreshold
Set device's queue full threshold. BUSY or QFULL threshold,upon which LUN queue depth will be throttled. Should be <= queue-full-sample-size if throttling is enabled.

.PARAMETER schednumreqoutstanding
Set number of outstanding IOs with competing worlds.

.PARAMETER state
Set the SCSI device state for the specific device given. Valid values are : 
    off: Set the device's state to OFF.
    on: Set the device's state to ON.

.PARAMETER writecacheenabled
Set device's write cache state.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$ledstate,
	[boolean]$defaultname,
	[long]$maxqueuedepth,
	[boolean]$nopersist,
	[string]$state,
	[long]$queuefullsamplesize,
	[long]$ledduration,
	[long]$queuefullthreshold,
	[Parameter(Mandatory=$true)]
	[string]$device,
	[long]$schednumreqoutstanding,
	[boolean]$writecacheenabled,
	[boolean]$force,
	[boolean]$dataintegrityenabled,
	[string]$name,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.device.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.device.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.device.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.device.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('ledstate')){
					if($HashTable.containskey('ledstate')){
						$HashTable.ledstate = $ledstate
					}
					Else{
						Write-error "The parameter ledstate is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('defaultname')){
					if($HashTable.containskey('defaultname')){
						$HashTable.defaultname = $defaultname
					}
					Else{
						Write-error "The parameter defaultname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('maxqueuedepth')){
					if($HashTable.containskey('maxqueuedepth')){
						$HashTable.maxqueuedepth = $maxqueuedepth
					}
					Else{
						Write-error "The parameter maxqueuedepth is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('nopersist')){
					if($HashTable.containskey('nopersist')){
						$HashTable.nopersist = $nopersist
					}
					Else{
						Write-error "The parameter nopersist is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('state')){
					if($HashTable.containskey('state')){
						$HashTable.state = $state
					}
					Else{
						Write-error "The parameter state is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('queuefullsamplesize')){
					if($HashTable.containskey('queuefullsamplesize')){
						$HashTable.queuefullsamplesize = $queuefullsamplesize
					}
					Else{
						Write-error "The parameter queuefullsamplesize is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ledduration')){
					if($HashTable.containskey('ledduration')){
						$HashTable.ledduration = $ledduration
					}
					Else{
						Write-error "The parameter ledduration is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('queuefullthreshold')){
					if($HashTable.containskey('queuefullthreshold')){
						$HashTable.queuefullthreshold = $queuefullthreshold
					}
					Else{
						Write-error "The parameter queuefullthreshold is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('schednumreqoutstanding')){
					if($HashTable.containskey('schednumreqoutstanding')){
						$HashTable.schednumreqoutstanding = $schednumreqoutstanding
					}
					Else{
						Write-error "The parameter schednumreqoutstanding is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('writecacheenabled')){
					if($HashTable.containskey('writecacheenabled')){
						$HashTable.writecacheenabled = $writecacheenabled
					}
					Else{
						Write-error "The parameter writecacheenabled is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('force')){
					if($HashTable.containskey('force')){
						$HashTable.force = $force
					}
					Else{
						Write-error "The parameter force is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('dataintegrityenabled')){
					if($HashTable.containskey('dataintegrityenabled')){
						$HashTable.dataintegrityenabled = $dataintegrityenabled
					}
					Else{
						Write-error "The parameter dataintegrityenabled is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('name')){
					if($HashTable.containskey('name')){
						$HashTable.name = $name
					}
					Else{
						Write-error "The parameter name is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.device.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('ledstate') -or $PSBoundParameters.ContainsKey('defaultname') -or $PSBoundParameters.ContainsKey('maxqueuedepth') -or $PSBoundParameters.ContainsKey('nopersist') -or $PSBoundParameters.ContainsKey('state') -or $PSBoundParameters.ContainsKey('queuefullsamplesize') -or $PSBoundParameters.ContainsKey('ledduration') -or $PSBoundParameters.ContainsKey('queuefullthreshold') -or $PSBoundParameters.ContainsKey('device') -or $PSBoundParameters.ContainsKey('schednumreqoutstanding') -or $PSBoundParameters.ContainsKey('writecacheenabled') -or $PSBoundParameters.ContainsKey('force') -or $PSBoundParameters.ContainsKey('dataintegrityenabled') -or $PSBoundParameters.ContainsKey('name')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.device.set.invoke()
				}
			}
		}
	}
}

function setconfig-EsxCLI.storage.core.device{
<#
.SYNOPSIS
Set device configuration

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER detached
Mark device as detached.

.PARAMETER device
The device upon which to operate. This can be any of the UIDs that a device reports.

.PARAMETER perenniallyreserved
Mark device as perennially reserved.

.PARAMETER sharedclusterwide
Mark device as not shared clusterwide.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$sharedclusterwide,
	[Parameter(Mandatory=$true)]
	[string]$device,
	[boolean]$perenniallyreserved,
	[boolean]$detached,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.device.setconfig){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.device.setconfig is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.device.setconfig | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.device.setconfig.CreateArgs()
				if($PSBoundParameters.ContainsKey('sharedclusterwide')){
					if($HashTable.containskey('sharedclusterwide')){
						$HashTable.sharedclusterwide = $sharedclusterwide
					}
					Else{
						Write-error "The parameter sharedclusterwide is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('perenniallyreserved')){
					if($HashTable.containskey('perenniallyreserved')){
						$HashTable.perenniallyreserved = $perenniallyreserved
					}
					Else{
						Write-error "The parameter perenniallyreserved is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('detached')){
					if($HashTable.containskey('detached')){
						$HashTable.detached = $detached
					}
					Else{
						Write-error "The parameter detached is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.device.setconfig.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('sharedclusterwide') -or $PSBoundParameters.ContainsKey('device') -or $PSBoundParameters.ContainsKey('perenniallyreserved') -or $PSBoundParameters.ContainsKey('detached')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.device.setconfig.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.core.device.detached{
<#
.SYNOPSIS
Lists all devices that were detached manually by changing their state on the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER device
Filter the output of the command to limit the output to a specific device.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$device,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.device.detached.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.device.detached.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.device.detached.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.device.detached.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.device.detached.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('device')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.device.detached.list.invoke()
				}
			}
		}
	}
}

function remove-EsxCLI.storage.core.device.detached{
<#
.SYNOPSIS
Provide control to allow a user to remove Detached devices from the persistent detached device list.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER all
If set, all devices will be removed from the Detached Device List.

.PARAMETER device
Select the detached device to remove from the Detached Device List.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$device,
	[boolean]$all,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.device.detached.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.device.detached.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.device.detached.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.device.detached.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('all')){
					if($HashTable.containskey('all')){
						$HashTable.all = $all
					}
					Else{
						Write-error "The parameter all is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.device.detached.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('device') -or $PSBoundParameters.ContainsKey('all')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.device.detached.remove.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.core.device.partition{
<#
.SYNOPSIS
For a given device list all of the partitions

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER device
Filter the output to a specific device.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$device,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.device.partition.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.device.partition.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.device.partition.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.device.partition.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.device.partition.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('device')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.device.partition.list.invoke()
				}
			}
		}
	}
}

function showguid-EsxCLI.storage.core.device.partition{
<#
.SYNOPSIS
For a given device list the GUID for GPT partitions

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER device
Filter the output to a specific device.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$device,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.device.partition.showguid){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.device.partition.showguid is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.device.partition.showguid | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.device.partition.showguid.CreateArgs()
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.device.partition.showguid.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('device')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.device.partition.showguid.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.storage.core.device.physical{
<#
.SYNOPSIS
Get information about a physical storage device.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER device
Specify a device name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$device,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.device.physical.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.device.physical.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.device.physical.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.device.physical.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.device.physical.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('device')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.device.physical.get.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.core.device.raid{
<#
.SYNOPSIS
List the physical devices that compose a given logical device.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER device
Specify a device name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$device,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.device.raid.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.device.raid.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.device.raid.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.device.raid.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.device.raid.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('device')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.device.raid.list.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.storage.core.device.smart{
<#
.SYNOPSIS
List Smart device parameters.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER devicename
The Smart device name

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$devicename,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.device.smart.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.device.smart.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.device.smart.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.device.smart.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('devicename')){
					if($HashTable.containskey('devicename')){
						$HashTable.devicename = $devicename
					}
					Else{
						Write-error "The parameter devicename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.device.smart.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('devicename')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.device.smart.get.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.storage.core.device.stats{
<#
.SYNOPSIS
List the SCSI stats for SCSI Devices in the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER device
Limit the stats output to one specific device. This device name can be any of the UIDs the device reports

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$device,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.device.stats.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.device.stats.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.device.stats.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.device.stats.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.device.stats.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('device')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.device.stats.get.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.storage.core.device.vaai.status{
<#
.SYNOPSIS
List VAAI properties for devices currently registered with the PSA.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER device
Filter the output of this command to only show a single device.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$device,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.device.vaai.status.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.device.vaai.status.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.device.vaai.status.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.device.vaai.status.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.device.vaai.status.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('device')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.device.vaai.status.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.storage.core.device.vaai.status{
<#
.SYNOPSIS
Enable/Disable VAAI operations on local SCSI disks. (NOTE: A request to enable an operation will take effect only if the underlying device supports the VAAI operation.)

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER ats
Enable or Disable ATS operation (1/0)

.PARAMETER clone
Enable or Disable CLONE operation (1/0)

.PARAMETER delete
Enable or Disable DELETE operation (1/0)

.PARAMETER device
The device upon which to operate (NAA ID).

.PARAMETER zero
Enable or Disable ZERO operation (1/0)

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$zero,
	[boolean]$clone,
	[boolean]$ats,
	[Parameter(Mandatory=$true)]
	[string]$device,
	[boolean]$delete,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.device.vaai.status.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.device.vaai.status.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.device.vaai.status.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.device.vaai.status.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('zero')){
					if($HashTable.containskey('zero')){
						$HashTable.zero = $zero
					}
					Else{
						Write-error "The parameter zero is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('clone')){
					if($HashTable.containskey('clone')){
						$HashTable.clone = $clone
					}
					Else{
						Write-error "The parameter clone is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ats')){
					if($HashTable.containskey('ats')){
						$HashTable.ats = $ats
					}
					Else{
						Write-error "The parameter ats is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('delete')){
					if($HashTable.containskey('delete')){
						$HashTable.delete = $delete
					}
					Else{
						Write-error "The parameter delete is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.device.vaai.status.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('zero') -or $PSBoundParameters.ContainsKey('clone') -or $PSBoundParameters.ContainsKey('ats') -or $PSBoundParameters.ContainsKey('device') -or $PSBoundParameters.ContainsKey('delete')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.device.vaai.status.set.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.core.device.world{
<#
.SYNOPSIS
Get a list of the worlds that are currently using devices on the ESX host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER device
Filter the output of the command to limit the output to a specific device.  This device name can be any of the UIDs registered for a device.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$device,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.device.world.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.device.world.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.device.world.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.device.world.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.device.world.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('device')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.device.world.list.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.core.path{
<#
.SYNOPSIS
List all the SCSI paths on the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER device
Limit the output to paths to a specific device.   This name can be any of the UIDs for a specific device.

.PARAMETER path
Limit the output to a specific path. This  name can be either the UID or the runtime name of the path.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$device,
	[string]$path,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.path.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.path.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.path.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.path.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('path')){
					if($HashTable.containskey('path')){
						$HashTable.path = $path
					}
					Else{
						Write-error "The parameter path is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.path.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('device') -or $PSBoundParameters.ContainsKey('path')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.path.list.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.storage.core.path{
<#
.SYNOPSIS
Provide control to allow a user to modify a single path's state. This efffectively allows a user to enable or disable SCSI paths. The user is not able to change the full range of path states, but can toggle between 'active' and 'off'. Please NOTE changing the Path state on any path that is the only path to a given device is likely to fail. The VMkernel will not change the path's state if changing the state would cause an 'All paths down' state or the device is currently in use.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER path
Select the path to set path state on. This can be a Runtime Name or Path UID

.PARAMETER state
Set the SCSI path state for the specific path given. Valid values are : 
    active: Set the path's state to active. This may be immediately changed by the system to another state if the active state is not appropriate.
    off: Administratively disable this path.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$state,
	[Parameter(Mandatory=$true)]
	[string]$path,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.path.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.path.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.path.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.path.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('state')){
					if($HashTable.containskey('state')){
						$HashTable.state = $state
					}
					Else{
						Write-error "The parameter state is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('path')){
					if($HashTable.containskey('path')){
						$HashTable.path = $path
					}
					Else{
						Write-error "The parameter path is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.path.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('state') -or $PSBoundParameters.ContainsKey('path')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.path.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.storage.core.path.stats{
<#
.SYNOPSIS
List the SCSI stats for the SCSI Paths in the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER path
Limit the stats output to one specific path. This path name can be the runtime name or the path UID.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$path,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.path.stats.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.path.stats.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.path.stats.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.path.stats.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('path')){
					if($HashTable.containskey('path')){
						$HashTable.path = $path
					}
					Else{
						Write-error "The parameter path is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.path.stats.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('path')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.path.stats.get.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.core.plugin{
<#
.SYNOPSIS
List loaded PSA plugins on the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER pluginclass
Indicate the class of plugin to limit the list to.  Allowed values are :
    Filter: Filter plugins
    MP: MultiPathing plugins
    VAAI: VAAI plugins
    all: All PSA Plugins (default)

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$pluginclass,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.plugin.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.plugin.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.plugin.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.plugin.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('pluginclass')){
					if($HashTable.containskey('pluginclass')){
						$HashTable.pluginclass = $pluginclass
					}
					Else{
						Write-error "The parameter pluginclass is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.plugin.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('pluginclass')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.plugin.list.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.storage.core.plugin.registration{
<#
.SYNOPSIS
Register a plugin module with PSA.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER dependencies
Add the [optional] dependencies for this module to loaded

.PARAMETER fullpath
Add the [optional] full path to this module

.PARAMETER modulename
Select the module name to be registered

.PARAMETER pluginclass
Indicate the class of plugin to register.  Allowed values are MP, VAAI or MPP defined subplugins like PSP, SATP.

.PARAMETER pluginname
Select the plugin name to be registered

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$fullpath,
	[Parameter(Mandatory=$true)]
	[string]$modulename,
	[Parameter(Mandatory=$true)]
	[string]$pluginname,
	[string]$dependencies,
	[Parameter(Mandatory=$true)]
	[string]$pluginclass,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.plugin.registration.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.plugin.registration.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.plugin.registration.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.plugin.registration.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('fullpath')){
					if($HashTable.containskey('fullpath')){
						$HashTable.fullpath = $fullpath
					}
					Else{
						Write-error "The parameter fullpath is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('modulename')){
					if($HashTable.containskey('modulename')){
						$HashTable.modulename = $modulename
					}
					Else{
						Write-error "The parameter modulename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('pluginname')){
					if($HashTable.containskey('pluginname')){
						$HashTable.pluginname = $pluginname
					}
					Else{
						Write-error "The parameter pluginname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('dependencies')){
					if($HashTable.containskey('dependencies')){
						$HashTable.dependencies = $dependencies
					}
					Else{
						Write-error "The parameter dependencies is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('pluginclass')){
					if($HashTable.containskey('pluginclass')){
						$HashTable.pluginclass = $pluginclass
					}
					Else{
						Write-error "The parameter pluginclass is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.plugin.registration.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('fullpath') -or $PSBoundParameters.ContainsKey('modulename') -or $PSBoundParameters.ContainsKey('pluginname') -or $PSBoundParameters.ContainsKey('dependencies') -or $PSBoundParameters.ContainsKey('pluginclass')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.plugin.registration.add.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.core.plugin.registration{
<#
.SYNOPSIS
List modules currently registered with PSA.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER modulename
Filter the output of this command to only show a single module.

.PARAMETER pluginclass
Indicate the class of plugin to list.  Allowed values are MP, VAAI or MPP defined subplugins like PSP, SATP.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$modulename,
	[string]$pluginclass,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.plugin.registration.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.plugin.registration.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.plugin.registration.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.plugin.registration.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('modulename')){
					if($HashTable.containskey('modulename')){
						$HashTable.modulename = $modulename
					}
					Else{
						Write-error "The parameter modulename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('pluginclass')){
					if($HashTable.containskey('pluginclass')){
						$HashTable.pluginclass = $pluginclass
					}
					Else{
						Write-error "The parameter pluginclass is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.plugin.registration.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('modulename') -or $PSBoundParameters.ContainsKey('pluginclass')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.plugin.registration.list.invoke()
				}
			}
		}
	}
}

function remove-EsxCLI.storage.core.plugin.registration{
<#
.SYNOPSIS
UnRegister a plugin module with PSA.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER modulename
Select the module name to be unregistered

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$modulename,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.core.plugin.registration.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.core.plugin.registration.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.core.plugin.registration.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.core.plugin.registration.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('modulename')){
					if($HashTable.containskey('modulename')){
						$HashTable.modulename = $modulename
					}
					Else{
						Write-error "The parameter modulename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.core.plugin.registration.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('modulename')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.core.plugin.registration.remove.invoke()
				}
			}
		}
	}
}

function automount-EsxCLI.storage.filesystem{
<#
.SYNOPSIS
Request mounting of known datastores not explicitly unmounted.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.filesystem.automount){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.filesystem.automount is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.storage.filesystem.automount.invoke()
		}
	}
}

function list-EsxCLI.storage.filesystem{
<#
.SYNOPSIS
List the volumes available to the host. This includes VMFS, NAS, VFAT and UFS partitions.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER ignoreerrors
Ignore errors encountered (if any) while retrieving information for each file system.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$ignoreerrors,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.filesystem.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.filesystem.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.filesystem.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.filesystem.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('ignoreerrors')){
					if($HashTable.containskey('ignoreerrors')){
						$HashTable.ignoreerrors = $ignoreerrors
					}
					Else{
						Write-error "The parameter ignoreerrors is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.filesystem.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('ignoreerrors')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.filesystem.list.invoke()
				}
			}
		}
	}
}

function mount-EsxCLI.storage.filesystem{
<#
.SYNOPSIS
Connect to and mount an unmounted volume on the ESX host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER nopersist
Mount the volume non-peristently; the volume will not be mounted after a restart.

.PARAMETER volumelabel
The label of the volume to mount. This volume must be unmounted for this operation to succeed.

.PARAMETER volumeuuid
The UUID of the VMFS filesystem to mount. This volume must be unmounted for this operation to succeed.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$volumelabel,
	[boolean]$nopersist,
	[string]$volumeuuid,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.filesystem.mount){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.filesystem.mount is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.filesystem.mount | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.filesystem.mount.CreateArgs()
				if($PSBoundParameters.ContainsKey('volumelabel')){
					if($HashTable.containskey('volumelabel')){
						$HashTable.volumelabel = $volumelabel
					}
					Else{
						Write-error "The parameter volumelabel is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('nopersist')){
					if($HashTable.containskey('nopersist')){
						$HashTable.nopersist = $nopersist
					}
					Else{
						Write-error "The parameter nopersist is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('volumeuuid')){
					if($HashTable.containskey('volumeuuid')){
						$HashTable.volumeuuid = $volumeuuid
					}
					Else{
						Write-error "The parameter volumeuuid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.filesystem.mount.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('volumelabel') -or $PSBoundParameters.ContainsKey('nopersist') -or $PSBoundParameters.ContainsKey('volumeuuid')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.filesystem.mount.invoke()
				}
			}
		}
	}
}

function rescan-EsxCLI.storage.filesystem{
<#
.SYNOPSIS
Scan storage devices for new mountable filesystems.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.filesystem.rescan){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.filesystem.rescan is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.storage.filesystem.rescan.invoke()
		}
	}
}

function unmount-EsxCLI.storage.filesystem{
<#
.SYNOPSIS
Disconnect and unmount and existing VMFS or NAS volume. This will not delete the configuration for the volume, but will remove the volume from the list of mounted volumes.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER nopersist
Unmount the volume non-peristently; the volume will be automounted after a restart.

.PARAMETER volumelabel
The label of the volume to unmount.

.PARAMETER volumepath
The path of the volume to unmount.

.PARAMETER volumeuuid
The uuid of the volume to unmount.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$volumelabel,
	[boolean]$nopersist,
	[string]$volumeuuid,
	[string]$volumepath,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.filesystem.unmount){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.filesystem.unmount is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.filesystem.unmount | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.filesystem.unmount.CreateArgs()
				if($PSBoundParameters.ContainsKey('volumelabel')){
					if($HashTable.containskey('volumelabel')){
						$HashTable.volumelabel = $volumelabel
					}
					Else{
						Write-error "The parameter volumelabel is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('nopersist')){
					if($HashTable.containskey('nopersist')){
						$HashTable.nopersist = $nopersist
					}
					Else{
						Write-error "The parameter nopersist is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('volumeuuid')){
					if($HashTable.containskey('volumeuuid')){
						$HashTable.volumeuuid = $volumeuuid
					}
					Else{
						Write-error "The parameter volumeuuid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('volumepath')){
					if($HashTable.containskey('volumepath')){
						$HashTable.volumepath = $volumepath
					}
					Else{
						Write-error "The parameter volumepath is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.filesystem.unmount.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('volumelabel') -or $PSBoundParameters.ContainsKey('nopersist') -or $PSBoundParameters.ContainsKey('volumeuuid') -or $PSBoundParameters.ContainsKey('volumepath')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.filesystem.unmount.invoke()
				}
			}
		}
	}
}

function enable-EsxCLI.storage.iofilter{
<#
.SYNOPSIS
Enable an iofilter.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER filter
Name of the iofilter.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$filter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.iofilter.enable){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.iofilter.enable is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.iofilter.enable | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.iofilter.enable.CreateArgs()
				if($PSBoundParameters.ContainsKey('filter')){
					if($HashTable.containskey('filter')){
						$HashTable.filter = $filter
					}
					Else{
						Write-error "The parameter filter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.iofilter.enable.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('filter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.iofilter.enable.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.iofilter{
<#
.SYNOPSIS
List the iofilters installed on this host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER filter
Filter the output of this command to only show a single iofilter.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$filter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.iofilter.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.iofilter.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.iofilter.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.iofilter.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('filter')){
					if($HashTable.containskey('filter')){
						$HashTable.filter = $filter
					}
					Else{
						Write-error "The parameter filter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.iofilter.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('filter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.iofilter.list.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.storage.nfs{
<#
.SYNOPSIS
Add a new NAS volume to the ESX Host and mount it with the given volume name.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER host2
The hostname or IP address of the NAS volume to add and mount on the system.

.PARAMETER ispe
If set this flag will set the mount point to be PE.

.PARAMETER readonly
If set this flag will set the mount point to be read-only.

.PARAMETER share
The share name on the remote system to use for this NAS mount point.

.PARAMETER volumename
The volume name to use for the NAS mount.  This must be a unique volume name and cannot conflict with existing NAS, VMFS or other volume names.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$share,
	[boolean]$readonly,
	[Parameter(Mandatory=$true)]
	[string]$volumename,
	[boolean]$ispe,
	[Parameter(Mandatory=$true)]
	[string]$host2,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nfs.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nfs.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nfs.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nfs.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('share')){
					if($HashTable.containskey('share')){
						$HashTable.share = $share
					}
					Else{
						Write-error "The parameter share is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('readonly')){
					if($HashTable.containskey('readonly')){
						$HashTable.readonly = $readonly
					}
					Else{
						Write-error "The parameter readonly is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('volumename')){
					if($HashTable.containskey('volumename')){
						$HashTable.volumename = $volumename
					}
					Else{
						Write-error "The parameter volumename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ispe')){
					if($HashTable.containskey('ispe')){
						$HashTable.ispe = $ispe
					}
					Else{
						Write-error "The parameter ispe is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('host2')){
					if($HashTable.containskey('host')){
						$HashTable.host = $host2
					}
					Else{
						Write-error "The parameter host2 is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nfs.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('share') -or $PSBoundParameters.ContainsKey('readonly') -or $PSBoundParameters.ContainsKey('volumename') -or $PSBoundParameters.ContainsKey('ispe') -or $PSBoundParameters.ContainsKey('host2')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nfs.add.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.nfs{
<#
.SYNOPSIS
List the NAS volumes currently known to the ESX host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER peonly
Filter the output to only show VVol PE volumes

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$peonly,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nfs.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nfs.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nfs.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nfs.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('peonly')){
					if($HashTable.containskey('peonly')){
						$HashTable.peonly = $peonly
					}
					Else{
						Write-error "The parameter peonly is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nfs.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('peonly')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nfs.list.invoke()
				}
			}
		}
	}
}

function remove-EsxCLI.storage.nfs{
<#
.SYNOPSIS
Remove an existing NAS volume from the ESX host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER volumename
The volume name of the NAS volume to remove from the ESX host.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$volumename,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nfs.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nfs.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nfs.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nfs.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('volumename')){
					if($HashTable.containskey('volumename')){
						$HashTable.volumename = $volumename
					}
					Else{
						Write-error "The parameter volumename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nfs.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('volumename')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nfs.remove.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.storage.nfs.param{
<#
.SYNOPSIS
Get the volume parameters of the NAS volumes.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER volumename
NAS volume name("all" to list all).

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$volumename,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nfs.param.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nfs.param.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nfs.param.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nfs.param.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('volumename')){
					if($HashTable.containskey('volumename')){
						$HashTable.volumename = $volumename
					}
					Else{
						Write-error "The parameter volumename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nfs.param.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('volumename')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nfs.param.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.storage.nfs.param{
<#
.SYNOPSIS
Set the volume parameters of the NAS volumes.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER maxqueuedepth
The maximum queue depth for the NAS volume.

.PARAMETER volumename
The NAS volume name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[long]$maxqueuedepth,
	[Parameter(Mandatory=$true)]
	[string]$volumename,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nfs.param.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nfs.param.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nfs.param.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nfs.param.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('maxqueuedepth')){
					if($HashTable.containskey('maxqueuedepth')){
						$HashTable.maxqueuedepth = $maxqueuedepth
					}
					Else{
						Write-error "The parameter maxqueuedepth is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('volumename')){
					if($HashTable.containskey('volumename')){
						$HashTable.volumename = $volumename
					}
					Else{
						Write-error "The parameter volumename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nfs.param.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('maxqueuedepth') -or $PSBoundParameters.ContainsKey('volumename')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nfs.param.set.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.storage.nfs41{
<#
.SYNOPSIS
Add a new NFS v4.1 volume to the ESX Host and mount it with the given volume name.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER hosts
The hostname(s) or IP address(es) (comma-separated) of the server for the NFS v4.1 volume to add and mount on the system.

.PARAMETER readonly
If set, this flag will make the mount point be read-only.

.PARAMETER sec
Security flavors. Acceptable values are:  [AUTH_SYS, SEC_KRB5].

.PARAMETER share
The share name on the remote system to use for this NFS v4.1 mount point.

.PARAMETER volumename
The volume name to use for the NFS v4.1 mount.  This must be a unique volume name and cannot conflict with existing NAS, NFS v4.1, VMFS, or other volume names.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$share,
	[Parameter(Mandatory=$true)]
	[string[]]$hosts,
	[string]$sec,
	[Parameter(Mandatory=$true)]
	[string]$volumename,
	[boolean]$readonly,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nfs41.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nfs41.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nfs41.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nfs41.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('share')){
					if($HashTable.containskey('share')){
						$HashTable.share = $share
					}
					Else{
						Write-error "The parameter share is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('hosts')){
					if($HashTable.containskey('hosts')){
						$HashTable.hosts = $hosts
					}
					Else{
						Write-error "The parameter hosts is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('sec')){
					if($HashTable.containskey('sec')){
						$HashTable.sec = $sec
					}
					Else{
						Write-error "The parameter sec is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('volumename')){
					if($HashTable.containskey('volumename')){
						$HashTable.volumename = $volumename
					}
					Else{
						Write-error "The parameter volumename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('readonly')){
					if($HashTable.containskey('readonly')){
						$HashTable.readonly = $readonly
					}
					Else{
						Write-error "The parameter readonly is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nfs41.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('share') -or $PSBoundParameters.ContainsKey('hosts') -or $PSBoundParameters.ContainsKey('sec') -or $PSBoundParameters.ContainsKey('volumename') -or $PSBoundParameters.ContainsKey('readonly')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nfs41.add.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.nfs41{
<#
.SYNOPSIS
List the NFS v4.1 volumes currently known to the ESX host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER peonly
Filter the output to only show VVol PE Volumes

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$peonly,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nfs41.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nfs41.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nfs41.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nfs41.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('peonly')){
					if($HashTable.containskey('peonly')){
						$HashTable.peonly = $peonly
					}
					Else{
						Write-error "The parameter peonly is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nfs41.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('peonly')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nfs41.list.invoke()
				}
			}
		}
	}
}

function remove-EsxCLI.storage.nfs41{
<#
.SYNOPSIS
Remove an existing NFS v4.1 volume from the ESX host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER volumename
The volume name of the NFS v4.1 volume to remove from the ESX host.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$volumename,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nfs41.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nfs41.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nfs41.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nfs41.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('volumename')){
					if($HashTable.containskey('volumename')){
						$HashTable.volumename = $volumename
					}
					Else{
						Write-error "The parameter volumename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nfs41.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('volumename')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nfs41.remove.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.storage.nfs41.param{
<#
.SYNOPSIS
Get the volume parameters of the NFS v4.1 volumes.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER volumename
NFS v4.1 volume name("all" to list all).

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$volumename,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nfs41.param.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nfs41.param.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nfs41.param.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nfs41.param.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('volumename')){
					if($HashTable.containskey('volumename')){
						$HashTable.volumename = $volumename
					}
					Else{
						Write-error "The parameter volumename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nfs41.param.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('volumename')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nfs41.param.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.storage.nfs41.param{
<#
.SYNOPSIS
Set the volume parameters of the NFS v4.1 volumes.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER maxqueuedepth
The maximum queue depth for the NFS v4.1 volume.

.PARAMETER volumename
The NFS v4.1 volume name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[long]$maxqueuedepth,
	[Parameter(Mandatory=$true)]
	[string]$volumename,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nfs41.param.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nfs41.param.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nfs41.param.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nfs41.param.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('maxqueuedepth')){
					if($HashTable.containskey('maxqueuedepth')){
						$HashTable.maxqueuedepth = $maxqueuedepth
					}
					Else{
						Write-error "The parameter maxqueuedepth is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('volumename')){
					if($HashTable.containskey('volumename')){
						$HashTable.volumename = $volumename
					}
					Else{
						Write-error "The parameter volumename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nfs41.param.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('maxqueuedepth') -or $PSBoundParameters.ContainsKey('volumename')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nfs41.param.set.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.nmp.device{
<#
.SYNOPSIS
List the devices currently controlled by the VMware NMP Multipath Plugin and show the SATP and PSP information associated with that device.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER device
Filter the output of this command to only show a single device.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$device,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nmp.device.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nmp.device.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nmp.device.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nmp.device.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nmp.device.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('device')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nmp.device.list.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.storage.nmp.device{
<#
.SYNOPSIS
Allow setting of the Path Selection Policy (PSP) for the given device to one of the loaded policies on the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER default
The Path selection policy is set back to the default for the assigned SATP for this device.

.PARAMETER device
The device you wish to set the Path Selection Policy for.

.PARAMETER psp
The Path selection policy you wish to assign to the given device.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$default,
	[Parameter(Mandatory=$true)]
	[string]$device,
	[string]$psp,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nmp.device.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nmp.device.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nmp.device.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nmp.device.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('default')){
					if($HashTable.containskey('default')){
						$HashTable.default = $default
					}
					Else{
						Write-error "The parameter default is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('psp')){
					if($HashTable.containskey('psp')){
						$HashTable.psp = $psp
					}
					Else{
						Write-error "The parameter psp is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nmp.device.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('default') -or $PSBoundParameters.ContainsKey('device') -or $PSBoundParameters.ContainsKey('psp')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nmp.device.set.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.nmp.path{
<#
.SYNOPSIS
List the paths currently claimed by the VMware NMP Multipath Plugin and show the SATP and PSP information associated with that path.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER device
Filter the output of this command to only show paths to a single device.

.PARAMETER path
Filter the output of this command to only show a single path.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$device,
	[string]$path,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nmp.path.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nmp.path.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nmp.path.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nmp.path.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('path')){
					if($HashTable.containskey('path')){
						$HashTable.path = $path
					}
					Else{
						Write-error "The parameter path is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nmp.path.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('device') -or $PSBoundParameters.ContainsKey('path')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nmp.path.list.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.nmp.psp{
<#
.SYNOPSIS
List the Path Selection Plugins (PSP) that are currently loaded into the NMP system and display information about those PSPs

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nmp.psp.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nmp.psp.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.storage.nmp.psp.list.invoke()
		}
	}
}

function get-EsxCLI.storage.nmp.psp.fixed.deviceconfig{
<#
.SYNOPSIS
Allow retrieving of Fixed Path Selection Policy settings for a given device.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER device
The device you wish to get the Preferred path for.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$device,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nmp.psp.fixed.deviceconfig.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nmp.psp.fixed.deviceconfig.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nmp.psp.fixed.deviceconfig.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nmp.psp.fixed.deviceconfig.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nmp.psp.fixed.deviceconfig.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('device')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nmp.psp.fixed.deviceconfig.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.storage.nmp.psp.fixed.deviceconfig{
<#
.SYNOPSIS
Allow setting of the perferred path on a given device controlled by the Fixed Path Selection Policy.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER cfgfile
Update the config file and runtime with the new setting.  In case device is claimed by another PSP, ignore any errors when applying to runtime configuration.

.PARAMETER default
Clear the preferred path selection for the given device.

.PARAMETER device
The device you wish to set the preferred path for. This device must be controlled by the Fixed Path Selection Policy(except when -g is specified)

.PARAMETER path
The path you wish to set as the preferred path for the given device.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$default,
	[Parameter(Mandatory=$true)]
	[string]$device,
	[boolean]$cfgfile,
	[string]$path,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nmp.psp.fixed.deviceconfig.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nmp.psp.fixed.deviceconfig.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nmp.psp.fixed.deviceconfig.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nmp.psp.fixed.deviceconfig.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('default')){
					if($HashTable.containskey('default')){
						$HashTable.default = $default
					}
					Else{
						Write-error "The parameter default is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('cfgfile')){
					if($HashTable.containskey('cfgfile')){
						$HashTable.cfgfile = $cfgfile
					}
					Else{
						Write-error "The parameter cfgfile is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('path')){
					if($HashTable.containskey('path')){
						$HashTable.path = $path
					}
					Else{
						Write-error "The parameter path is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nmp.psp.fixed.deviceconfig.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('default') -or $PSBoundParameters.ContainsKey('device') -or $PSBoundParameters.ContainsKey('cfgfile') -or $PSBoundParameters.ContainsKey('path')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nmp.psp.fixed.deviceconfig.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.storage.nmp.psp.generic.deviceconfig{
<#
.SYNOPSIS
Allow retrieving of per device PSP configuration parameters.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER device
The device you wish to get PSP configuration for.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$device,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nmp.psp.generic.deviceconfig.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nmp.psp.generic.deviceconfig.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nmp.psp.generic.deviceconfig.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nmp.psp.generic.deviceconfig.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nmp.psp.generic.deviceconfig.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('device')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nmp.psp.generic.deviceconfig.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.storage.nmp.psp.generic.deviceconfig{
<#
.SYNOPSIS
Allow setting of per device PSP configuration parameters.  This command will set the configuration for the given device with whichever PSP it is currently configurated with.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER cfgfile
Update the config file and runtime with the new setting.  In case device is claimed by another PSP, ignore any errors when applying to runtime configuration.

.PARAMETER config
The configuration string you wish to set.

.PARAMETER device
The device you wish to set PSP configuration for.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$config,
	[Parameter(Mandatory=$true)]
	[string]$device,
	[boolean]$cfgfile,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nmp.psp.generic.deviceconfig.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nmp.psp.generic.deviceconfig.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nmp.psp.generic.deviceconfig.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nmp.psp.generic.deviceconfig.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('config')){
					if($HashTable.containskey('config')){
						$HashTable.config = $config
					}
					Else{
						Write-error "The parameter config is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('cfgfile')){
					if($HashTable.containskey('cfgfile')){
						$HashTable.cfgfile = $cfgfile
					}
					Else{
						Write-error "The parameter cfgfile is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nmp.psp.generic.deviceconfig.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('config') -or $PSBoundParameters.ContainsKey('device') -or $PSBoundParameters.ContainsKey('cfgfile')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nmp.psp.generic.deviceconfig.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.storage.nmp.psp.generic.pathconfig{
<#
.SYNOPSIS
Allow retrieving of per path PSP configuration parameters.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER path
The path you wish to get PSP configuration for.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$path,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nmp.psp.generic.pathconfig.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nmp.psp.generic.pathconfig.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nmp.psp.generic.pathconfig.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nmp.psp.generic.pathconfig.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('path')){
					if($HashTable.containskey('path')){
						$HashTable.path = $path
					}
					Else{
						Write-error "The parameter path is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nmp.psp.generic.pathconfig.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('path')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nmp.psp.generic.pathconfig.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.storage.nmp.psp.generic.pathconfig{
<#
.SYNOPSIS
Allow setting of per path PSP configuration parameters.  This command will set the configuration for the given path with whichever PSP it is currently configurated with.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER cfgfile
Update the config file and runtime with the new setting.  In case device is claimed by another PSP, ignore any errors when applying to runtime configuration.

.PARAMETER config
The configuration string you wish to set.

.PARAMETER path
The path you wish to set PSP configuration for.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$config,
	[boolean]$cfgfile,
	[Parameter(Mandatory=$true)]
	[string]$path,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nmp.psp.generic.pathconfig.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nmp.psp.generic.pathconfig.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nmp.psp.generic.pathconfig.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nmp.psp.generic.pathconfig.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('config')){
					if($HashTable.containskey('config')){
						$HashTable.config = $config
					}
					Else{
						Write-error "The parameter config is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('cfgfile')){
					if($HashTable.containskey('cfgfile')){
						$HashTable.cfgfile = $cfgfile
					}
					Else{
						Write-error "The parameter cfgfile is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('path')){
					if($HashTable.containskey('path')){
						$HashTable.path = $path
					}
					Else{
						Write-error "The parameter path is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nmp.psp.generic.pathconfig.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('config') -or $PSBoundParameters.ContainsKey('cfgfile') -or $PSBoundParameters.ContainsKey('path')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nmp.psp.generic.pathconfig.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.storage.nmp.psp.roundrobin.deviceconfig{
<#
.SYNOPSIS
Allow retrieving of Round Robin Path Selection Policy settings for a given device.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER device
The device you wish to get the Round Robin properties for.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$device,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nmp.psp.roundrobin.deviceconfig.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nmp.psp.roundrobin.deviceconfig.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nmp.psp.roundrobin.deviceconfig.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nmp.psp.roundrobin.deviceconfig.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nmp.psp.roundrobin.deviceconfig.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('device')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nmp.psp.roundrobin.deviceconfig.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.storage.nmp.psp.roundrobin.deviceconfig{
<#
.SYNOPSIS
Allow setting of the Round Robin path options on a given device controlled by the Round Robin Selection Policy.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER bytes
When the --type option is set to 'bytes' this is the  value that will be assigned to the byte limit value for this device.

.PARAMETER cfgfile
Update the config file and runtime with the new setting.  In case device is claimed by another PSP, ignore any errors when applying to runtime configuration.

.PARAMETER device
The device you wish to set the Round Robin settings for. This device must be controlled by the Round Robin Path Selection Policy(except when -g is specified)

.PARAMETER iops
When the --type option is set to 'iops' this is the  value that will be assigned to the I/O operation limit value for this device.

.PARAMETER type
Set the type of the Round Robin path switching that should be enabled for this device. Valid values for type are: 
    bytes: Set the trigger for path switching based on the number of bytes sent down a path.
    default: Set the trigger for path switching back to default values.
    iops: Set the trigger for path switching based on the number of I/O operations on a path.

.PARAMETER useano
Set useano to true,to also include non-optimizedpaths in the set of active paths used to issue I/Os on this device,otherwise set it to false

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[long]$iops,
	[boolean]$useano,
	[long]$bytes,
	[Parameter(Mandatory=$true)]
	[string]$device,
	[string]$type,
	[boolean]$cfgfile,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nmp.psp.roundrobin.deviceconfig.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nmp.psp.roundrobin.deviceconfig.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nmp.psp.roundrobin.deviceconfig.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nmp.psp.roundrobin.deviceconfig.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('iops')){
					if($HashTable.containskey('iops')){
						$HashTable.iops = $iops
					}
					Else{
						Write-error "The parameter iops is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('useano')){
					if($HashTable.containskey('useano')){
						$HashTable.useano = $useano
					}
					Else{
						Write-error "The parameter useano is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('bytes')){
					if($HashTable.containskey('bytes')){
						$HashTable.bytes = $bytes
					}
					Else{
						Write-error "The parameter bytes is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('type')){
					if($HashTable.containskey('type')){
						$HashTable.type = $type
					}
					Else{
						Write-error "The parameter type is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('cfgfile')){
					if($HashTable.containskey('cfgfile')){
						$HashTable.cfgfile = $cfgfile
					}
					Else{
						Write-error "The parameter cfgfile is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nmp.psp.roundrobin.deviceconfig.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('iops') -or $PSBoundParameters.ContainsKey('useano') -or $PSBoundParameters.ContainsKey('bytes') -or $PSBoundParameters.ContainsKey('device') -or $PSBoundParameters.ContainsKey('type') -or $PSBoundParameters.ContainsKey('cfgfile')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nmp.psp.roundrobin.deviceconfig.set.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.nmp.satp{
<#
.SYNOPSIS
List the Storage Array Type Plugins (SATP) that are currently loaded into the NMP system and display information about those SATPs

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nmp.satp.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nmp.satp.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.storage.nmp.satp.list.invoke()
		}
	}
}

function set-EsxCLI.storage.nmp.satp{
<#
.SYNOPSIS
Set the default Path Selection Policy for a given Storage Array Type Plugin (SATP).

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER boot
This is a system default rule added at boot time. Do not modify esx.conf or add to host profile.

.PARAMETER defaultpsp
The default path selection policy to set for a given --satp

.PARAMETER satp
The SATP name for the Storage Array Type Plugin on which this command will operate.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$defaultpsp,
	[boolean]$boot,
	[Parameter(Mandatory=$true)]
	[string]$satp,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nmp.satp.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nmp.satp.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nmp.satp.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nmp.satp.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('defaultpsp')){
					if($HashTable.containskey('defaultpsp')){
						$HashTable.defaultpsp = $defaultpsp
					}
					Else{
						Write-error "The parameter defaultpsp is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('boot')){
					if($HashTable.containskey('boot')){
						$HashTable.boot = $boot
					}
					Else{
						Write-error "The parameter boot is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('satp')){
					if($HashTable.containskey('satp')){
						$HashTable.satp = $satp
					}
					Else{
						Write-error "The parameter satp is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nmp.satp.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('defaultpsp') -or $PSBoundParameters.ContainsKey('boot') -or $PSBoundParameters.ContainsKey('satp')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nmp.satp.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.storage.nmp.satp.generic.deviceconfig{
<#
.SYNOPSIS
Allow retrieving of per device SATP configuration parameters.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER device
The device you wish to get SATP configuration for.

.PARAMETER excludetpginfo
Exclude TPG info from the device's SATP configuration.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$device,
	[boolean]$excludetpginfo,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nmp.satp.generic.deviceconfig.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nmp.satp.generic.deviceconfig.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nmp.satp.generic.deviceconfig.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nmp.satp.generic.deviceconfig.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('excludetpginfo')){
					if($HashTable.containskey('excludetpginfo')){
						$HashTable.excludetpginfo = $excludetpginfo
					}
					Else{
						Write-error "The parameter excludetpginfo is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nmp.satp.generic.deviceconfig.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('device') -or $PSBoundParameters.ContainsKey('excludetpginfo')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nmp.satp.generic.deviceconfig.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.storage.nmp.satp.generic.deviceconfig{
<#
.SYNOPSIS
Allow setting of per device SATP configuration parameters. This command will set the configuration for the given device with whichever SATP it is currently configurated with.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER config
The configuration string you wish to set.

.PARAMETER device
The device you wish to set SATP configuration for.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$config,
	[string]$device,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nmp.satp.generic.deviceconfig.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nmp.satp.generic.deviceconfig.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nmp.satp.generic.deviceconfig.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nmp.satp.generic.deviceconfig.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('config')){
					if($HashTable.containskey('config')){
						$HashTable.config = $config
					}
					Else{
						Write-error "The parameter config is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nmp.satp.generic.deviceconfig.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('config') -or $PSBoundParameters.ContainsKey('device')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nmp.satp.generic.deviceconfig.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.storage.nmp.satp.generic.pathconfig{
<#
.SYNOPSIS
Allow retrieving of per path SATP configuration parameters.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER path
The path you wish to get SATP configuration for.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$path,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nmp.satp.generic.pathconfig.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nmp.satp.generic.pathconfig.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nmp.satp.generic.pathconfig.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nmp.satp.generic.pathconfig.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('path')){
					if($HashTable.containskey('path')){
						$HashTable.path = $path
					}
					Else{
						Write-error "The parameter path is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nmp.satp.generic.pathconfig.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('path')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nmp.satp.generic.pathconfig.get.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.storage.nmp.satp.generic.pathconfig{
<#
.SYNOPSIS
Allow setting of per path SATP configuration parameters.  This command will set the configuration for the given path with whichever SATP it is currently configurated with.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER config
The configuration string you wish to set.

.PARAMETER path
The path you wish to set SATP configuration for.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$config,
	[Parameter(Mandatory=$true)]
	[string]$path,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nmp.satp.generic.pathconfig.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nmp.satp.generic.pathconfig.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nmp.satp.generic.pathconfig.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nmp.satp.generic.pathconfig.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('config')){
					if($HashTable.containskey('config')){
						$HashTable.config = $config
					}
					Else{
						Write-error "The parameter config is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('path')){
					if($HashTable.containskey('path')){
						$HashTable.path = $path
					}
					Else{
						Write-error "The parameter path is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nmp.satp.generic.pathconfig.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('config') -or $PSBoundParameters.ContainsKey('path')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nmp.satp.generic.pathconfig.set.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.storage.nmp.satp.rule{
<#
.SYNOPSIS
Add a rule to the list of claim rules for the given SATP.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER boot
This is a system default rule added at boot time. Do not modify esx.conf or add to host profile.

.PARAMETER claimoption
Set the claim option string when adding a SATP claim rule.

.PARAMETER description
Set the claim rule description when adding a SATP claim rule.

.PARAMETER device
Set the device when adding SATP claim rules. Device rules are mutually exclusive with vendor/model and driver rules.

.PARAMETER driver
Set the driver string when adding a SATP claim rule. Driver rules are mutually exclusive with vendor/model rules.

.PARAMETER force
Force claim rules to ignore validity checks and install the rule anyway.

.PARAMETER model
Set the model string when adding SATP a claim rule. Vendor/Model rules are mutually exclusive with driver rules.

.PARAMETER option
Set the option string when adding a SATP claim rule.

.PARAMETER psp
Set the default PSP for the SATP claim rule.

.PARAMETER pspoption
Set the PSP options for the SATP claim rule.

.PARAMETER satp
The SATP for which a new rule will be added.

.PARAMETER transport
Set the claim transport type string when adding a SATP claim rule.

.PARAMETER type
Set the claim type when adding a SATP claim rule.

.PARAMETER vendor
Set the vendor string when adding SATP claim rules. Vendor/Model rules are mutually exclusive with driver rules.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$pspoption,
	[string]$transport,
	[string]$description,
	[string]$vendor,
	[boolean]$boot,
	[string]$type,
	[Parameter(Mandatory=$true)]
	[string]$satp,
	[string]$device,
	[boolean]$force,
	[string]$driver,
	[string]$claimoption,
	[string]$psp,
	[string]$option,
	[string]$model,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nmp.satp.rule.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nmp.satp.rule.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nmp.satp.rule.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nmp.satp.rule.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('pspoption')){
					if($HashTable.containskey('pspoption')){
						$HashTable.pspoption = $pspoption
					}
					Else{
						Write-error "The parameter pspoption is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('transport')){
					if($HashTable.containskey('transport')){
						$HashTable.transport = $transport
					}
					Else{
						Write-error "The parameter transport is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('description')){
					if($HashTable.containskey('description')){
						$HashTable.description = $description
					}
					Else{
						Write-error "The parameter description is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vendor')){
					if($HashTable.containskey('vendor')){
						$HashTable.vendor = $vendor
					}
					Else{
						Write-error "The parameter vendor is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('boot')){
					if($HashTable.containskey('boot')){
						$HashTable.boot = $boot
					}
					Else{
						Write-error "The parameter boot is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('type')){
					if($HashTable.containskey('type')){
						$HashTable.type = $type
					}
					Else{
						Write-error "The parameter type is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('satp')){
					if($HashTable.containskey('satp')){
						$HashTable.satp = $satp
					}
					Else{
						Write-error "The parameter satp is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('force')){
					if($HashTable.containskey('force')){
						$HashTable.force = $force
					}
					Else{
						Write-error "The parameter force is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('driver')){
					if($HashTable.containskey('driver')){
						$HashTable.driver = $driver
					}
					Else{
						Write-error "The parameter driver is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('claimoption')){
					if($HashTable.containskey('claimoption')){
						$HashTable.claimoption = $claimoption
					}
					Else{
						Write-error "The parameter claimoption is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('psp')){
					if($HashTable.containskey('psp')){
						$HashTable.psp = $psp
					}
					Else{
						Write-error "The parameter psp is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('option')){
					if($HashTable.containskey('option')){
						$HashTable.option = $option
					}
					Else{
						Write-error "The parameter option is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('model')){
					if($HashTable.containskey('model')){
						$HashTable.model = $model
					}
					Else{
						Write-error "The parameter model is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nmp.satp.rule.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('pspoption') -or $PSBoundParameters.ContainsKey('transport') -or $PSBoundParameters.ContainsKey('description') -or $PSBoundParameters.ContainsKey('vendor') -or $PSBoundParameters.ContainsKey('boot') -or $PSBoundParameters.ContainsKey('type') -or $PSBoundParameters.ContainsKey('satp') -or $PSBoundParameters.ContainsKey('device') -or $PSBoundParameters.ContainsKey('force') -or $PSBoundParameters.ContainsKey('driver') -or $PSBoundParameters.ContainsKey('claimoption') -or $PSBoundParameters.ContainsKey('psp') -or $PSBoundParameters.ContainsKey('option') -or $PSBoundParameters.ContainsKey('model')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nmp.satp.rule.add.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.nmp.satp.rule{
<#
.SYNOPSIS
List the claiming rules for Storage Array Type Plugins (SATP)

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER satp
Filter the SATP rules to a specific SATP

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$satp,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nmp.satp.rule.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nmp.satp.rule.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nmp.satp.rule.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nmp.satp.rule.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('satp')){
					if($HashTable.containskey('satp')){
						$HashTable.satp = $satp
					}
					Else{
						Write-error "The parameter satp is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nmp.satp.rule.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('satp')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nmp.satp.rule.list.invoke()
				}
			}
		}
	}
}

function remove-EsxCLI.storage.nmp.satp.rule{
<#
.SYNOPSIS
Delete a rule from the list of claim rules for the given SATP.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER boot
This is a system default rule added at boot time. Do not modify esx.conf or add to host profile.

.PARAMETER claimoption
The claim option string for the SATP claim rule to delete.

.PARAMETER description
The desription string for the SATP claim rule to delete.

.PARAMETER device
The device for the SATP claim rule to delete

.PARAMETER driver
The driver string for the SATP claim rule to delete.

.PARAMETER model
The model string for the SATP claim rule to delete.

.PARAMETER option
The option string for the SATP claim rule to delete.

.PARAMETER psp
The default PSP for the SATP claim rule to delete.

.PARAMETER pspoption
The PSP options for the SATP claim rule to delete.

.PARAMETER satp
The SATP for which a rule will be deleted.

.PARAMETER transport
The transport type for the SATP claim rule to delete.

.PARAMETER type
Set the claim type when adding a SATP claim rule.

.PARAMETER vendor
The vendor string for the SATP claim rule to delete

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$pspoption,
	[string]$transport,
	[string]$description,
	[boolean]$boot,
	[string]$type,
	[Parameter(Mandatory=$true)]
	[string]$satp,
	[string]$device,
	[string]$vendor,
	[string]$driver,
	[string]$claimoption,
	[string]$psp,
	[string]$option,
	[string]$model,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.nmp.satp.rule.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.nmp.satp.rule.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.nmp.satp.rule.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.nmp.satp.rule.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('pspoption')){
					if($HashTable.containskey('pspoption')){
						$HashTable.pspoption = $pspoption
					}
					Else{
						Write-error "The parameter pspoption is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('transport')){
					if($HashTable.containskey('transport')){
						$HashTable.transport = $transport
					}
					Else{
						Write-error "The parameter transport is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('description')){
					if($HashTable.containskey('description')){
						$HashTable.description = $description
					}
					Else{
						Write-error "The parameter description is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('boot')){
					if($HashTable.containskey('boot')){
						$HashTable.boot = $boot
					}
					Else{
						Write-error "The parameter boot is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('type')){
					if($HashTable.containskey('type')){
						$HashTable.type = $type
					}
					Else{
						Write-error "The parameter type is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('satp')){
					if($HashTable.containskey('satp')){
						$HashTable.satp = $satp
					}
					Else{
						Write-error "The parameter satp is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vendor')){
					if($HashTable.containskey('vendor')){
						$HashTable.vendor = $vendor
					}
					Else{
						Write-error "The parameter vendor is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('driver')){
					if($HashTable.containskey('driver')){
						$HashTable.driver = $driver
					}
					Else{
						Write-error "The parameter driver is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('claimoption')){
					if($HashTable.containskey('claimoption')){
						$HashTable.claimoption = $claimoption
					}
					Else{
						Write-error "The parameter claimoption is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('psp')){
					if($HashTable.containskey('psp')){
						$HashTable.psp = $psp
					}
					Else{
						Write-error "The parameter psp is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('option')){
					if($HashTable.containskey('option')){
						$HashTable.option = $option
					}
					Else{
						Write-error "The parameter option is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('model')){
					if($HashTable.containskey('model')){
						$HashTable.model = $model
					}
					Else{
						Write-error "The parameter model is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.nmp.satp.rule.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('pspoption') -or $PSBoundParameters.ContainsKey('transport') -or $PSBoundParameters.ContainsKey('description') -or $PSBoundParameters.ContainsKey('boot') -or $PSBoundParameters.ContainsKey('type') -or $PSBoundParameters.ContainsKey('satp') -or $PSBoundParameters.ContainsKey('device') -or $PSBoundParameters.ContainsKey('vendor') -or $PSBoundParameters.ContainsKey('driver') -or $PSBoundParameters.ContainsKey('claimoption') -or $PSBoundParameters.ContainsKey('psp') -or $PSBoundParameters.ContainsKey('option') -or $PSBoundParameters.ContainsKey('model')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.nmp.satp.rule.remove.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.san.fc{
<#
.SYNOPSIS
List attributes of all FC adapters on the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
FC adapter name (vmhbaX), or none, to list all.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.san.fc.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.san.fc.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.san.fc.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.san.fc.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.san.fc.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.san.fc.list.invoke()
				}
			}
		}
	}
}

function reset-EsxCLI.storage.san.fc{
<#
.SYNOPSIS
Perform LIP (Loop Initiation Primitive) Reset to a given FC adapter on the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
Issue LIP Reset command to given Fibre Channel HBA.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.san.fc.reset){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.san.fc.reset is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.san.fc.reset | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.san.fc.reset.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.san.fc.reset.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.san.fc.reset.invoke()
				}
			}
		}
	}
}

function clear-EsxCLI.storage.san.fc.events{
<#
.SYNOPSIS
Clear events for a given FC adapter on the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
Issue Clear Event command to specified Fibre Channel HBA.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.san.fc.events.clear){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.san.fc.events.clear is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.san.fc.events.clear | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.san.fc.events.clear.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.san.fc.events.clear.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.san.fc.events.clear.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.storage.san.fc.events{
<#
.SYNOPSIS
Get Events for FC Devices

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
FC adapter name (vmhbaX), or none, to retrieve all.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.san.fc.events.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.san.fc.events.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.san.fc.events.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.san.fc.events.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.san.fc.events.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.san.fc.events.get.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.storage.san.fc.stats{
<#
.SYNOPSIS
Get statistics for a given FC adapter, or all FC adapters on the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
FC adapter name (vmhbaX), or none, to list all.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.san.fc.stats.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.san.fc.stats.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.san.fc.stats.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.san.fc.stats.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.san.fc.stats.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.san.fc.stats.get.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.san.fcoe{
<#
.SYNOPSIS
List attributes of all FCoE adapters on the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
FCoE adapter name (vmhbaX), or none, to list all.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.san.fcoe.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.san.fcoe.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.san.fcoe.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.san.fcoe.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.san.fcoe.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.san.fcoe.list.invoke()
				}
			}
		}
	}
}

function reset-EsxCLI.storage.san.fcoe{
<#
.SYNOPSIS
Perform LIP (Loop Initiation Primitive) Reset to a given FCoE adapter on the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
Issue LIP Reset command to given hba.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.san.fcoe.reset){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.san.fcoe.reset is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.san.fcoe.reset | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.san.fcoe.reset.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.san.fcoe.reset.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.san.fcoe.reset.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.storage.san.fcoe.stats{
<#
.SYNOPSIS
Get statistics for a given FCoE adapter, or all FCoE adapters on the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
FCoE adapter name (vmhbaX), or none, to list all.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.san.fcoe.stats.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.san.fcoe.stats.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.san.fcoe.stats.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.san.fcoe.stats.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.san.fcoe.stats.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.san.fcoe.stats.get.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.san.iscsi{
<#
.SYNOPSIS
List attributes of all Software iSCSI adapters on the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
iSCSI adapter name (vmhbaX), or none, to list all.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.san.iscsi.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.san.iscsi.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.san.iscsi.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.san.iscsi.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.san.iscsi.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.san.iscsi.list.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.storage.san.iscsi.stats{
<#
.SYNOPSIS
Get statistics for Software iSCSI adapter.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
iSCSI device name (vmhbaX), or none, to list all.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.san.iscsi.stats.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.san.iscsi.stats.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.san.iscsi.stats.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.san.iscsi.stats.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.san.iscsi.stats.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.san.iscsi.stats.get.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.san.sas{
<#
.SYNOPSIS
List all SAS IO Device Management devices.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
SAS adapter name (vmhbaX), or none, to list all.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.san.sas.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.san.sas.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.san.sas.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.san.sas.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.san.sas.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.san.sas.list.invoke()
				}
			}
		}
	}
}

function reset-EsxCLI.storage.san.sas{
<#
.SYNOPSIS
Perform SAS Reset

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
Issue Reset command to given hba.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.san.sas.reset){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.san.sas.reset is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.san.sas.reset | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.san.sas.reset.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.san.sas.reset.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.san.sas.reset.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.storage.san.sas.stats{
<#
.SYNOPSIS
List Stats for given device, or all devices.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER adapter
SAS adapter name (vmhbaX), or none, to list all.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$adapter,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.san.sas.stats.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.san.sas.stats.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.san.sas.stats.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.san.sas.stats.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('adapter')){
					if($HashTable.containskey('adapter')){
						$HashTable.adapter = $adapter
					}
					Else{
						Write-error "The parameter adapter is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.san.sas.stats.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('adapter')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.san.sas.stats.get.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.storage.vflash.cache{
<#
.SYNOPSIS
Get individual vflash cache info.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER cachename
The vflash cache name

.PARAMETER modulename
The vflash module name

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$modulename,
	[Parameter(Mandatory=$true)]
	[string]$cachename,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.vflash.cache.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.vflash.cache.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.vflash.cache.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.vflash.cache.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('modulename')){
					if($HashTable.containskey('modulename')){
						$HashTable.modulename = $modulename
					}
					Else{
						Write-error "The parameter modulename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('cachename')){
					if($HashTable.containskey('cachename')){
						$HashTable.cachename = $cachename
					}
					Else{
						Write-error "The parameter cachename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.vflash.cache.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('modulename') -or $PSBoundParameters.ContainsKey('cachename')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.vflash.cache.get.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.vflash.cache{
<#
.SYNOPSIS
List individual vflash caches.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER modulename
The vflash module name

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$modulename,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.vflash.cache.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.vflash.cache.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.vflash.cache.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.vflash.cache.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('modulename')){
					if($HashTable.containskey('modulename')){
						$HashTable.modulename = $modulename
					}
					Else{
						Write-error "The parameter modulename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.vflash.cache.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('modulename')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.vflash.cache.list.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.storage.vflash.cache.stats{
<#
.SYNOPSIS
Get vflash cache statistics.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER cachename
The vflash cache file name

.PARAMETER modulename
The vflash module name

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$modulename,
	[Parameter(Mandatory=$true)]
	[string]$cachename,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.vflash.cache.stats.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.vflash.cache.stats.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.vflash.cache.stats.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.vflash.cache.stats.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('modulename')){
					if($HashTable.containskey('modulename')){
						$HashTable.modulename = $modulename
					}
					Else{
						Write-error "The parameter modulename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('cachename')){
					if($HashTable.containskey('cachename')){
						$HashTable.cachename = $cachename
					}
					Else{
						Write-error "The parameter cachename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.vflash.cache.stats.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('modulename') -or $PSBoundParameters.ContainsKey('cachename')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.vflash.cache.stats.get.invoke()
				}
			}
		}
	}
}

function reset-EsxCLI.storage.vflash.cache.stats{
<#
.SYNOPSIS
Reset vflash cache statistics.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER cachename
The vflash cache file name

.PARAMETER modulename
The vflash module name

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$modulename,
	[Parameter(Mandatory=$true)]
	[string]$cachename,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.vflash.cache.stats.reset){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.vflash.cache.stats.reset is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.vflash.cache.stats.reset | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.vflash.cache.stats.reset.CreateArgs()
				if($PSBoundParameters.ContainsKey('modulename')){
					if($HashTable.containskey('modulename')){
						$HashTable.modulename = $modulename
					}
					Else{
						Write-error "The parameter modulename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('cachename')){
					if($HashTable.containskey('cachename')){
						$HashTable.cachename = $cachename
					}
					Else{
						Write-error "The parameter cachename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.vflash.cache.stats.reset.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('modulename') -or $PSBoundParameters.ContainsKey('cachename')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.vflash.cache.stats.reset.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.vflash.device{
<#
.SYNOPSIS
List vflash SSD devices.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER eligible
List the eligible / ineligible SSD devices for vflash.

.PARAMETER used
List the used / unused SSD devices for vflash.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$used,
	[boolean]$eligible,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.vflash.device.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.vflash.device.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.vflash.device.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.vflash.device.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('used')){
					if($HashTable.containskey('used')){
						$HashTable.used = $used
					}
					Else{
						Write-error "The parameter used is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('eligible')){
					if($HashTable.containskey('eligible')){
						$HashTable.eligible = $eligible
					}
					Else{
						Write-error "The parameter eligible is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.vflash.device.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('used') -or $PSBoundParameters.ContainsKey('eligible')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.vflash.device.list.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.storage.vflash.module{
<#
.SYNOPSIS
Get vflash module info.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER modulename
The vflash module name

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$modulename,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.vflash.module.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.vflash.module.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.vflash.module.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.vflash.module.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('modulename')){
					if($HashTable.containskey('modulename')){
						$HashTable.modulename = $modulename
					}
					Else{
						Write-error "The parameter modulename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.vflash.module.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('modulename')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.vflash.module.get.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.vflash.module{
<#
.SYNOPSIS
List vflash modules.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.vflash.module.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.vflash.module.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.storage.vflash.module.list.invoke()
		}
	}
}

function get-EsxCLI.storage.vflash.module.stats{
<#
.SYNOPSIS
Get vflash module statistics

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER modulename
The vflash module name

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$modulename,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.vflash.module.stats.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.vflash.module.stats.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.vflash.module.stats.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.vflash.module.stats.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('modulename')){
					if($HashTable.containskey('modulename')){
						$HashTable.modulename = $modulename
					}
					Else{
						Write-error "The parameter modulename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.vflash.module.stats.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('modulename')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.vflash.module.stats.get.invoke()
				}
			}
		}
	}
}

function unmap-EsxCLI.storage.vmfs{
<#
.SYNOPSIS
Reclaim the space by unmapping free blocks from VMFS Volume

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER reclaimunit
Number of VMFS blocks that should be unmapped per iteration.

.PARAMETER volumelabel
The label of the VMFS volume to unmap the free blocks.

.PARAMETER volumeuuid
The uuid of the VMFS volume to unmap the free blocks.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$volumelabel,
	[long]$reclaimunit,
	[string]$volumeuuid,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.vmfs.unmap){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.vmfs.unmap is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.vmfs.unmap | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.vmfs.unmap.CreateArgs()
				if($PSBoundParameters.ContainsKey('volumelabel')){
					if($HashTable.containskey('volumelabel')){
						$HashTable.volumelabel = $volumelabel
					}
					Else{
						Write-error "The parameter volumelabel is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('reclaimunit')){
					if($HashTable.containskey('reclaimunit')){
						$HashTable.reclaimunit = $reclaimunit
					}
					Else{
						Write-error "The parameter reclaimunit is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('volumeuuid')){
					if($HashTable.containskey('volumeuuid')){
						$HashTable.volumeuuid = $volumeuuid
					}
					Else{
						Write-error "The parameter volumeuuid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.vmfs.unmap.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('volumelabel') -or $PSBoundParameters.ContainsKey('reclaimunit') -or $PSBoundParameters.ContainsKey('volumeuuid')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.vmfs.unmap.invoke()
				}
			}
		}
	}
}

function upgrade-EsxCLI.storage.vmfs{
<#
.SYNOPSIS
Upgrade a VMFS3 volume to VMFS5.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER volumelabel
The label of the VMFS volume to upgrade.

.PARAMETER volumeuuid
The uuid of the VMFS volume to upgrade.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$volumelabel,
	[string]$volumeuuid,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.vmfs.upgrade){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.vmfs.upgrade is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.vmfs.upgrade | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.vmfs.upgrade.CreateArgs()
				if($PSBoundParameters.ContainsKey('volumelabel')){
					if($HashTable.containskey('volumelabel')){
						$HashTable.volumelabel = $volumelabel
					}
					Else{
						Write-error "The parameter volumelabel is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('volumeuuid')){
					if($HashTable.containskey('volumeuuid')){
						$HashTable.volumeuuid = $volumeuuid
					}
					Else{
						Write-error "The parameter volumeuuid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.vmfs.upgrade.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('volumelabel') -or $PSBoundParameters.ContainsKey('volumeuuid')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.vmfs.upgrade.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.vmfs.extent{
<#
.SYNOPSIS
List the VMFS extents available on the host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.vmfs.extent.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.vmfs.extent.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.storage.vmfs.extent.list.invoke()
		}
	}
}

function list-EsxCLI.storage.vmfs.host{
<#
.SYNOPSIS
List hosts accessing a particular VMFS Volume.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER liveness
The type of liveness check to perform on the VMFS volume. Valid values are  [none, quick] (default is none).

.PARAMETER volumelabel
The label of the target VMFS volume.

.PARAMETER volumeuuid
The uuid of the target VMFS volume.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$volumelabel,
	[string]$liveness,
	[string]$volumeuuid,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.vmfs.host.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.vmfs.host.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.vmfs.host.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.vmfs.host.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('volumelabel')){
					if($HashTable.containskey('volumelabel')){
						$HashTable.volumelabel = $volumelabel
					}
					Else{
						Write-error "The parameter volumelabel is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('liveness')){
					if($HashTable.containskey('liveness')){
						$HashTable.liveness = $liveness
					}
					Else{
						Write-error "The parameter liveness is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('volumeuuid')){
					if($HashTable.containskey('volumeuuid')){
						$HashTable.volumeuuid = $volumeuuid
					}
					Else{
						Write-error "The parameter volumeuuid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.vmfs.host.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('volumelabel') -or $PSBoundParameters.ContainsKey('liveness') -or $PSBoundParameters.ContainsKey('volumeuuid')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.vmfs.host.list.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.vmfs.lockmode{
<#
.SYNOPSIS
List the on-disk critical section locking mode for VMFS volumes available on this host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER ignoreerrors
Ignore errors encountered (if any) while retrieving information for each file system.

.PARAMETER volumelabel
The label of the target VMFS volume.

.PARAMETER volumeuuid
The uuid of the target VMFS volume.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string[]]$volumelabel,
	[string[]]$volumeuuid,
	[boolean]$ignoreerrors,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.vmfs.lockmode.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.vmfs.lockmode.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.vmfs.lockmode.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.vmfs.lockmode.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('volumelabel')){
					if($HashTable.containskey('volumelabel')){
						$HashTable.volumelabel = $volumelabel
					}
					Else{
						Write-error "The parameter volumelabel is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('volumeuuid')){
					if($HashTable.containskey('volumeuuid')){
						$HashTable.volumeuuid = $volumeuuid
					}
					Else{
						Write-error "The parameter volumeuuid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ignoreerrors')){
					if($HashTable.containskey('ignoreerrors')){
						$HashTable.ignoreerrors = $ignoreerrors
					}
					Else{
						Write-error "The parameter ignoreerrors is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.vmfs.lockmode.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('volumelabel') -or $PSBoundParameters.ContainsKey('volumeuuid') -or $PSBoundParameters.ContainsKey('ignoreerrors')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.vmfs.lockmode.list.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.storage.vmfs.lockmode{
<#
.SYNOPSIS
Update the on-disk critical section locking mode for a particular VMFS Volume.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER ats
Enable ATS-only locking.

.PARAMETER scsi
Enable SCSI locking.

.PARAMETER volumelabel
The label of the target VMFS volume.

.PARAMETER volumeuuid
The uuid of the target VMFS volume.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$scsi,
	[string]$volumelabel,
	[boolean]$ats,
	[string]$volumeuuid,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.vmfs.lockmode.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.vmfs.lockmode.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.vmfs.lockmode.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.vmfs.lockmode.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('scsi')){
					if($HashTable.containskey('scsi')){
						$HashTable.scsi = $scsi
					}
					Else{
						Write-error "The parameter scsi is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('volumelabel')){
					if($HashTable.containskey('volumelabel')){
						$HashTable.volumelabel = $volumelabel
					}
					Else{
						Write-error "The parameter volumelabel is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('ats')){
					if($HashTable.containskey('ats')){
						$HashTable.ats = $ats
					}
					Else{
						Write-error "The parameter ats is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('volumeuuid')){
					if($HashTable.containskey('volumeuuid')){
						$HashTable.volumeuuid = $volumeuuid
					}
					Else{
						Write-error "The parameter volumeuuid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.vmfs.lockmode.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('scsi') -or $PSBoundParameters.ContainsKey('volumelabel') -or $PSBoundParameters.ContainsKey('ats') -or $PSBoundParameters.ContainsKey('volumeuuid')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.vmfs.lockmode.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.storage.vmfs.pbcache{
<#
.SYNOPSIS
Get VMFS Pointer Block cache statistics.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.vmfs.pbcache.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.vmfs.pbcache.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.storage.vmfs.pbcache.get.invoke()
		}
	}
}

function reset-EsxCLI.storage.vmfs.pbcache{
<#
.SYNOPSIS
Reset the VMFS Pointer Block cache statistics.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.vmfs.pbcache.reset){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.vmfs.pbcache.reset is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.storage.vmfs.pbcache.reset.invoke()
		}
	}
}

function list-EsxCLI.storage.vmfs.snapshot{
<#
.SYNOPSIS
List unresolved snapshots/replicas of VMFS volume.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER volumelabel
The VMFS volume label of the snapshot to list.

.PARAMETER volumeuuid
The VMFS volume uuid of the snapshot to list.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$volumelabel,
	[string]$volumeuuid,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.vmfs.snapshot.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.vmfs.snapshot.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.vmfs.snapshot.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.vmfs.snapshot.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('volumelabel')){
					if($HashTable.containskey('volumelabel')){
						$HashTable.volumelabel = $volumelabel
					}
					Else{
						Write-error "The parameter volumelabel is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('volumeuuid')){
					if($HashTable.containskey('volumeuuid')){
						$HashTable.volumeuuid = $volumeuuid
					}
					Else{
						Write-error "The parameter volumeuuid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.vmfs.snapshot.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('volumelabel') -or $PSBoundParameters.ContainsKey('volumeuuid')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.vmfs.snapshot.list.invoke()
				}
			}
		}
	}
}

function mount-EsxCLI.storage.vmfs.snapshot{
<#
.SYNOPSIS
Mount a snapshot/replica of a VMFS volume.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER nopersist
Mount the volume non-peristently; the volume will not be automounted after a restart.

.PARAMETER volumelabel
The VMFS volume label of the snapshot to mount.

.PARAMETER volumeuuid
The VMFS volume uuid of the snapshot to mount.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$volumelabel,
	[boolean]$nopersist,
	[string]$volumeuuid,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.vmfs.snapshot.mount){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.vmfs.snapshot.mount is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.vmfs.snapshot.mount | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.vmfs.snapshot.mount.CreateArgs()
				if($PSBoundParameters.ContainsKey('volumelabel')){
					if($HashTable.containskey('volumelabel')){
						$HashTable.volumelabel = $volumelabel
					}
					Else{
						Write-error "The parameter volumelabel is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('nopersist')){
					if($HashTable.containskey('nopersist')){
						$HashTable.nopersist = $nopersist
					}
					Else{
						Write-error "The parameter nopersist is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('volumeuuid')){
					if($HashTable.containskey('volumeuuid')){
						$HashTable.volumeuuid = $volumeuuid
					}
					Else{
						Write-error "The parameter volumeuuid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.vmfs.snapshot.mount.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('volumelabel') -or $PSBoundParameters.ContainsKey('nopersist') -or $PSBoundParameters.ContainsKey('volumeuuid')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.vmfs.snapshot.mount.invoke()
				}
			}
		}
	}
}

function resignature-EsxCLI.storage.vmfs.snapshot{
<#
.SYNOPSIS
Resignature a snapshot/replica of a VMFS volume.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER volumelabel
The VMFS volume label of the snapshot to resignature.

.PARAMETER volumeuuid
The VMFS volume uuid of the snapshot to resignature.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$volumelabel,
	[string]$volumeuuid,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.vmfs.snapshot.resignature){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.vmfs.snapshot.resignature is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.vmfs.snapshot.resignature | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.vmfs.snapshot.resignature.CreateArgs()
				if($PSBoundParameters.ContainsKey('volumelabel')){
					if($HashTable.containskey('volumelabel')){
						$HashTable.volumelabel = $volumelabel
					}
					Else{
						Write-error "The parameter volumelabel is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('volumeuuid')){
					if($HashTable.containskey('volumeuuid')){
						$HashTable.volumeuuid = $volumeuuid
					}
					Else{
						Write-error "The parameter volumeuuid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.vmfs.snapshot.resignature.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('volumelabel') -or $PSBoundParameters.ContainsKey('volumeuuid')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.vmfs.snapshot.resignature.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.vmfs.snapshot.extent{
<#
.SYNOPSIS
List extents of unresolved snapshots/replicas of VMFS volume.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER volumelabel
The VMFS volume label of the target snapshot to enumerate.

.PARAMETER volumeuuid
The VMFS volume uuid of the target snapshot to enumerate.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$volumelabel,
	[string]$volumeuuid,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.vmfs.snapshot.extent.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.vmfs.snapshot.extent.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.vmfs.snapshot.extent.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.vmfs.snapshot.extent.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('volumelabel')){
					if($HashTable.containskey('volumelabel')){
						$HashTable.volumelabel = $volumelabel
					}
					Else{
						Write-error "The parameter volumelabel is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('volumeuuid')){
					if($HashTable.containskey('volumeuuid')){
						$HashTable.volumeuuid = $volumeuuid
					}
					Else{
						Write-error "The parameter volumeuuid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.vmfs.snapshot.extent.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('volumelabel') -or $PSBoundParameters.ContainsKey('volumeuuid')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.vmfs.snapshot.extent.list.invoke()
				}
			}
		}
	}
}

function unbindall-EsxCLI.storage.vvol.daemon{
<#
.SYNOPSIS
Unbind all virtual Volumes from all VPs known to the ESX host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.vvol.daemon.unbindall){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.vvol.daemon.unbindall is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.storage.vvol.daemon.unbindall.invoke()
		}
	}
}

function list-EsxCLI.storage.vvol.protocolendpoint{
<#
.SYNOPSIS
List the VVol Protocol EndPoints currently known to the ESX host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER pe
This shows PE information associated with given vasa pe id

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$pe,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.vvol.protocolendpoint.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.vvol.protocolendpoint.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.vvol.protocolendpoint.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.vvol.protocolendpoint.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('pe')){
					if($HashTable.containskey('pe')){
						$HashTable.pe = $pe
					}
					Else{
						Write-error "The parameter pe is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.vvol.protocolendpoint.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('pe')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.vvol.protocolendpoint.list.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.storage.vvol.storagecontainer{
<#
.SYNOPSIS
List the VVol StorageContainers currently known to the ESX host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.vvol.storagecontainer.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.vvol.storagecontainer.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.storage.vvol.storagecontainer.list.invoke()
		}
	}
}

function scan-EsxCLI.storage.vvol.storagecontainer.abandonedvvol{
<#
.SYNOPSIS
Scans the specified storage container for abandoned VVols.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER path
Path to VVol Storage Container to scan.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$path,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.vvol.storagecontainer.abandonedvvol.scan){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.vvol.storagecontainer.abandonedvvol.scan is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.storage.vvol.storagecontainer.abandonedvvol.scan | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.storage.vvol.storagecontainer.abandonedvvol.scan.CreateArgs()
				if($PSBoundParameters.ContainsKey('path')){
					if($HashTable.containskey('path')){
						$HashTable.path = $path
					}
					Else{
						Write-error "The parameter path is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.storage.vvol.storagecontainer.abandonedvvol.scan.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('path')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.storage.vvol.storagecontainer.abandonedvvol.scan.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.storage.vvol.vasacontext{
<#
.SYNOPSIS
Get the VVol VASA Context (VC UUID).

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.vvol.vasacontext.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.vvol.vasacontext.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.storage.vvol.vasacontext.get.invoke()
		}
	}
}

function list-EsxCLI.storage.vvol.vasaprovider{
<#
.SYNOPSIS
List the VASA Providers registered on the host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.storage.vvol.vasaprovider.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.storage.vvol.vasaprovider.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.storage.vvol.vasaprovider.list.invoke()
		}
	}
}

function add-EsxCLI.system.account{
<#
.SYNOPSIS
Create a new local user account.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER description
User description, e.g. full name.

.PARAMETER id
User ID, e.g. "administrator".

.PARAMETER password
User password.

.PARAMETER passwordconfirmation
Password confirmation. Required if password is specified.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$description,
	[string]$passwordconfirmation,
	[string]$password,
	[Parameter(Mandatory=$true)]
	[string]$id,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.account.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.account.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.account.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.account.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('description')){
					if($HashTable.containskey('description')){
						$HashTable.description = $description
					}
					Else{
						Write-error "The parameter description is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('passwordconfirmation')){
					if($HashTable.containskey('passwordconfirmation')){
						$HashTable.passwordconfirmation = $passwordconfirmation
					}
					Else{
						Write-error "The parameter passwordconfirmation is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('password')){
					if($HashTable.containskey('password')){
						$HashTable.password = $password
					}
					Else{
						Write-error "The parameter password is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('id')){
					if($HashTable.containskey('id')){
						$HashTable.id = $id
					}
					Else{
						Write-error "The parameter id is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.account.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('description') -or $PSBoundParameters.ContainsKey('passwordconfirmation') -or $PSBoundParameters.ContainsKey('password') -or $PSBoundParameters.ContainsKey('id')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.account.add.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.system.account{
<#
.SYNOPSIS
List local user accounts.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.account.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.account.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.account.list.invoke()
		}
	}
}

function remove-EsxCLI.system.account{
<#
.SYNOPSIS
Remove an existing local user account.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER id
ID of user to be removed.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$id,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.account.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.account.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.account.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.account.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('id')){
					if($HashTable.containskey('id')){
						$HashTable.id = $id
					}
					Else{
						Write-error "The parameter id is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.account.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('id')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.account.remove.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.system.account{
<#
.SYNOPSIS
Modify an existing local user account.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER description
User description, e.g. full name.

.PARAMETER id
User ID, e.g. "administrator".

.PARAMETER password
User password.

.PARAMETER passwordconfirmation
Password confirmation. Required if password is specified.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$description,
	[string]$passwordconfirmation,
	[string]$password,
	[Parameter(Mandatory=$true)]
	[string]$id,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.account.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.account.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.account.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.account.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('description')){
					if($HashTable.containskey('description')){
						$HashTable.description = $description
					}
					Else{
						Write-error "The parameter description is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('passwordconfirmation')){
					if($HashTable.containskey('passwordconfirmation')){
						$HashTable.passwordconfirmation = $passwordconfirmation
					}
					Else{
						Write-error "The parameter passwordconfirmation is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('password')){
					if($HashTable.containskey('password')){
						$HashTable.password = $password
					}
					Else{
						Write-error "The parameter password is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('id')){
					if($HashTable.containskey('id')){
						$HashTable.id = $id
					}
					Else{
						Write-error "The parameter id is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.account.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('description') -or $PSBoundParameters.ContainsKey('passwordconfirmation') -or $PSBoundParameters.ContainsKey('password') -or $PSBoundParameters.ContainsKey('id')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.account.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.system.boot.device{
<#
.SYNOPSIS
Get the systems boot device.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.boot.device.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.boot.device.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.boot.device.get.invoke()
		}
	}
}

function add-EsxCLI.system.coredump.file{
<#
.SYNOPSIS
Create a VMkernel Dump VMFS file for this system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER auto
Automatically create a file if none found and autoCreateDumpFile kernel option is set.

.PARAMETER datastore
Manually specify the datastore the Dump File is created in.  If not provided, a datastore of sufficient size will be automatically chosen.

.PARAMETER enable
Enable diagnostic file after creation.

.PARAMETER file
Manually specify the file name of the created Dump File.  If not provided, a unique name will be chosen.

.PARAMETER size
Manually set the size in MB of the created Dump File.  If not provided, a default size for the current machine will be calculated.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$file,
	[string]$datastore,
	[long]$size,
	[boolean]$auto,
	[boolean]$enable,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.coredump.file.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.coredump.file.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.coredump.file.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.coredump.file.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('file')){
					if($HashTable.containskey('file')){
						$HashTable.file = $file
					}
					Else{
						Write-error "The parameter file is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('datastore')){
					if($HashTable.containskey('datastore')){
						$HashTable.datastore = $datastore
					}
					Else{
						Write-error "The parameter datastore is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('size')){
					if($HashTable.containskey('size')){
						$HashTable.size = $size
					}
					Else{
						Write-error "The parameter size is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('auto')){
					if($HashTable.containskey('auto')){
						$HashTable.auto = $auto
					}
					Else{
						Write-error "The parameter auto is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('enable')){
					if($HashTable.containskey('enable')){
						$HashTable.enable = $enable
					}
					Else{
						Write-error "The parameter enable is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.coredump.file.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('file') -or $PSBoundParameters.ContainsKey('datastore') -or $PSBoundParameters.ContainsKey('size') -or $PSBoundParameters.ContainsKey('auto') -or $PSBoundParameters.ContainsKey('enable')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.coredump.file.add.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.system.coredump.file{
<#
.SYNOPSIS
Get the dump file path. This command will print the path to the active and/or configured VMFS Dump File.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.coredump.file.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.coredump.file.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.coredump.file.get.invoke()
		}
	}
}

function list-EsxCLI.system.coredump.file{
<#
.SYNOPSIS
List the active and configured VMFS Diagnostic Files.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.coredump.file.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.coredump.file.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.coredump.file.list.invoke()
		}
	}
}

function remove-EsxCLI.system.coredump.file{
<#
.SYNOPSIS
Remove a VMkernel Dump VMFS file from this system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER file
Specify the file name of the Dump File to be removed.  If not given, the configured dump file will be removed.

.PARAMETER force
Deactivate and unconfigure the dump file being removed.  This option is required if the file is active.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$force,
	[string]$file,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.coredump.file.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.coredump.file.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.coredump.file.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.coredump.file.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('force')){
					if($HashTable.containskey('force')){
						$HashTable.force = $force
					}
					Else{
						Write-error "The parameter force is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('file')){
					if($HashTable.containskey('file')){
						$HashTable.file = $file
					}
					Else{
						Write-error "The parameter file is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.coredump.file.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('force') -or $PSBoundParameters.ContainsKey('file')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.coredump.file.remove.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.system.coredump.file{
<#
.SYNOPSIS
Set the active and configured VMkernel Dump VMFS file for this system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER enable
Enable or disable the VMkernel dump file. This option cannot be specified when unconfiguring the dump file.

.PARAMETER path
The path of the VMFS Dump File to use. This must be a pre-allocated file.

.PARAMETER smart
This flag can be used only with --enable=true. It will cause the file to be selected using the smart selection algorithm.

.PARAMETER unconfigure
Unconfigure the current VMFS Dump file.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$smart,
	[boolean]$unconfigure,
	[string]$path,
	[boolean]$enable,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.coredump.file.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.coredump.file.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.coredump.file.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.coredump.file.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('smart')){
					if($HashTable.containskey('smart')){
						$HashTable.smart = $smart
					}
					Else{
						Write-error "The parameter smart is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('unconfigure')){
					if($HashTable.containskey('unconfigure')){
						$HashTable.unconfigure = $unconfigure
					}
					Else{
						Write-error "The parameter unconfigure is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('path')){
					if($HashTable.containskey('path')){
						$HashTable.path = $path
					}
					Else{
						Write-error "The parameter path is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('enable')){
					if($HashTable.containskey('enable')){
						$HashTable.enable = $enable
					}
					Else{
						Write-error "The parameter enable is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.coredump.file.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('smart') -or $PSBoundParameters.ContainsKey('unconfigure') -or $PSBoundParameters.ContainsKey('path') -or $PSBoundParameters.ContainsKey('enable')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.coredump.file.set.invoke()
				}
			}
		}
	}
}

function check-EsxCLI.system.coredump.network{
<#
.SYNOPSIS
Check the status of the configured network dump server

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.coredump.network.check){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.coredump.network.check is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.coredump.network.check.invoke()
		}
	}
}

function get-EsxCLI.system.coredump.network{
<#
.SYNOPSIS
Get the currently configured parameters for network coredump, if enabled.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.coredump.network.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.coredump.network.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.coredump.network.get.invoke()
		}
	}
}

function set-EsxCLI.system.coredump.network{
<#
.SYNOPSIS
Set the parameters used for network core dump

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER enable
Enable network dump. This option cannot be specified when setting the dump parameters below.

.PARAMETER interfacename
An active interface to be used for the network core dump. Required option when setting dump parameters.

.PARAMETER serverip
IP address of the core dump server( ipv4 or ipv6 )(Required if --server-ipv4 is not used.)

.PARAMETER serveripv4
IPv4 address of the core dump server.(deprecated, use -j|--server-ip instead)

.PARAMETER serverport
Port on which the core dump server is listening. (Optional)

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$interfacename,
	[string]$serveripv4,
	[long]$serverport,
	[string]$serverip,
	[boolean]$enable,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.coredump.network.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.coredump.network.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.coredump.network.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.coredump.network.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('interfacename')){
					if($HashTable.containskey('interfacename')){
						$HashTable.interfacename = $interfacename
					}
					Else{
						Write-error "The parameter interfacename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('serveripv4')){
					if($HashTable.containskey('serveripv4')){
						$HashTable.serveripv4 = $serveripv4
					}
					Else{
						Write-error "The parameter serveripv4 is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('serverport')){
					if($HashTable.containskey('serverport')){
						$HashTable.serverport = $serverport
					}
					Else{
						Write-error "The parameter serverport is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('serverip')){
					if($HashTable.containskey('serverip')){
						$HashTable.serverip = $serverip
					}
					Else{
						Write-error "The parameter serverip is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('enable')){
					if($HashTable.containskey('enable')){
						$HashTable.enable = $enable
					}
					Else{
						Write-error "The parameter enable is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.coredump.network.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('interfacename') -or $PSBoundParameters.ContainsKey('serveripv4') -or $PSBoundParameters.ContainsKey('serverport') -or $PSBoundParameters.ContainsKey('serverip') -or $PSBoundParameters.ContainsKey('enable')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.coredump.network.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.system.coredump.partition{
<#
.SYNOPSIS
Get one of the dump partition configured values. This command will print either the active dump partition or the configured dump partition depending on the flags passed.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.coredump.partition.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.coredump.partition.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.coredump.partition.get.invoke()
		}
	}
}

function list-EsxCLI.system.coredump.partition{
<#
.SYNOPSIS
List all of the partitions on the system that have a partition type matching the VMware Core partition type. Also indicate which partition, if any, is being used as the system's dump partition and which is configured to be used at next boot.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.coredump.partition.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.coredump.partition.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.coredump.partition.list.invoke()
		}
	}
}

function set-EsxCLI.system.coredump.partition{
<#
.SYNOPSIS
Set the specific VMkernel dump partition for this system. This will configure the dump partition for the next boot. This command will change the active dump partition to the partition specified.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER enable
Enable or disable the VMkernel dump partition. This option cannot be specified when setting or unconfiguring the dump partition.

.PARAMETER partition
The name of the partition to use. This should be a device name with a partition number at the end. Example: naa.xxxxx:1

.PARAMETER smart
This flag can be used only with --enable=true. It will cause the best available partition to be selected using the smart selection algorithm.

.PARAMETER unconfigure
Set the dump partition into an unconfigured state. This will remove the current configured dump partition for the next boot. This will result in the smart activate algorithm being used at the next boot.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$smart,
	[boolean]$unconfigure,
	[string]$partition,
	[boolean]$enable,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.coredump.partition.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.coredump.partition.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.coredump.partition.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.coredump.partition.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('smart')){
					if($HashTable.containskey('smart')){
						$HashTable.smart = $smart
					}
					Else{
						Write-error "The parameter smart is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('unconfigure')){
					if($HashTable.containskey('unconfigure')){
						$HashTable.unconfigure = $unconfigure
					}
					Else{
						Write-error "The parameter unconfigure is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('partition')){
					if($HashTable.containskey('partition')){
						$HashTable.partition = $partition
					}
					Else{
						Write-error "The parameter partition is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('enable')){
					if($HashTable.containskey('enable')){
						$HashTable.enable = $enable
					}
					Else{
						Write-error "The parameter enable is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.coredump.partition.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('smart') -or $PSBoundParameters.ContainsKey('unconfigure') -or $PSBoundParameters.ContainsKey('partition') -or $PSBoundParameters.ContainsKey('enable')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.coredump.partition.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.system.hostname{
<#
.SYNOPSIS
Get the host, domain or fully qualified name of the ESX host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.hostname.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.hostname.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.hostname.get.invoke()
		}
	}
}

function set-EsxCLI.system.hostname{
<#
.SYNOPSIS
This command allows the user to set the hostname, domain name or fully qualified domain name of the ESX host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER domain
The domain name to set for the ESX host. This option is mutually exclusive with the --fqdn option.

.PARAMETER fqdn
Set the fully qualified domain name of the ESX host.

.PARAMETER host2
The host name to set for the ESX host. This name should not contain the DNS domain name of the host and can only contain letters, numbers and '-'. NOTE this is not the fully qualified name, that can be set with the --fqdn option. This option is mutually exclusive with the --fqdn option.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$fqdn,
	[string]$domain,
	[string]$host2,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.hostname.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.hostname.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.hostname.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.hostname.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('fqdn')){
					if($HashTable.containskey('fqdn')){
						$HashTable.fqdn = $fqdn
					}
					Else{
						Write-error "The parameter fqdn is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('domain')){
					if($HashTable.containskey('domain')){
						$HashTable.domain = $domain
					}
					Else{
						Write-error "The parameter domain is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('host2')){
					if($HashTable.containskey('host')){
						$HashTable.host = $host2
					}
					Else{
						Write-error "The parameter host2 is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.hostname.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('fqdn') -or $PSBoundParameters.ContainsKey('domain') -or $PSBoundParameters.ContainsKey('host2')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.hostname.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.system.maintenanceMode{
<#
.SYNOPSIS
Get the maintenance mode state of the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.maintenanceMode.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.maintenanceMode.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.maintenanceMode.get.invoke()
		}
	}
}

function set-EsxCLI.system.maintenanceMode{
<#
.SYNOPSIS
Enable or disable the maintenance mode of the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER enable
enable maintenance mode

.PARAMETER timeout
Time to perform operation in seconds (default 0 seconds)

.PARAMETER vsanmode
Action the VSAN service must take before the host can enter maintenance mode (default ensureObjectAccessibility). Allowed values are: 
    ensureObjectAccessibility: Evacuate data from the disk to ensure object accessibility in the Virtual SAN cluster, before entering maintenance mode.
    evacuateAllData: Evacuate all data from the disk before entering maintenance mode.
    noAction: Do not move Virtual SAN data out of the disk before entering maintenance mode.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[long]$timeout,
	[string]$vsanmode,
	[Parameter(Mandatory=$true)]
	[boolean]$enable,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.maintenanceMode.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.maintenanceMode.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.maintenanceMode.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.maintenanceMode.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('timeout')){
					if($HashTable.containskey('timeout')){
						$HashTable.timeout = $timeout
					}
					Else{
						Write-error "The parameter timeout is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('vsanmode')){
					if($HashTable.containskey('vsanmode')){
						$HashTable.vsanmode = $vsanmode
					}
					Else{
						Write-error "The parameter vsanmode is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('enable')){
					if($HashTable.containskey('enable')){
						$HashTable.enable = $enable
					}
					Else{
						Write-error "The parameter enable is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.maintenanceMode.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('timeout') -or $PSBoundParameters.ContainsKey('vsanmode') -or $PSBoundParameters.ContainsKey('enable')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.maintenanceMode.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.system.module{
<#
.SYNOPSIS
Show information for a VMkernel module.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER module
The name of the VMkernel module.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$module,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.module.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.module.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.module.get | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.module.get.CreateArgs()
				if($PSBoundParameters.ContainsKey('module')){
					if($HashTable.containskey('module')){
						$HashTable.module = $module
					}
					Else{
						Write-error "The parameter module is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.module.get.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('module')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.module.get.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.system.module{
<#
.SYNOPSIS
List the VMkernel modules that the system knows about.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER enabled
List the enabled / disabled VMkernel modules and device drivers.

.PARAMETER loaded
List the loaded / not loaded VMkernel modules and device drivers.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$enabled,
	[boolean]$loaded,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.module.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.module.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.module.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.module.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('enabled')){
					if($HashTable.containskey('enabled')){
						$HashTable.enabled = $enabled
					}
					Else{
						Write-error "The parameter enabled is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('loaded')){
					if($HashTable.containskey('loaded')){
						$HashTable.loaded = $loaded
					}
					Else{
						Write-error "The parameter loaded is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.module.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('enabled') -or $PSBoundParameters.ContainsKey('loaded')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.module.list.invoke()
				}
			}
		}
	}
}

function load-EsxCLI.system.module{
<#
.SYNOPSIS
Load a VMkernel module with the given name if it is enabled. If the module is disabled then the use of --force is required to load the module.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER force
Ignore the enabled/disabled state of this module and force it to load.

.PARAMETER module
The name of the VMkernel module to load.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$module,
	[boolean]$force,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.module.load){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.module.load is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.module.load | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.module.load.CreateArgs()
				if($PSBoundParameters.ContainsKey('module')){
					if($HashTable.containskey('module')){
						$HashTable.module = $module
					}
					Else{
						Write-error "The parameter module is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('force')){
					if($HashTable.containskey('force')){
						$HashTable.force = $force
					}
					Else{
						Write-error "The parameter force is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.module.load.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('module') -or $PSBoundParameters.ContainsKey('force')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.module.load.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.system.module{
<#
.SYNOPSIS
Allow enabling and disabling of a VMkernel module.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER enabled
Set to true to enable the module, set to false to disable the module.

.PARAMETER force
Skip VMkernel module validity checks and set options for a module (or alias) with the given name.

.PARAMETER module
The name of the VMkernel module to set options for.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[boolean]$enabled,
	[Parameter(Mandatory=$true)]
	[string]$module,
	[boolean]$force,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.module.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.module.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.module.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.module.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('enabled')){
					if($HashTable.containskey('enabled')){
						$HashTable.enabled = $enabled
					}
					Else{
						Write-error "The parameter enabled is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('module')){
					if($HashTable.containskey('module')){
						$HashTable.module = $module
					}
					Else{
						Write-error "The parameter module is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('force')){
					if($HashTable.containskey('force')){
						$HashTable.force = $force
					}
					Else{
						Write-error "The parameter force is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.module.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('enabled') -or $PSBoundParameters.ContainsKey('module') -or $PSBoundParameters.ContainsKey('force')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.module.set.invoke()
				}
			}
		}
	}
}

function copy-EsxCLI.system.module.parameters{
<#
.SYNOPSIS
Copy the load time parameters from one VMkernel module to another.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER force
Skip VMkernel module validity checks for the source VMkernel module.

.PARAMETER parameterkeys
Parameter key that should get copied.

.PARAMETER source
The name of the source VMkernel module.

.PARAMETER target
The name of the target VMkernel module.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$source,
	[Parameter(Mandatory=$true)]
	[string]$target,
	[Parameter(Mandatory=$true)]
	[string[]]$parameterkeys,
	[boolean]$force,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.module.parameters.copy){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.module.parameters.copy is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.module.parameters.copy | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.module.parameters.copy.CreateArgs()
				if($PSBoundParameters.ContainsKey('source')){
					if($HashTable.containskey('source')){
						$HashTable.source = $source
					}
					Else{
						Write-error "The parameter source is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('target')){
					if($HashTable.containskey('target')){
						$HashTable.target = $target
					}
					Else{
						Write-error "The parameter target is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('parameterkeys')){
					if($HashTable.containskey('parameterkeys')){
						$HashTable.parameterkeys = $parameterkeys
					}
					Else{
						Write-error "The parameter parameterkeys is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('force')){
					if($HashTable.containskey('force')){
						$HashTable.force = $force
					}
					Else{
						Write-error "The parameter force is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.module.parameters.copy.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('source') -or $PSBoundParameters.ContainsKey('target') -or $PSBoundParameters.ContainsKey('parameterkeys') -or $PSBoundParameters.ContainsKey('force')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.module.parameters.copy.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.system.module.parameters{
<#
.SYNOPSIS
List the parameters, a descriptions of each parameter supported for a given module name and the user defined value for each parameter.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER module
The name of the VMkernel module to get the option string for.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$module,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.module.parameters.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.module.parameters.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.module.parameters.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.module.parameters.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('module')){
					if($HashTable.containskey('module')){
						$HashTable.module = $module
					}
					Else{
						Write-error "The parameter module is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.module.parameters.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('module')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.module.parameters.list.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.system.module.parameters{
<#
.SYNOPSIS
Set the load time parameters for the given VMkernel module.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER append
Append the specified parameter string to the currently configured parameter string for the VMkernel module. If --append is not specified, the parameter string currently configured for the VMkernel module will be replaced by the specified parameter string.

.PARAMETER force
Skip VMkernel module validity checks and set parameters for a module (or alias) with the given name.

.PARAMETER module
The name of the VMkernel module to set parameters for.

.PARAMETER parameterstring
The string containing the parameters for this module.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$module,
	[Parameter(Mandatory=$true)]
	[string]$parameterstring,
	[boolean]$append,
	[boolean]$force,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.module.parameters.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.module.parameters.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.module.parameters.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.module.parameters.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('module')){
					if($HashTable.containskey('module')){
						$HashTable.module = $module
					}
					Else{
						Write-error "The parameter module is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('parameterstring')){
					if($HashTable.containskey('parameterstring')){
						$HashTable.parameterstring = $parameterstring
					}
					Else{
						Write-error "The parameter parameterstring is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('append')){
					if($HashTable.containskey('append')){
						$HashTable.append = $append
					}
					Else{
						Write-error "The parameter append is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('force')){
					if($HashTable.containskey('force')){
						$HashTable.force = $force
					}
					Else{
						Write-error "The parameter force is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.module.parameters.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('module') -or $PSBoundParameters.ContainsKey('parameterstring') -or $PSBoundParameters.ContainsKey('append') -or $PSBoundParameters.ContainsKey('force')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.module.parameters.set.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.system.permission{
<#
.SYNOPSIS
List permissions defined on the host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.permission.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.permission.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.permission.list.invoke()
		}
	}
}

function set-EsxCLI.system.permission{
<#
.SYNOPSIS
Set permission for a user or group.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER group
Specifies that the supplied ID refers to a group. ESXi local groups are not supported.

.PARAMETER id
ID of user or group. Domain users or groups should be specified as "DOMAIN\user_name" or "DOMAIN\group_name".

.PARAMETER role
Name of role that specifies user access rights. 
    Admin: Full access rights
    NoAccess: Used for restricting granted access. E.g. to deny access for some user whose group already has access.
    ReadOnly: See details of objects, but not make changes

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$role,
	[boolean]$group,
	[Parameter(Mandatory=$true)]
	[string]$id,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.permission.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.permission.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.permission.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.permission.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('role')){
					if($HashTable.containskey('role')){
						$HashTable.role = $role
					}
					Else{
						Write-error "The parameter role is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('group')){
					if($HashTable.containskey('group')){
						$HashTable.group = $group
					}
					Else{
						Write-error "The parameter group is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('id')){
					if($HashTable.containskey('id')){
						$HashTable.id = $id
					}
					Else{
						Write-error "The parameter id is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.permission.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('role') -or $PSBoundParameters.ContainsKey('group') -or $PSBoundParameters.ContainsKey('id')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.permission.set.invoke()
				}
			}
		}
	}
}

function unset-EsxCLI.system.permission{
<#
.SYNOPSIS
Remove permission for a user or group.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER group
Specifies that the supplied ID refers to a group.

.PARAMETER id
ID of user or group.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$group,
	[Parameter(Mandatory=$true)]
	[string]$id,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.permission.unset){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.permission.unset is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.permission.unset | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.permission.unset.CreateArgs()
				if($PSBoundParameters.ContainsKey('group')){
					if($HashTable.containskey('group')){
						$HashTable.group = $group
					}
					Else{
						Write-error "The parameter group is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('id')){
					if($HashTable.containskey('id')){
						$HashTable.id = $id
					}
					Else{
						Write-error "The parameter id is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.permission.unset.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('group') -or $PSBoundParameters.ContainsKey('id')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.permission.unset.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.system.process{
<#
.SYNOPSIS
List the VMkernel UserWorld processes currently on the host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.process.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.process.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.process.list.invoke()
		}
	}
}

function get-EsxCLI.system.process.stats.load{
<#
.SYNOPSIS
System load average over the last 1, 5 and 15 minutes.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.process.stats.load.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.process.stats.load.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.process.stats.load.get.invoke()
		}
	}
}

function get-EsxCLI.system.process.stats.running{
<#
.SYNOPSIS
Number of currently running processes.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.process.stats.running.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.process.stats.running.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.process.stats.running.get.invoke()
		}
	}
}

function list-EsxCLI.system.secpolicy.domain{
<#
.SYNOPSIS
List the enforcement level for each domain.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.secpolicy.domain.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.secpolicy.domain.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.secpolicy.domain.list.invoke()
		}
	}
}

function set-EsxCLI.system.secpolicy.domain{
<#
.SYNOPSIS
Set the enforcement level for a domain in the system. Any option specified here is not persistent and will not survive a reboot of the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER alldomains
All domains.

.PARAMETER level
The enforcement level.

.PARAMETER name
The domain name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$level,
	[boolean]$alldomains,
	[string]$name,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.secpolicy.domain.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.secpolicy.domain.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.secpolicy.domain.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.secpolicy.domain.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('level')){
					if($HashTable.containskey('level')){
						$HashTable.level = $level
					}
					Else{
						Write-error "The parameter level is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('alldomains')){
					if($HashTable.containskey('alldomains')){
						$HashTable.alldomains = $alldomains
					}
					Else{
						Write-error "The parameter alldomains is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('name')){
					if($HashTable.containskey('name')){
						$HashTable.name = $name
					}
					Else{
						Write-error "The parameter name is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.secpolicy.domain.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('level') -or $PSBoundParameters.ContainsKey('alldomains') -or $PSBoundParameters.ContainsKey('name')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.secpolicy.domain.set.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.system.security.certificatestore{
<#
.SYNOPSIS
Add a new CA certificate to the CA certificate store.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER filename
Path to certificate file in PEM format

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$filename,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.security.certificatestore.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.security.certificatestore.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.security.certificatestore.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.security.certificatestore.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('filename')){
					if($HashTable.containskey('filename')){
						$HashTable.filename = $filename
					}
					Else{
						Write-error "The parameter filename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.security.certificatestore.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('filename')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.security.certificatestore.add.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.system.security.certificatestore{
<#
.SYNOPSIS
List all certificates in the CA certificate store.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.security.certificatestore.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.security.certificatestore.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.security.certificatestore.list.invoke()
		}
	}
}

function remove-EsxCLI.system.security.certificatestore{
<#
.SYNOPSIS
Remove a certificate from the CA certificate store.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER issuer
Remove certificate by the specified issuer

.PARAMETER serial
Remove certificate of specified serial number

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$serial,
	[Parameter(Mandatory=$true)]
	[string]$issuer,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.security.certificatestore.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.security.certificatestore.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.security.certificatestore.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.security.certificatestore.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('serial')){
					if($HashTable.containskey('serial')){
						$HashTable.serial = $serial
					}
					Else{
						Write-error "The parameter serial is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('issuer')){
					if($HashTable.containskey('issuer')){
						$HashTable.issuer = $issuer
					}
					Else{
						Write-error "The parameter issuer is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.security.certificatestore.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('serial') -or $PSBoundParameters.ContainsKey('issuer')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.security.certificatestore.remove.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.system.settings.advanced{
<#
.SYNOPSIS
List the advanced options available from the VMkernel.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER delta
Only display options whose values differ from their default.

.PARAMETER option
Only get the information for a single VMkernel advanced option.

.PARAMETER tree
Limit the list of advanced option to a specific sub tree.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$option,
	[string]$tree,
	[boolean]$delta,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.settings.advanced.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.settings.advanced.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.settings.advanced.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.settings.advanced.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('option')){
					if($HashTable.containskey('option')){
						$HashTable.option = $option
					}
					Else{
						Write-error "The parameter option is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('tree')){
					if($HashTable.containskey('tree')){
						$HashTable.tree = $tree
					}
					Else{
						Write-error "The parameter tree is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('delta')){
					if($HashTable.containskey('delta')){
						$HashTable.delta = $delta
					}
					Else{
						Write-error "The parameter delta is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.settings.advanced.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('option') -or $PSBoundParameters.ContainsKey('tree') -or $PSBoundParameters.ContainsKey('delta')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.settings.advanced.list.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.system.settings.advanced{
<#
.SYNOPSIS
Set the value of an advanced option.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER default
Reset the option to its default value.

.PARAMETER intvalue
If the option is an integer value use this option.

.PARAMETER option
The name of the option to set the value of. Example: "/Misc/HostName"

.PARAMETER stringvalue
If the option is a string use this option.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$default,
	[Parameter(Mandatory=$true)]
	[string]$option,
	[string]$stringvalue,
	[long]$intvalue,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.settings.advanced.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.settings.advanced.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.settings.advanced.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.settings.advanced.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('default')){
					if($HashTable.containskey('default')){
						$HashTable.default = $default
					}
					Else{
						Write-error "The parameter default is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('option')){
					if($HashTable.containskey('option')){
						$HashTable.option = $option
					}
					Else{
						Write-error "The parameter option is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('stringvalue')){
					if($HashTable.containskey('stringvalue')){
						$HashTable.stringvalue = $stringvalue
					}
					Else{
						Write-error "The parameter stringvalue is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('intvalue')){
					if($HashTable.containskey('intvalue')){
						$HashTable.intvalue = $intvalue
					}
					Else{
						Write-error "The parameter intvalue is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.settings.advanced.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('default') -or $PSBoundParameters.ContainsKey('option') -or $PSBoundParameters.ContainsKey('stringvalue') -or $PSBoundParameters.ContainsKey('intvalue')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.settings.advanced.set.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.system.settings.kernel{
<#
.SYNOPSIS
List VMkernel kernel settings.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER delta
Only display options whose values differ from their default.

.PARAMETER option
The name of the VMkernel kernel setting to get.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$delta,
	[string]$option,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.settings.kernel.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.settings.kernel.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.settings.kernel.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.settings.kernel.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('delta')){
					if($HashTable.containskey('delta')){
						$HashTable.delta = $delta
					}
					Else{
						Write-error "The parameter delta is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('option')){
					if($HashTable.containskey('option')){
						$HashTable.option = $option
					}
					Else{
						Write-error "The parameter option is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.settings.kernel.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('delta') -or $PSBoundParameters.ContainsKey('option')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.settings.kernel.list.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.system.settings.kernel{
<#
.SYNOPSIS
Set a VMKernel setting.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER setting
The name of the VMKernel setting to set.

.PARAMETER value
The value to set the setting to.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$setting,
	[Parameter(Mandatory=$true)]
	[string]$value,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.settings.kernel.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.settings.kernel.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.settings.kernel.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.settings.kernel.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('setting')){
					if($HashTable.containskey('setting')){
						$HashTable.setting = $setting
					}
					Else{
						Write-error "The parameter setting is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('value')){
					if($HashTable.containskey('value')){
						$HashTable.value = $value
					}
					Else{
						Write-error "The parameter value is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.settings.kernel.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('setting') -or $PSBoundParameters.ContainsKey('value')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.settings.kernel.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.system.settings.keyboard.layout{
<#
.SYNOPSIS
Get the keyboard layout

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.settings.keyboard.layout.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.settings.keyboard.layout.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.settings.keyboard.layout.get.invoke()
		}
	}
}

function list-EsxCLI.system.settings.keyboard.layout{
<#
.SYNOPSIS
List the keyboard layout

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.settings.keyboard.layout.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.settings.keyboard.layout.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.settings.keyboard.layout.list.invoke()
		}
	}
}

function set-EsxCLI.system.settings.keyboard.layout{
<#
.SYNOPSIS
Set the keyboard layout

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER layout
The name of the layout to set

.PARAMETER nopersist
Only apply this layout for the current boot

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$nopersist,
	[string]$layout,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.settings.keyboard.layout.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.settings.keyboard.layout.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.settings.keyboard.layout.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.settings.keyboard.layout.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('nopersist')){
					if($HashTable.containskey('nopersist')){
						$HashTable.nopersist = $nopersist
					}
					Else{
						Write-error "The parameter nopersist is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('layout')){
					if($HashTable.containskey('layout')){
						$HashTable.layout = $layout
					}
					Else{
						Write-error "The parameter layout is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.settings.keyboard.layout.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('nopersist') -or $PSBoundParameters.ContainsKey('layout')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.settings.keyboard.layout.set.invoke()
				}
			}
		}
	}
}

function poweroff-EsxCLI.system.shutdown{
<#
.SYNOPSIS
Power off the system. The host must be in maintenance mode.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER delay
Delay interval in seconds

.PARAMETER reason
Reason for performing the operation

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$reason,
	[long]$delay,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.shutdown.poweroff){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.shutdown.poweroff is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.shutdown.poweroff | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.shutdown.poweroff.CreateArgs()
				if($PSBoundParameters.ContainsKey('reason')){
					if($HashTable.containskey('reason')){
						$HashTable.reason = $reason
					}
					Else{
						Write-error "The parameter reason is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('delay')){
					if($HashTable.containskey('delay')){
						$HashTable.delay = $delay
					}
					Else{
						Write-error "The parameter delay is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.shutdown.poweroff.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('reason') -or $PSBoundParameters.ContainsKey('delay')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.shutdown.poweroff.invoke()
				}
			}
		}
	}
}

function reboot-EsxCLI.system.shutdown{
<#
.SYNOPSIS
Reboot the system. The host must be in maintenance mode.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER delay
Delay interval in seconds

.PARAMETER reason
Reason for performing the operation

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$reason,
	[long]$delay,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.shutdown.reboot){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.shutdown.reboot is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.shutdown.reboot | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.shutdown.reboot.CreateArgs()
				if($PSBoundParameters.ContainsKey('reason')){
					if($HashTable.containskey('reason')){
						$HashTable.reason = $reason
					}
					Else{
						Write-error "The parameter reason is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('delay')){
					if($HashTable.containskey('delay')){
						$HashTable.delay = $delay
					}
					Else{
						Write-error "The parameter delay is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.shutdown.reboot.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('reason') -or $PSBoundParameters.ContainsKey('delay')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.shutdown.reboot.invoke()
				}
			}
		}
	}
}

function search-EsxCLI.system.slp{
<#
.SYNOPSIS
Perform SLP search for neighboring services

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER node
Optional, host FQDN or IP address to connect to. Use -P to control protocol used.

.PARAMETER port
Optional, override the default port value 427.

.PARAMETER protocol
Optional, override unicast protocol:  [tcp, udp], default tcp, requires -n.

.PARAMETER service
Optional, the service name to search for. Defaults to 'service-agent'.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$node,
	[string]$protocol,
	[long]$port,
	[string]$service,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.slp.search){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.slp.search is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.slp.search | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.slp.search.CreateArgs()
				if($PSBoundParameters.ContainsKey('node')){
					if($HashTable.containskey('node')){
						$HashTable.node = $node
					}
					Else{
						Write-error "The parameter node is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('protocol')){
					if($HashTable.containskey('protocol')){
						$HashTable.protocol = $protocol
					}
					Else{
						Write-error "The parameter protocol is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('port')){
					if($HashTable.containskey('port')){
						$HashTable.port = $port
					}
					Else{
						Write-error "The parameter port is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('service')){
					if($HashTable.containskey('service')){
						$HashTable.service = $service
					}
					Else{
						Write-error "The parameter service is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.slp.search.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('node') -or $PSBoundParameters.ContainsKey('protocol') -or $PSBoundParameters.ContainsKey('port') -or $PSBoundParameters.ContainsKey('service')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.slp.search.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.system.slp.stats{
<#
.SYNOPSIS
Report operational state of Service Location Protocol Daemon

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.slp.stats.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.slp.stats.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.slp.stats.get.invoke()
		}
	}
}

function get-EsxCLI.system.snmp{
<#
.SYNOPSIS
Get SNMP Agent configuration

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.snmp.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.snmp.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.snmp.get.invoke()
		}
	}
}

function hash-EsxCLI.system.snmp{
<#
.SYNOPSIS
Generate localized hash values based on this agents snmp engine id.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER authhash
Provide filename to secret for authentication hash, use in set --users

.PARAMETER privhash
Provide filename to secret for privacy hash, use in set --users

.PARAMETER rawsecret
Make -A and -X flags read raw secret from command line instead of file.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$privhash,
	[Parameter(Mandatory=$true)]
	[string]$authhash,
	[boolean]$rawsecret,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.snmp.hash){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.snmp.hash is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.snmp.hash | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.snmp.hash.CreateArgs()
				if($PSBoundParameters.ContainsKey('privhash')){
					if($HashTable.containskey('privhash')){
						$HashTable.privhash = $privhash
					}
					Else{
						Write-error "The parameter privhash is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('authhash')){
					if($HashTable.containskey('authhash')){
						$HashTable.authhash = $authhash
					}
					Else{
						Write-error "The parameter authhash is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('rawsecret')){
					if($HashTable.containskey('rawsecret')){
						$HashTable.rawsecret = $rawsecret
					}
					Else{
						Write-error "The parameter rawsecret is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.snmp.hash.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('privhash') -or $PSBoundParameters.ContainsKey('authhash') -or $PSBoundParameters.ContainsKey('rawsecret')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.snmp.hash.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.system.snmp{
<#
.SYNOPSIS
This command allows the user to set up ESX SNMP agent.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER authentication
Set default authentication protocol. Values: none, MD5, SHA1

.PARAMETER communities
Set up to ten communities each no more than 64 characters. Format is: community1[,community2,...] (this overwrites previous settings)

.PARAMETER enable
Start or stop SNMP service. Values: [yes|no, true|false, 0|1]

.PARAMETER engineid
Set SNMPv3 engine id. Must be at least 10 to 32 hexadecimal characters. 0x or 0X is stripped if found as well as colons (:)

.PARAMETER hwsrc
Where to source hardware events from IPMI sensors or CIM Indications. One of: indications|sensors

.PARAMETER largestorage
Support large storage for hrStorageAllocationUnits *hrStorageSize. Values: [yes|no, true|false, 0|1].  Control how theagent reports hrStorageAllocationUnits, hrStorageSize andhrStorageUsed in hrStorageTable.  Setting this directive to 1 tosupport large storage with small allocation units, the agentre-calculates these values so they all fit Integer32 andhrStorageAllocationUnits * hrStorageSize gives real size of thestorage ( Note: hrStorageAllocationUnits will not be real allocationunits if real hrStorageSize won't fit into Integer32 ).  Setting thisdirective to 0 turns off this calculation and the agent reports realhrStorageAllocationUnits, but it might report wrong hrStorageSize forlarge storage because the value won't fit into Integer32.

.PARAMETER loglevel
System Agent syslog logging level: debug|info|warning|error

.PARAMETER notraps
Comma separated list of trap oids for traps not to be sent by agent. Use value 'reset' to clear setting

.PARAMETER port
Set UDP port to poll snmp agent on. The default is udp/161. May not use ports 32768 to 40959

.PARAMETER privacy
Set default privacy protocol. Values: none, AES128

.PARAMETER remoteusers
Set up to five inform user ids. Format is: user/auth-proto/-|auth-hash/priv-proto/-|priv-hash/engine-id[,...] Where user is 32 chars max. auth-proto is none|MD5|SHA1, priv-proto is none|AES. '-' indicates no hash. engine-id is hex string '0x0-9a-f' up to 32 chars max.

.PARAMETER reset
Return agent configuration to factory defaults

.PARAMETER syscontact
System contact string as presented in sysContact.0. Up to 255 characters

.PARAMETER syslocation
System location string as presented in sysLocation.0. Up to 255 characters.

.PARAMETER targets
Set up to three targets to send SNMPv1 traps to. Format is: ip-or-hostname[@port]/community[,...] The default port is udp/162. (this overwrites previous settings)

.PARAMETER users
Set up to five local users. Format is: user/-|auth-hash/-|priv-hash/model[,...] Where user is 32 chars max. '-' indicates no hash. Model is one of (none|auth|priv).

.PARAMETER v3targets
Set up to three SNMPv3 notification targets. Format is: ip-or-hostname[@port]/remote-user/security-level/trap|inform[,...].

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$privacy,
	[boolean]$enable,
	[string]$syslocation,
	[string]$engineid,
	[string]$notraps,
	[string]$remoteusers,
	[string]$hwsrc,
	[boolean]$reset,
	[string]$authentication,
	[string]$syscontact,
	[string]$users,
	[string]$v3targets,
	[string]$communities,
	[long]$port,
	[string]$loglevel,
	[string]$targets,
	[boolean]$largestorage,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.snmp.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.snmp.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.snmp.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.snmp.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('privacy')){
					if($HashTable.containskey('privacy')){
						$HashTable.privacy = $privacy
					}
					Else{
						Write-error "The parameter privacy is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('enable')){
					if($HashTable.containskey('enable')){
						$HashTable.enable = $enable
					}
					Else{
						Write-error "The parameter enable is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('syslocation')){
					if($HashTable.containskey('syslocation')){
						$HashTable.syslocation = $syslocation
					}
					Else{
						Write-error "The parameter syslocation is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('engineid')){
					if($HashTable.containskey('engineid')){
						$HashTable.engineid = $engineid
					}
					Else{
						Write-error "The parameter engineid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('notraps')){
					if($HashTable.containskey('notraps')){
						$HashTable.notraps = $notraps
					}
					Else{
						Write-error "The parameter notraps is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('remoteusers')){
					if($HashTable.containskey('remoteusers')){
						$HashTable.remoteusers = $remoteusers
					}
					Else{
						Write-error "The parameter remoteusers is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('hwsrc')){
					if($HashTable.containskey('hwsrc')){
						$HashTable.hwsrc = $hwsrc
					}
					Else{
						Write-error "The parameter hwsrc is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('reset')){
					if($HashTable.containskey('reset')){
						$HashTable.reset = $reset
					}
					Else{
						Write-error "The parameter reset is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('authentication')){
					if($HashTable.containskey('authentication')){
						$HashTable.authentication = $authentication
					}
					Else{
						Write-error "The parameter authentication is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('syscontact')){
					if($HashTable.containskey('syscontact')){
						$HashTable.syscontact = $syscontact
					}
					Else{
						Write-error "The parameter syscontact is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('users')){
					if($HashTable.containskey('users')){
						$HashTable.users = $users
					}
					Else{
						Write-error "The parameter users is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('v3targets')){
					if($HashTable.containskey('v3targets')){
						$HashTable.v3targets = $v3targets
					}
					Else{
						Write-error "The parameter v3targets is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('communities')){
					if($HashTable.containskey('communities')){
						$HashTable.communities = $communities
					}
					Else{
						Write-error "The parameter communities is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('port')){
					if($HashTable.containskey('port')){
						$HashTable.port = $port
					}
					Else{
						Write-error "The parameter port is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('loglevel')){
					if($HashTable.containskey('loglevel')){
						$HashTable.loglevel = $loglevel
					}
					Else{
						Write-error "The parameter loglevel is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('targets')){
					if($HashTable.containskey('targets')){
						$HashTable.targets = $targets
					}
					Else{
						Write-error "The parameter targets is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('largestorage')){
					if($HashTable.containskey('largestorage')){
						$HashTable.largestorage = $largestorage
					}
					Else{
						Write-error "The parameter largestorage is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.snmp.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('privacy') -or $PSBoundParameters.ContainsKey('enable') -or $PSBoundParameters.ContainsKey('syslocation') -or $PSBoundParameters.ContainsKey('engineid') -or $PSBoundParameters.ContainsKey('notraps') -or $PSBoundParameters.ContainsKey('remoteusers') -or $PSBoundParameters.ContainsKey('hwsrc') -or $PSBoundParameters.ContainsKey('reset') -or $PSBoundParameters.ContainsKey('authentication') -or $PSBoundParameters.ContainsKey('syscontact') -or $PSBoundParameters.ContainsKey('users') -or $PSBoundParameters.ContainsKey('v3targets') -or $PSBoundParameters.ContainsKey('communities') -or $PSBoundParameters.ContainsKey('port') -or $PSBoundParameters.ContainsKey('loglevel') -or $PSBoundParameters.ContainsKey('targets') -or $PSBoundParameters.ContainsKey('largestorage')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.snmp.set.invoke()
				}
			}
		}
	}
}

function test-EsxCLI.system.snmp{
<#
.SYNOPSIS
Verify ESX SNMP notifications can be delivered to target destinations.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER authhash
Optionally test authentication secret generates matching hash for user

.PARAMETER privhash
Optionally test privacy secret generates matching hash for user

.PARAMETER rawsecret
Make -A and -X flags read raw secret from command line instead of file.

.PARAMETER user
Validate a given SNMPv3 user name exists

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$privhash,
	[string]$authhash,
	[string]$user,
	[boolean]$rawsecret,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.snmp.test){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.snmp.test is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.snmp.test | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.snmp.test.CreateArgs()
				if($PSBoundParameters.ContainsKey('privhash')){
					if($HashTable.containskey('privhash')){
						$HashTable.privhash = $privhash
					}
					Else{
						Write-error "The parameter privhash is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('authhash')){
					if($HashTable.containskey('authhash')){
						$HashTable.authhash = $authhash
					}
					Else{
						Write-error "The parameter authhash is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('user')){
					if($HashTable.containskey('user')){
						$HashTable.user = $user
					}
					Else{
						Write-error "The parameter user is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('rawsecret')){
					if($HashTable.containskey('rawsecret')){
						$HashTable.rawsecret = $rawsecret
					}
					Else{
						Write-error "The parameter rawsecret is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.snmp.test.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('privhash') -or $PSBoundParameters.ContainsKey('authhash') -or $PSBoundParameters.ContainsKey('user') -or $PSBoundParameters.ContainsKey('rawsecret')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.snmp.test.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.system.stats.uptime{
<#
.SYNOPSIS
Disply the number of microseconds the system has been running.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.stats.uptime.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.stats.uptime.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.stats.uptime.get.invoke()
		}
	}
}

function mark-EsxCLI.system.syslog{
<#
.SYNOPSIS
Mark all logs with the specified string

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER message
The message to place in the logs

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$message,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.syslog.mark){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.syslog.mark is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.syslog.mark | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.syslog.mark.CreateArgs()
				if($PSBoundParameters.ContainsKey('message')){
					if($HashTable.containskey('message')){
						$HashTable.message = $message
					}
					Else{
						Write-error "The parameter message is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.syslog.mark.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('message')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.syslog.mark.invoke()
				}
			}
		}
	}
}

function reload-EsxCLI.system.syslog{
<#
.SYNOPSIS
Reload the log daemon to apply any new configuration options

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.syslog.reload){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.syslog.reload is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.syslog.reload.invoke()
		}
	}
}

function get-EsxCLI.system.syslog.config{
<#
.SYNOPSIS
Show the current global configuration values

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.syslog.config.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.syslog.config.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.syslog.config.get.invoke()
		}
	}
}

function set-EsxCLI.system.syslog.config{
<#
.SYNOPSIS
Set global log configuration options

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER checksslcerts
Verify remote SSL certificates against the local CA Store

.PARAMETER defaultrotate
Default number of rotated local logs to keep

.PARAMETER defaultsize
Default size of local logs before rotation, in KiB

.PARAMETER defaulttimeout
Default network retry timeout in seconds if a remote server fails to respond

.PARAMETER droplogrotate
Number of rotated dropped log files to keep

.PARAMETER droplogsize
Size of dropped log file before rotation, in KiB

.PARAMETER logdir
The directory to output local logs to

.PARAMETER logdirunique
Place logs in a unique subdirectory of logdir, based on hostname

.PARAMETER loghost
The remote host(s) to send logs to

.PARAMETER queuedropmark
Message queue capacity after which messages are dropped

.PARAMETER reset
Reset values to default

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[long]$droplogsize,
	[long]$defaultrotate,
	[long]$defaulttimeout,
	[string]$logdir,
	[boolean]$logdirunique,
	[boolean]$checksslcerts,
	[string]$reset,
	[long]$queuedropmark,
	[long]$defaultsize,
	[long]$droplogrotate,
	[string]$loghost,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.syslog.config.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.syslog.config.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.syslog.config.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.syslog.config.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('droplogsize')){
					if($HashTable.containskey('droplogsize')){
						$HashTable.droplogsize = $droplogsize
					}
					Else{
						Write-error "The parameter droplogsize is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('defaultrotate')){
					if($HashTable.containskey('defaultrotate')){
						$HashTable.defaultrotate = $defaultrotate
					}
					Else{
						Write-error "The parameter defaultrotate is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('defaulttimeout')){
					if($HashTable.containskey('defaulttimeout')){
						$HashTable.defaulttimeout = $defaulttimeout
					}
					Else{
						Write-error "The parameter defaulttimeout is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('logdir')){
					if($HashTable.containskey('logdir')){
						$HashTable.logdir = $logdir
					}
					Else{
						Write-error "The parameter logdir is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('logdirunique')){
					if($HashTable.containskey('logdirunique')){
						$HashTable.logdirunique = $logdirunique
					}
					Else{
						Write-error "The parameter logdirunique is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('checksslcerts')){
					if($HashTable.containskey('checksslcerts')){
						$HashTable.checksslcerts = $checksslcerts
					}
					Else{
						Write-error "The parameter checksslcerts is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('reset')){
					if($HashTable.containskey('reset')){
						$HashTable.reset = $reset
					}
					Else{
						Write-error "The parameter reset is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('queuedropmark')){
					if($HashTable.containskey('queuedropmark')){
						$HashTable.queuedropmark = $queuedropmark
					}
					Else{
						Write-error "The parameter queuedropmark is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('defaultsize')){
					if($HashTable.containskey('defaultsize')){
						$HashTable.defaultsize = $defaultsize
					}
					Else{
						Write-error "The parameter defaultsize is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('droplogrotate')){
					if($HashTable.containskey('droplogrotate')){
						$HashTable.droplogrotate = $droplogrotate
					}
					Else{
						Write-error "The parameter droplogrotate is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('loghost')){
					if($HashTable.containskey('loghost')){
						$HashTable.loghost = $loghost
					}
					Else{
						Write-error "The parameter loghost is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.syslog.config.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('droplogsize') -or $PSBoundParameters.ContainsKey('defaultrotate') -or $PSBoundParameters.ContainsKey('defaulttimeout') -or $PSBoundParameters.ContainsKey('logdir') -or $PSBoundParameters.ContainsKey('logdirunique') -or $PSBoundParameters.ContainsKey('checksslcerts') -or $PSBoundParameters.ContainsKey('reset') -or $PSBoundParameters.ContainsKey('queuedropmark') -or $PSBoundParameters.ContainsKey('defaultsize') -or $PSBoundParameters.ContainsKey('droplogrotate') -or $PSBoundParameters.ContainsKey('loghost')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.syslog.config.set.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.system.syslog.config.logger{
<#
.SYNOPSIS
Show the currently configured sub-loggers

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.syslog.config.logger.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.syslog.config.logger.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.syslog.config.logger.list.invoke()
		}
	}
}

function set-EsxCLI.system.syslog.config.logger{
<#
.SYNOPSIS
Set configuration options for a specific sub-logger

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER id
The id of the logger to configure

.PARAMETER reset
Reset values to default

.PARAMETER rotate
Number of rotated logs to keep for a specific logger (requires --id)

.PARAMETER size
Set size of logs before rotation for a specific logger, in KiB (requires --id)

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[long]$rotate,
	[string]$reset,
	[long]$size,
	[Parameter(Mandatory=$true)]
	[string]$id,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.syslog.config.logger.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.syslog.config.logger.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.syslog.config.logger.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.syslog.config.logger.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('rotate')){
					if($HashTable.containskey('rotate')){
						$HashTable.rotate = $rotate
					}
					Else{
						Write-error "The parameter rotate is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('reset')){
					if($HashTable.containskey('reset')){
						$HashTable.reset = $reset
					}
					Else{
						Write-error "The parameter reset is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('size')){
					if($HashTable.containskey('size')){
						$HashTable.size = $size
					}
					Else{
						Write-error "The parameter size is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('id')){
					if($HashTable.containskey('id')){
						$HashTable.id = $id
					}
					Else{
						Write-error "The parameter id is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.syslog.config.logger.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('rotate') -or $PSBoundParameters.ContainsKey('reset') -or $PSBoundParameters.ContainsKey('size') -or $PSBoundParameters.ContainsKey('id')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.syslog.config.logger.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.system.time{
<#
.SYNOPSIS
Disply the current system time.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.time.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.time.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.time.get.invoke()
		}
	}
}

function set-EsxCLI.system.time{
<#
.SYNOPSIS
Set the system clock time. Any missing parameters will default to the current time

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER day
Day

.PARAMETER hour
Hour

.PARAMETER min
Minute

.PARAMETER month
Month

.PARAMETER sec
Second

.PARAMETER year
Year

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[long]$hour,
	[long]$min,
	[long]$month,
	[long]$year,
	[long]$sec,
	[long]$day,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.time.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.time.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.time.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.time.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('hour')){
					if($HashTable.containskey('hour')){
						$HashTable.hour = $hour
					}
					Else{
						Write-error "The parameter hour is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('min')){
					if($HashTable.containskey('min')){
						$HashTable.min = $min
					}
					Else{
						Write-error "The parameter min is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('month')){
					if($HashTable.containskey('month')){
						$HashTable.month = $month
					}
					Else{
						Write-error "The parameter month is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('year')){
					if($HashTable.containskey('year')){
						$HashTable.year = $year
					}
					Else{
						Write-error "The parameter year is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('sec')){
					if($HashTable.containskey('sec')){
						$HashTable.sec = $sec
					}
					Else{
						Write-error "The parameter sec is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('day')){
					if($HashTable.containskey('day')){
						$HashTable.day = $day
					}
					Else{
						Write-error "The parameter day is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.time.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('hour') -or $PSBoundParameters.ContainsKey('min') -or $PSBoundParameters.ContainsKey('month') -or $PSBoundParameters.ContainsKey('year') -or $PSBoundParameters.ContainsKey('sec') -or $PSBoundParameters.ContainsKey('day')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.time.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.system.uuid{
<#
.SYNOPSIS
Get the system UUID.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.uuid.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.uuid.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.uuid.get.invoke()
		}
	}
}

function get-EsxCLI.system.version{
<#
.SYNOPSIS
Display the product name, version and build information.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.version.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.version.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.version.get.invoke()
		}
	}
}

function get-EsxCLI.system.visorfs{
<#
.SYNOPSIS
Obtain status information on the memory filesystem as a whole.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.visorfs.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.visorfs.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.visorfs.get.invoke()
		}
	}
}

function add-EsxCLI.system.visorfs.ramdisk{
<#
.SYNOPSIS
Add a new Visorfs RAM disk to the ESXi Host and mount it.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER maxsize
Maximum size (max reservation in MiB)

.PARAMETER minsize
Minimum size (min reservation in MiB)

.PARAMETER name
Name for the ramdisk

.PARAMETER permissions
Permissions for the root of the ramdisk (mode)

.PARAMETER target
Mountpoint for the ramdisk (absolute path)

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[long]$maxsize,
	[Parameter(Mandatory=$true)]
	[string]$name,
	[Parameter(Mandatory=$true)]
	[string]$target,
	[Parameter(Mandatory=$true)]
	[string]$permissions,
	[Parameter(Mandatory=$true)]
	[long]$minsize,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.visorfs.ramdisk.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.visorfs.ramdisk.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.visorfs.ramdisk.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.visorfs.ramdisk.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('maxsize')){
					if($HashTable.containskey('maxsize')){
						$HashTable.maxsize = $maxsize
					}
					Else{
						Write-error "The parameter maxsize is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('name')){
					if($HashTable.containskey('name')){
						$HashTable.name = $name
					}
					Else{
						Write-error "The parameter name is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('target')){
					if($HashTable.containskey('target')){
						$HashTable.target = $target
					}
					Else{
						Write-error "The parameter target is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('permissions')){
					if($HashTable.containskey('permissions')){
						$HashTable.permissions = $permissions
					}
					Else{
						Write-error "The parameter permissions is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('minsize')){
					if($HashTable.containskey('minsize')){
						$HashTable.minsize = $minsize
					}
					Else{
						Write-error "The parameter minsize is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.visorfs.ramdisk.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('maxsize') -or $PSBoundParameters.ContainsKey('name') -or $PSBoundParameters.ContainsKey('target') -or $PSBoundParameters.ContainsKey('permissions') -or $PSBoundParameters.ContainsKey('minsize')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.visorfs.ramdisk.add.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.system.visorfs.ramdisk{
<#
.SYNOPSIS
List the RAM disks used by the host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.visorfs.ramdisk.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.visorfs.ramdisk.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.visorfs.ramdisk.list.invoke()
		}
	}
}

function remove-EsxCLI.system.visorfs.ramdisk{
<#
.SYNOPSIS
Remove a Visorfs RAM disk from the ESXi Host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER target
Mountpoint for the ramdisk (absolute path)

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$target,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.visorfs.ramdisk.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.visorfs.ramdisk.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.visorfs.ramdisk.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.visorfs.ramdisk.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('target')){
					if($HashTable.containskey('target')){
						$HashTable.target = $target
					}
					Else{
						Write-error "The parameter target is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.visorfs.ramdisk.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('target')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.visorfs.ramdisk.remove.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.system.visorfs.tardisk{
<#
.SYNOPSIS
List the tardisks used by the host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.visorfs.tardisk.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.visorfs.tardisk.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.visorfs.tardisk.list.invoke()
		}
	}
}

function get-EsxCLI.system.welcomemsg{
<#
.SYNOPSIS
Get the Welcome Message for DCUI.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.welcomemsg.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.welcomemsg.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.system.welcomemsg.get.invoke()
		}
	}
}

function set-EsxCLI.system.welcomemsg{
<#
.SYNOPSIS
Set the Welcome Message for DCUI.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER message
Welcome Message String.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$message,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.system.welcomemsg.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.system.welcomemsg.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.system.welcomemsg.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.system.welcomemsg.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('message')){
					if($HashTable.containskey('message')){
						$HashTable.message = $message
					}
					Else{
						Write-error "The parameter message is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.system.welcomemsg.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('message')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.system.welcomemsg.set.invoke()
				}
			}
		}
	}
}

function kill-EsxCLI.vm.process{
<#
.SYNOPSIS
Used to forcibly kill Virtual Machines that are stuck and not responding to normal stop operations.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER type
The type of kill operation to attempt. There are three types of VM kills that can be attempted:   [soft, hard, force]. Users should always attempt 'soft' kills first, which will give the VMX process a chance to shutdown cleanly (like kill or kill -SIGTERM). If that does not work move to 'hard' kills which will shutdown the process immediately (like kill -9 or kill -SIGKILL). 'force' should be used as a last resort attempt to kill the VM. If all three fail then a reboot is required.

.PARAMETER worldid
The World ID of the Virtual Machine to kill. This can be obtained from the 'vm process list' command

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$type,
	[Parameter(Mandatory=$true)]
	[long]$worldid,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vm.process.kill){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vm.process.kill is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.vm.process.kill | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.vm.process.kill.CreateArgs()
				if($PSBoundParameters.ContainsKey('type')){
					if($HashTable.containskey('type')){
						$HashTable.type = $type
					}
					Else{
						Write-error "The parameter type is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('worldid')){
					if($HashTable.containskey('worldid')){
						$HashTable.worldid = $worldid
					}
					Else{
						Write-error "The parameter worldid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.vm.process.kill.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('type') -or $PSBoundParameters.ContainsKey('worldid')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.vm.process.kill.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.vm.process{
<#
.SYNOPSIS
List the virtual machines on this system. This command currently will only list running VMs on the system.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vm.process.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vm.process.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.vm.process.list.invoke()
		}
	}
}

function get-EsxCLI.vsan.cluster{
<#
.SYNOPSIS
Get information about the Virtual SAN cluster that this host is joined to.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.cluster.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.cluster.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.vsan.cluster.get.invoke()
		}
	}
}

function join-EsxCLI.vsan.cluster{
<#
.SYNOPSIS
Join the host to a Virtual SAN cluster.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER clusteruuid
Virtual SAN cluster UUID of the cluster instance which the host will join, or create, in the form "nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn" where n are hexadecimal digits.

.PARAMETER wait
Wait until the host joins the cluster.

.PARAMETER witnessnode
Join the host as a witness node to the cluster. It is required to specify "--witness-preferred-fault-domain" when this parameter is set.

.PARAMETER witnesspreferredfaultdomain
Specify the fault domain that witness node prefers to respond in case of network partition. It should be either of the two fault domains for existing data sites. This parameter is useful only when "--witness-node" is set.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$wait,
	[Parameter(Mandatory=$true)]
	[string]$clusteruuid,
	[string]$witnesspreferredfaultdomain,
	[boolean]$witnessnode,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.cluster.join){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.cluster.join is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.vsan.cluster.join | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.vsan.cluster.join.CreateArgs()
				if($PSBoundParameters.ContainsKey('wait')){
					if($HashTable.containskey('wait')){
						$HashTable.wait = $wait
					}
					Else{
						Write-error "The parameter wait is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('clusteruuid')){
					if($HashTable.containskey('clusteruuid')){
						$HashTable.clusteruuid = $clusteruuid
					}
					Else{
						Write-error "The parameter clusteruuid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('witnesspreferredfaultdomain')){
					if($HashTable.containskey('witnesspreferredfaultdomain')){
						$HashTable.witnesspreferredfaultdomain = $witnesspreferredfaultdomain
					}
					Else{
						Write-error "The parameter witnesspreferredfaultdomain is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('witnessnode')){
					if($HashTable.containskey('witnessnode')){
						$HashTable.witnessnode = $witnessnode
					}
					Else{
						Write-error "The parameter witnessnode is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.vsan.cluster.join.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('wait') -or $PSBoundParameters.ContainsKey('clusteruuid') -or $PSBoundParameters.ContainsKey('witnesspreferredfaultdomain') -or $PSBoundParameters.ContainsKey('witnessnode')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.vsan.cluster.join.invoke()
				}
			}
		}
	}
}

function leave-EsxCLI.vsan.cluster{
<#
.SYNOPSIS
Leave the Virtual SAN cluster the host is currently joined to.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.cluster.leave){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.cluster.leave is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.vsan.cluster.leave.invoke()
		}
	}
}

function new-EsxCLI.vsan.cluster{
<#
.SYNOPSIS
Create a Virtual SAN cluster with current host joined. A random sub-cluster UUID will be generated.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.cluster.new){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.cluster.new is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.vsan.cluster.new.invoke()
		}
	}
}

function restore-EsxCLI.vsan.cluster{
<#
.SYNOPSIS
Restore the persisted Virtual SAN cluster configuration.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER boot
Set when restoring the cluster during boot (internal only!)

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$boot,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.cluster.restore){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.cluster.restore is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.vsan.cluster.restore | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.vsan.cluster.restore.CreateArgs()
				if($PSBoundParameters.ContainsKey('boot')){
					if($HashTable.containskey('boot')){
						$HashTable.boot = $boot
					}
					Else{
						Write-error "The parameter boot is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.vsan.cluster.restore.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('boot')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.vsan.cluster.restore.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.vsan.cluster.preferredfaultdomain{
<#
.SYNOPSIS
Get the preferred fault domain for a stretched cluster.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.cluster.preferredfaultdomain.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.cluster.preferredfaultdomain.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.vsan.cluster.preferredfaultdomain.get.invoke()
		}
	}
}

function set-EsxCLI.vsan.cluster.preferredfaultdomain{
<#
.SYNOPSIS
Set the preferred fault domain for a stretched cluster.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER preferredfaultdomainname
Preferred Fault domain name to use for a stretched cluster.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$preferredfaultdomainname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.cluster.preferredfaultdomain.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.cluster.preferredfaultdomain.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.vsan.cluster.preferredfaultdomain.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.vsan.cluster.preferredfaultdomain.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('preferredfaultdomainname')){
					if($HashTable.containskey('preferredfaultdomainname')){
						$HashTable.preferredfaultdomainname = $preferredfaultdomainname
					}
					Else{
						Write-error "The parameter preferredfaultdomainname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.vsan.cluster.preferredfaultdomain.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('preferredfaultdomainname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.vsan.cluster.preferredfaultdomain.set.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.vsan.cluster.unicastagent{
<#
.SYNOPSIS
Add a unicast agent to the Virtual SAN cluster configuration.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER addr
IP address of the unicast agent.

.PARAMETER boundinterfacename
Name of the bound outgoing network interface.

.PARAMETER port
Port the unicast agent is listening on.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$addr,
	[string]$boundinterfacename,
	[long]$port,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.cluster.unicastagent.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.cluster.unicastagent.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.vsan.cluster.unicastagent.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.vsan.cluster.unicastagent.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('addr')){
					if($HashTable.containskey('addr')){
						$HashTable.addr = $addr
					}
					Else{
						Write-error "The parameter addr is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('boundinterfacename')){
					if($HashTable.containskey('boundinterfacename')){
						$HashTable.boundinterfacename = $boundinterfacename
					}
					Else{
						Write-error "The parameter boundinterfacename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('port')){
					if($HashTable.containskey('port')){
						$HashTable.port = $port
					}
					Else{
						Write-error "The parameter port is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.vsan.cluster.unicastagent.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('addr') -or $PSBoundParameters.ContainsKey('boundinterfacename') -or $PSBoundParameters.ContainsKey('port')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.vsan.cluster.unicastagent.add.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.vsan.cluster.unicastagent{
<#
.SYNOPSIS
List all unicast agents in the Virtual SAN cluster configuration.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.cluster.unicastagent.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.cluster.unicastagent.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.vsan.cluster.unicastagent.list.invoke()
		}
	}
}

function remove-EsxCLI.vsan.cluster.unicastagent{
<#
.SYNOPSIS
Remove a unicast agent from the Virtual SAN cluster configuration.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER addr
IP address of the unicast agent.

.PARAMETER port
Port the unicast agent is listening on.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[long]$port,
	[Parameter(Mandatory=$true)]
	[string]$addr,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.cluster.unicastagent.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.cluster.unicastagent.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.vsan.cluster.unicastagent.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.vsan.cluster.unicastagent.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('port')){
					if($HashTable.containskey('port')){
						$HashTable.port = $port
					}
					Else{
						Write-error "The parameter port is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('addr')){
					if($HashTable.containskey('addr')){
						$HashTable.addr = $addr
					}
					Else{
						Write-error "The parameter addr is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.vsan.cluster.unicastagent.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('port') -or $PSBoundParameters.ContainsKey('addr')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.vsan.cluster.unicastagent.remove.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.vsan.datastore.name{
<#
.SYNOPSIS
Get VSAN datastore name.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.datastore.name.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.datastore.name.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.vsan.datastore.name.get.invoke()
		}
	}
}

function set-EsxCLI.vsan.datastore.name{
<#
.SYNOPSIS
Configure VSAN datastore name. In general, Rename should always be done at cluster level. Across a VSAN cluster VSAN datastore name should be in sync.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER newname
Set VSAN datastore name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$newname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.datastore.name.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.datastore.name.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.vsan.datastore.name.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.vsan.datastore.name.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('newname')){
					if($HashTable.containskey('newname')){
						$HashTable.newname = $newname
					}
					Else{
						Write-error "The parameter newname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.vsan.datastore.name.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('newname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.vsan.datastore.name.set.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.vsan.faultdomain{
<#
.SYNOPSIS
Get the fault domain name for this host.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.faultdomain.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.faultdomain.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.vsan.faultdomain.get.invoke()
		}
	}
}

function reset-EsxCLI.vsan.faultdomain{
<#
.SYNOPSIS
Reset Host fault domain to default value

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.faultdomain.reset){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.faultdomain.reset is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.vsan.faultdomain.reset.invoke()
		}
	}
}

function set-EsxCLI.vsan.faultdomain{
<#
.SYNOPSIS
Set the fault domain for this host

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER fdname
Fault domain name to use for this host. Empty string means reset to default.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$fdname,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.faultdomain.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.faultdomain.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.vsan.faultdomain.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.vsan.faultdomain.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('fdname')){
					if($HashTable.containskey('fdname')){
						$HashTable.fdname = $fdname
					}
					Else{
						Write-error "The parameter fdname is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.vsan.faultdomain.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('fdname')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.vsan.faultdomain.set.invoke()
				}
			}
		}
	}
}

function cancel-EsxCLI.vsan.maintenancemode{
<#
.SYNOPSIS
Cancel an in-progress VSAN maintenance mode operation.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.maintenancemode.cancel){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.maintenancemode.cancel is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.vsan.maintenancemode.cancel.invoke()
		}
	}
}

function clear-EsxCLI.vsan.network{
<#
.SYNOPSIS
Clear the VSAN network configuration.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.network.clear){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.network.clear is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.vsan.network.clear.invoke()
		}
	}
}

function list-EsxCLI.vsan.network{
<#
.SYNOPSIS
List the network configuration currently in use by VSAN.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.network.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.network.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.vsan.network.list.invoke()
		}
	}
}

function remove-EsxCLI.vsan.network{
<#
.SYNOPSIS
Remove an interface from the VSAN network configuration.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER force
Notify VSAN subsystem of removal, even if not configured.

.PARAMETER interfacename
Interface name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$interfacename,
	[boolean]$force,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.network.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.network.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.vsan.network.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.vsan.network.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('interfacename')){
					if($HashTable.containskey('interfacename')){
						$HashTable.interfacename = $interfacename
					}
					Else{
						Write-error "The parameter interfacename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('force')){
					if($HashTable.containskey('force')){
						$HashTable.force = $force
					}
					Else{
						Write-error "The parameter force is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.vsan.network.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('interfacename') -or $PSBoundParameters.ContainsKey('force')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.vsan.network.remove.invoke()
				}
			}
		}
	}
}

function restore-EsxCLI.vsan.network{
<#
.SYNOPSIS
Restore the persisted VSAN network configuration.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.network.restore){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.network.restore is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.vsan.network.restore.invoke()
		}
	}
}

function add-EsxCLI.vsan.network.ip{
<#
.SYNOPSIS
Add an IP interface to the VSAN network configuration.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER agentmcaddr
IPv4 multicast address for agent (also called downstream) group.

.PARAMETER agentmcport
Multicast address port for agent (also called downstream) group.

.PARAMETER agentv6mcaddr
IPv6 multicast address for agent (also called downstream) group.

.PARAMETER hostucport
Unicast address port for host unicast channel.

.PARAMETER interfacename
Interface name.

.PARAMETER mastermcaddr
IPv4 multicast address for master (also called upstream) group.

.PARAMETER mastermcport
Multicast address port for master (also called upstream) group.

.PARAMETER masterv6mcaddr
IPv6 multicast address for master (also called upstream) group.

.PARAMETER multicastttl
Time-to-live for multicast packets.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$interfacename,
	[string]$agentmcaddr,
	[string]$agentv6mcaddr,
	[string]$mastermcaddr,
	[long]$mastermcport,
	[long]$hostucport,
	[string]$masterv6mcaddr,
	[long]$multicastttl,
	[long]$agentmcport,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.network.ip.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.network.ip.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.vsan.network.ip.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.vsan.network.ip.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('interfacename')){
					if($HashTable.containskey('interfacename')){
						$HashTable.interfacename = $interfacename
					}
					Else{
						Write-error "The parameter interfacename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('agentmcaddr')){
					if($HashTable.containskey('agentmcaddr')){
						$HashTable.agentmcaddr = $agentmcaddr
					}
					Else{
						Write-error "The parameter agentmcaddr is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('agentv6mcaddr')){
					if($HashTable.containskey('agentv6mcaddr')){
						$HashTable.agentv6mcaddr = $agentv6mcaddr
					}
					Else{
						Write-error "The parameter agentv6mcaddr is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('mastermcaddr')){
					if($HashTable.containskey('mastermcaddr')){
						$HashTable.mastermcaddr = $mastermcaddr
					}
					Else{
						Write-error "The parameter mastermcaddr is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('mastermcport')){
					if($HashTable.containskey('mastermcport')){
						$HashTable.mastermcport = $mastermcport
					}
					Else{
						Write-error "The parameter mastermcport is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('hostucport')){
					if($HashTable.containskey('hostucport')){
						$HashTable.hostucport = $hostucport
					}
					Else{
						Write-error "The parameter hostucport is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('masterv6mcaddr')){
					if($HashTable.containskey('masterv6mcaddr')){
						$HashTable.masterv6mcaddr = $masterv6mcaddr
					}
					Else{
						Write-error "The parameter masterv6mcaddr is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('multicastttl')){
					if($HashTable.containskey('multicastttl')){
						$HashTable.multicastttl = $multicastttl
					}
					Else{
						Write-error "The parameter multicastttl is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('agentmcport')){
					if($HashTable.containskey('agentmcport')){
						$HashTable.agentmcport = $agentmcport
					}
					Else{
						Write-error "The parameter agentmcport is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.vsan.network.ip.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('interfacename') -or $PSBoundParameters.ContainsKey('agentmcaddr') -or $PSBoundParameters.ContainsKey('agentv6mcaddr') -or $PSBoundParameters.ContainsKey('mastermcaddr') -or $PSBoundParameters.ContainsKey('mastermcport') -or $PSBoundParameters.ContainsKey('hostucport') -or $PSBoundParameters.ContainsKey('masterv6mcaddr') -or $PSBoundParameters.ContainsKey('multicastttl') -or $PSBoundParameters.ContainsKey('agentmcport')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.vsan.network.ip.add.invoke()
				}
			}
		}
	}
}

function remove-EsxCLI.vsan.network.ip{
<#
.SYNOPSIS
Remove an IP interface from the VSAN network configuration.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER force
Notify VSAN subsystem of removal, even if not configured.

.PARAMETER interfacename
Interface name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$interfacename,
	[boolean]$force,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.network.ip.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.network.ip.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.vsan.network.ip.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.vsan.network.ip.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('interfacename')){
					if($HashTable.containskey('interfacename')){
						$HashTable.interfacename = $interfacename
					}
					Else{
						Write-error "The parameter interfacename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('force')){
					if($HashTable.containskey('force')){
						$HashTable.force = $force
					}
					Else{
						Write-error "The parameter force is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.vsan.network.ip.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('interfacename') -or $PSBoundParameters.ContainsKey('force')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.vsan.network.ip.remove.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.vsan.network.ip{
<#
.SYNOPSIS
Reconfigure an IP interface in the VSAN network configuration.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER agentmcaddr
IPv4 multicast address for agent (also called downstream) group.

.PARAMETER agentmcport
Multicast address port for agent (also called downstream) group.

.PARAMETER agentv6mcaddr
IPv6 multicast address for agent (also called downstream) group.

.PARAMETER hostucport
Unicast address port for host unicast channel.

.PARAMETER interfacename
Interface name.

.PARAMETER mastermcaddr
IPv4 multicast address for master (also called upstream) group.

.PARAMETER mastermcport
Multicast address port for master (also called upstream) group.

.PARAMETER masterv6mcaddr
IPv6 multicast address for master (also called upstream) group.

.PARAMETER multicastttl
Time-to-live for multicast packets.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$interfacename,
	[string]$agentmcaddr,
	[string]$agentv6mcaddr,
	[string]$mastermcaddr,
	[long]$mastermcport,
	[long]$hostucport,
	[string]$masterv6mcaddr,
	[long]$multicastttl,
	[long]$agentmcport,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.network.ip.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.network.ip.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.vsan.network.ip.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.vsan.network.ip.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('interfacename')){
					if($HashTable.containskey('interfacename')){
						$HashTable.interfacename = $interfacename
					}
					Else{
						Write-error "The parameter interfacename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('agentmcaddr')){
					if($HashTable.containskey('agentmcaddr')){
						$HashTable.agentmcaddr = $agentmcaddr
					}
					Else{
						Write-error "The parameter agentmcaddr is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('agentv6mcaddr')){
					if($HashTable.containskey('agentv6mcaddr')){
						$HashTable.agentv6mcaddr = $agentv6mcaddr
					}
					Else{
						Write-error "The parameter agentv6mcaddr is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('mastermcaddr')){
					if($HashTable.containskey('mastermcaddr')){
						$HashTable.mastermcaddr = $mastermcaddr
					}
					Else{
						Write-error "The parameter mastermcaddr is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('mastermcport')){
					if($HashTable.containskey('mastermcport')){
						$HashTable.mastermcport = $mastermcport
					}
					Else{
						Write-error "The parameter mastermcport is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('hostucport')){
					if($HashTable.containskey('hostucport')){
						$HashTable.hostucport = $hostucport
					}
					Else{
						Write-error "The parameter hostucport is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('masterv6mcaddr')){
					if($HashTable.containskey('masterv6mcaddr')){
						$HashTable.masterv6mcaddr = $masterv6mcaddr
					}
					Else{
						Write-error "The parameter masterv6mcaddr is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('multicastttl')){
					if($HashTable.containskey('multicastttl')){
						$HashTable.multicastttl = $multicastttl
					}
					Else{
						Write-error "The parameter multicastttl is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('agentmcport')){
					if($HashTable.containskey('agentmcport')){
						$HashTable.agentmcport = $agentmcport
					}
					Else{
						Write-error "The parameter agentmcport is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.vsan.network.ip.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('interfacename') -or $PSBoundParameters.ContainsKey('agentmcaddr') -or $PSBoundParameters.ContainsKey('agentv6mcaddr') -or $PSBoundParameters.ContainsKey('mastermcaddr') -or $PSBoundParameters.ContainsKey('mastermcport') -or $PSBoundParameters.ContainsKey('hostucport') -or $PSBoundParameters.ContainsKey('masterv6mcaddr') -or $PSBoundParameters.ContainsKey('multicastttl') -or $PSBoundParameters.ContainsKey('agentmcport')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.vsan.network.ip.set.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.vsan.network.ipv4{
<#
.SYNOPSIS
Add an IP interface to the VSAN network configuration.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER agentmcaddr
IPv4 multicast address for agent (also called downstream) group.

.PARAMETER agentmcport
Multicast address port for agent (also called downstream) group.

.PARAMETER agentv6mcaddr
IPv6 multicast address for agent (also called downstream) group.

.PARAMETER hostucport
Unicast address port for host unicast channel.

.PARAMETER interfacename
Interface name.

.PARAMETER mastermcaddr
IPv4 multicast address for master (also called upstream) group.

.PARAMETER mastermcport
Multicast address port for master (also called upstream) group.

.PARAMETER masterv6mcaddr
IPv6 multicast address for master (also called upstream) group.

.PARAMETER multicastttl
Time-to-live for multicast packets.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$interfacename,
	[string]$agentmcaddr,
	[string]$agentv6mcaddr,
	[string]$mastermcaddr,
	[long]$mastermcport,
	[long]$hostucport,
	[string]$masterv6mcaddr,
	[long]$multicastttl,
	[long]$agentmcport,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.network.ipv4.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.network.ipv4.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.vsan.network.ipv4.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.vsan.network.ipv4.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('interfacename')){
					if($HashTable.containskey('interfacename')){
						$HashTable.interfacename = $interfacename
					}
					Else{
						Write-error "The parameter interfacename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('agentmcaddr')){
					if($HashTable.containskey('agentmcaddr')){
						$HashTable.agentmcaddr = $agentmcaddr
					}
					Else{
						Write-error "The parameter agentmcaddr is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('agentv6mcaddr')){
					if($HashTable.containskey('agentv6mcaddr')){
						$HashTable.agentv6mcaddr = $agentv6mcaddr
					}
					Else{
						Write-error "The parameter agentv6mcaddr is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('mastermcaddr')){
					if($HashTable.containskey('mastermcaddr')){
						$HashTable.mastermcaddr = $mastermcaddr
					}
					Else{
						Write-error "The parameter mastermcaddr is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('mastermcport')){
					if($HashTable.containskey('mastermcport')){
						$HashTable.mastermcport = $mastermcport
					}
					Else{
						Write-error "The parameter mastermcport is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('hostucport')){
					if($HashTable.containskey('hostucport')){
						$HashTable.hostucport = $hostucport
					}
					Else{
						Write-error "The parameter hostucport is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('masterv6mcaddr')){
					if($HashTable.containskey('masterv6mcaddr')){
						$HashTable.masterv6mcaddr = $masterv6mcaddr
					}
					Else{
						Write-error "The parameter masterv6mcaddr is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('multicastttl')){
					if($HashTable.containskey('multicastttl')){
						$HashTable.multicastttl = $multicastttl
					}
					Else{
						Write-error "The parameter multicastttl is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('agentmcport')){
					if($HashTable.containskey('agentmcport')){
						$HashTable.agentmcport = $agentmcport
					}
					Else{
						Write-error "The parameter agentmcport is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.vsan.network.ipv4.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('interfacename') -or $PSBoundParameters.ContainsKey('agentmcaddr') -or $PSBoundParameters.ContainsKey('agentv6mcaddr') -or $PSBoundParameters.ContainsKey('mastermcaddr') -or $PSBoundParameters.ContainsKey('mastermcport') -or $PSBoundParameters.ContainsKey('hostucport') -or $PSBoundParameters.ContainsKey('masterv6mcaddr') -or $PSBoundParameters.ContainsKey('multicastttl') -or $PSBoundParameters.ContainsKey('agentmcport')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.vsan.network.ipv4.add.invoke()
				}
			}
		}
	}
}

function remove-EsxCLI.vsan.network.ipv4{
<#
.SYNOPSIS
Remove an IP interface from the VSAN network configuration.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER force
Notify VSAN subsystem of removal, even if not configured.

.PARAMETER interfacename
Interface name.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$interfacename,
	[boolean]$force,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.network.ipv4.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.network.ipv4.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.vsan.network.ipv4.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.vsan.network.ipv4.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('interfacename')){
					if($HashTable.containskey('interfacename')){
						$HashTable.interfacename = $interfacename
					}
					Else{
						Write-error "The parameter interfacename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('force')){
					if($HashTable.containskey('force')){
						$HashTable.force = $force
					}
					Else{
						Write-error "The parameter force is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.vsan.network.ipv4.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('interfacename') -or $PSBoundParameters.ContainsKey('force')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.vsan.network.ipv4.remove.invoke()
				}
			}
		}
	}
}

function set-EsxCLI.vsan.network.ipv4{
<#
.SYNOPSIS
Reconfigure an IP interface in the VSAN network configuration.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER agentmcaddr
IPv4 multicast address for agent (also called downstream) group.

.PARAMETER agentmcport
Multicast address port for agent (also called downstream) group.

.PARAMETER agentv6mcaddr
IPv6 multicast address for agent (also called downstream) group.

.PARAMETER hostucport
Unicast address port for host unicast channel.

.PARAMETER interfacename
Interface name.

.PARAMETER mastermcaddr
IPv4 multicast address for master (also called upstream) group.

.PARAMETER mastermcport
Multicast address port for master (also called upstream) group.

.PARAMETER masterv6mcaddr
IPv6 multicast address for master (also called upstream) group.

.PARAMETER multicastttl
Time-to-live for multicast packets.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$interfacename,
	[string]$agentmcaddr,
	[string]$agentv6mcaddr,
	[string]$mastermcaddr,
	[long]$mastermcport,
	[long]$hostucport,
	[string]$masterv6mcaddr,
	[long]$multicastttl,
	[long]$agentmcport,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.network.ipv4.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.network.ipv4.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.vsan.network.ipv4.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.vsan.network.ipv4.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('interfacename')){
					if($HashTable.containskey('interfacename')){
						$HashTable.interfacename = $interfacename
					}
					Else{
						Write-error "The parameter interfacename is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('agentmcaddr')){
					if($HashTable.containskey('agentmcaddr')){
						$HashTable.agentmcaddr = $agentmcaddr
					}
					Else{
						Write-error "The parameter agentmcaddr is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('agentv6mcaddr')){
					if($HashTable.containskey('agentv6mcaddr')){
						$HashTable.agentv6mcaddr = $agentv6mcaddr
					}
					Else{
						Write-error "The parameter agentv6mcaddr is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('mastermcaddr')){
					if($HashTable.containskey('mastermcaddr')){
						$HashTable.mastermcaddr = $mastermcaddr
					}
					Else{
						Write-error "The parameter mastermcaddr is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('mastermcport')){
					if($HashTable.containskey('mastermcport')){
						$HashTable.mastermcport = $mastermcport
					}
					Else{
						Write-error "The parameter mastermcport is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('hostucport')){
					if($HashTable.containskey('hostucport')){
						$HashTable.hostucport = $hostucport
					}
					Else{
						Write-error "The parameter hostucport is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('masterv6mcaddr')){
					if($HashTable.containskey('masterv6mcaddr')){
						$HashTable.masterv6mcaddr = $masterv6mcaddr
					}
					Else{
						Write-error "The parameter masterv6mcaddr is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('multicastttl')){
					if($HashTable.containskey('multicastttl')){
						$HashTable.multicastttl = $multicastttl
					}
					Else{
						Write-error "The parameter multicastttl is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('agentmcport')){
					if($HashTable.containskey('agentmcport')){
						$HashTable.agentmcport = $agentmcport
					}
					Else{
						Write-error "The parameter agentmcport is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.vsan.network.ipv4.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('interfacename') -or $PSBoundParameters.ContainsKey('agentmcaddr') -or $PSBoundParameters.ContainsKey('agentv6mcaddr') -or $PSBoundParameters.ContainsKey('mastermcaddr') -or $PSBoundParameters.ContainsKey('mastermcport') -or $PSBoundParameters.ContainsKey('hostucport') -or $PSBoundParameters.ContainsKey('masterv6mcaddr') -or $PSBoundParameters.ContainsKey('multicastttl') -or $PSBoundParameters.ContainsKey('agentmcport')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.vsan.network.ipv4.set.invoke()
				}
			}
		}
	}
}

function cleardefault-EsxCLI.vsan.policy{
<#
.SYNOPSIS
Clear default VSAN storage policy values.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.policy.cleardefault){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.policy.cleardefault is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.vsan.policy.cleardefault.invoke()
		}
	}
}

function getdefault-EsxCLI.vsan.policy{
<#
.SYNOPSIS
Get default VSAN storage policy values.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER policyclass
VSAN policy class whose default value to get. If not provided, defaults for all classes will be retrieved. Options are:  [cluster, vdisk, vmnamespace, vmswap, vmem].

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$policyclass,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.policy.getdefault){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.policy.getdefault is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.vsan.policy.getdefault | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.vsan.policy.getdefault.CreateArgs()
				if($PSBoundParameters.ContainsKey('policyclass')){
					if($HashTable.containskey('policyclass')){
						$HashTable.policyclass = $policyclass
					}
					Else{
						Write-error "The parameter policyclass is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.vsan.policy.getdefault.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('policyclass')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.vsan.policy.getdefault.invoke()
				}
			}
		}
	}
}

function setdefault-EsxCLI.vsan.policy{
<#
.SYNOPSIS
Set default VSAN storage policy values.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER policy
VSAN policy to set as default, in the form of a string. Options are: 
1)cacheReservation - Flash capacity reserved as read cache for the storage object. Specified as a percentage of the logical size of the object. To be used only for addressing read performance issues. Reserved flash capacity cannot be used by other objects. Unreserved flash is shared fairly among all objects. It is specified in parts per million.
Default value: 0, Maximum value: 1000000.
2)forceProvisioning - If this option is "1" the object will be provisioned even if the policy specified in the storage policy is not satisfiable with the resources currently available in the cluster. Virtual SAN will try to bring the object into compliance if and when resources become available.
Default value: 0.
3)hostFailuresToTolerate - Defines the number of host, disk, or network failures a storage object can tolerate. When the fault tolerance method is mirroring: to tolerate "n" failures, "n+1" copies of the object are created and "2n+1" hosts contributing storage are required (if fault domains are configured, "2n+1" fault domains with hosts contributing storage are required). When the fault tolerance method is erasure coding: to tolerate 1 failure, 4 hosts (or fault domains) are required; and to tolerate 2 failures, 6 hosts (or fault domains) are required.
Note: A host which is not part of a fault domain is counted as its own single-host fault domain.
Default value: 1, Maximum value: 3.
4)stripeWidth - The number of HDDs across which each replica of storage object is striped. A value higher than 1 may result in better performance (for e.g when flash read cache misses need to get serviced from HDD), but also results in higher used of system resources.
Default value: 1, Maximum value: 12.
5)proportionalCapacity - Percentage of the logical size of the storage object that will be reserved (thick provisioning) upon VM provisioning. The rest of the storage object is thin provisioned.
Default value: 0%, Maximum value: 100%.
6)iopsLimit - Defines upper IOPS limit for a disk. IO rate that has been serviced on a disk will be measured and if the rate exceeds the IOPS limit, IO will be delayed to keep it under the limit. Zero value means no limit.
Default value: 0.
7)replicaPreference - Defines the method used to tolerate failures. RAID-1 achieves failure tolerance using mirrors, which provides better performance. RAID-5/6 achieves failure tolerance using parity blocks, which provides better space efficiency. RAID-5/6 is only available on All-flash and when the number of failures to tolerate is set to 1 or 2: a value of 1 implies a RAID-5 configuration, and a value of 2 implies a RAID-6 configuration.
Default value: RAID-1.

.PARAMETER policyclass
VSAN policy class whose default value to set. Options are:  [cluster, vdisk, vmnamespace, vmswap, vmem].

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$policy,
	[Parameter(Mandatory=$true)]
	[string]$policyclass,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.policy.setdefault){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.policy.setdefault is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.vsan.policy.setdefault | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.vsan.policy.setdefault.CreateArgs()
				if($PSBoundParameters.ContainsKey('policy')){
					if($HashTable.containskey('policy')){
						$HashTable.policy = $policy
					}
					Else{
						Write-error "The parameter policy is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('policyclass')){
					if($HashTable.containskey('policyclass')){
						$HashTable.policyclass = $policyclass
					}
					Else{
						Write-error "The parameter policyclass is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.vsan.policy.setdefault.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('policy') -or $PSBoundParameters.ContainsKey('policyclass')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.vsan.policy.setdefault.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.vsan.storage{
<#
.SYNOPSIS
Add physical disk for VSAN usage.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER disks
Specify hdds to add for use by VSAN. Expects an empty disk with no partitions in which case the disk will be partitioned and formatted. Otherwise this operation will fail. The command expects the device name for the disk to be provided, e.g.: mpx.vmhba2:C0:T1:L0. Multiple hdds can be provided using format -d hdd1 -d hdd2 -d hdd3

.PARAMETER ssd
Specify ssd to add for use by VSAN. Expects an empty ssd with no partitions in which case the ssd will be partitioned and formatted. Otherwise this operation will fail. If an ssd which is already added for use by VSAN, is provided along with '-d/--disks', then the disk mentioned with '-d' will be added to the existing diskgroup created under this ssd and in which case, the ssd won't be partitioned and formatted. The command expects the device name for the disk to be provided, e.g.: mpx.vmhba2:C0:T1:L0

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$ssd,
	[Parameter(Mandatory=$true)]
	[string[]]$disks,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.storage.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.storage.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.vsan.storage.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.vsan.storage.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('ssd')){
					if($HashTable.containskey('ssd')){
						$HashTable.ssd = $ssd
					}
					Else{
						Write-error "The parameter ssd is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('disks')){
					if($HashTable.containskey('disks')){
						$HashTable.disks = $disks
					}
					Else{
						Write-error "The parameter disks is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.vsan.storage.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('ssd') -or $PSBoundParameters.ContainsKey('disks')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.vsan.storage.add.invoke()
				}
			}
		}
	}
}

function list-EsxCLI.vsan.storage{
<#
.SYNOPSIS
List VSAN storage configuration.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER device
Filter the output of this command to only show a single device with specified device name.

.PARAMETER uuid
Filter the output of this command to only show a single device with specified uuid.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$uuid,
	[string]$device,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.storage.list){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.storage.list is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.vsan.storage.list | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.vsan.storage.list.CreateArgs()
				if($PSBoundParameters.ContainsKey('uuid')){
					if($HashTable.containskey('uuid')){
						$HashTable.uuid = $uuid
					}
					Else{
						Write-error "The parameter uuid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('device')){
					if($HashTable.containskey('device')){
						$HashTable.device = $device
					}
					Else{
						Write-error "The parameter device is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.vsan.storage.list.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('uuid') -or $PSBoundParameters.ContainsKey('device')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.vsan.storage.list.invoke()
				}
			}
		}
	}
}

function remove-EsxCLI.vsan.storage{
<#
.SYNOPSIS
Remove physical disks from VSAN disk groups.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER disk
Specify individual hdd to remove from VSAN usage.e.g.: mpx.vmhba2:C0:T1:L0

.PARAMETER evacuationmode
Action the VSAN service must take before the host can enter maintenance mode (default noAction). Allowed values are:
    ensureObjectAccessibility: Evacuate data from the disk to ensure object accessibility in the VSAN cluster, before removing the disk.
    evacuateAllData: Evacuate all data from the disk before removing it.
    noAction: Do not move VSAN data out of the disk before removing it.

.PARAMETER ssd
Specify a disk group's fronting ssd to remove the ssd and each backing hdd from VSAN usage.e.g.: mpx.vmhba2:C0:T1:L0

.PARAMETER uuid
Specify UUID of VSAN disk.e.g.: 52afa1de-4240-d5d6-17f9-8af1ec8509e5

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$ssd,
	[string]$disk,
	[string]$uuid,
	[string]$evacuationmode,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.storage.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.storage.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.vsan.storage.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.vsan.storage.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('ssd')){
					if($HashTable.containskey('ssd')){
						$HashTable.ssd = $ssd
					}
					Else{
						Write-error "The parameter ssd is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('disk')){
					if($HashTable.containskey('disk')){
						$HashTable.disk = $disk
					}
					Else{
						Write-error "The parameter disk is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('uuid')){
					if($HashTable.containskey('uuid')){
						$HashTable.uuid = $uuid
					}
					Else{
						Write-error "The parameter uuid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('evacuationmode')){
					if($HashTable.containskey('evacuationmode')){
						$HashTable.evacuationmode = $evacuationmode
					}
					Else{
						Write-error "The parameter evacuationmode is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.vsan.storage.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('ssd') -or $PSBoundParameters.ContainsKey('disk') -or $PSBoundParameters.ContainsKey('uuid') -or $PSBoundParameters.ContainsKey('evacuationmode')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.vsan.storage.remove.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.vsan.storage.automode{
<#
.SYNOPSIS
Get status of storage auto claim mode.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.storage.automode.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.storage.automode.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.vsan.storage.automode.get.invoke()
		}
	}
}

function set-EsxCLI.vsan.storage.automode{
<#
.SYNOPSIS
Configure storage auto claim mode

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER enabled
Changing this value to true will result in enabling auto disk claim mode. Disks will be claimed by the VSAN service in next storage event, e.g.: adapter rescan and disk hot-plug. Set to false to disable storage auto claim mode.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[boolean]$enabled,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.storage.automode.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.storage.automode.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.vsan.storage.automode.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.vsan.storage.automode.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('enabled')){
					if($HashTable.containskey('enabled')){
						$HashTable.enabled = $enabled
					}
					Else{
						Write-error "The parameter enabled is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.vsan.storage.automode.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('enabled')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.vsan.storage.automode.set.invoke()
				}
			}
		}
	}
}

function mount-EsxCLI.vsan.storage.diskgroup{
<#
.SYNOPSIS
Mount a VSAN disk or disk group.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER disk
Specify the disk to mount for use by VSAN.e.g.: mpx.vmhba0:C0:T1:L0

.PARAMETER ssd
Specify a disk group's fronting ssd to mount the ssd and each backing hdd for use by VSAN.e.g.: mpx.vmhba2:C0:T1:L0

.PARAMETER uuid
Specify a VSAN UUID of the disk or fronting ssd to mount for use by VSAN.e.g.: 5291022a-ad03-df90-dd0f-b9f980cc005e

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$ssd,
	[string]$disk,
	[string]$uuid,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.storage.diskgroup.mount){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.storage.diskgroup.mount is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.vsan.storage.diskgroup.mount | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.vsan.storage.diskgroup.mount.CreateArgs()
				if($PSBoundParameters.ContainsKey('ssd')){
					if($HashTable.containskey('ssd')){
						$HashTable.ssd = $ssd
					}
					Else{
						Write-error "The parameter ssd is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('disk')){
					if($HashTable.containskey('disk')){
						$HashTable.disk = $disk
					}
					Else{
						Write-error "The parameter disk is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('uuid')){
					if($HashTable.containskey('uuid')){
						$HashTable.uuid = $uuid
					}
					Else{
						Write-error "The parameter uuid is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.vsan.storage.diskgroup.mount.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('ssd') -or $PSBoundParameters.ContainsKey('disk') -or $PSBoundParameters.ContainsKey('uuid')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.vsan.storage.diskgroup.mount.invoke()
				}
			}
		}
	}
}

function unmount-EsxCLI.vsan.storage.diskgroup{
<#
.SYNOPSIS
Unmount VSAN disk or disk group.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER disk
Specify the hdd to unmount from VSAN usage.e.g.: mpx.vmhba0:C0:T1:L0

.PARAMETER ssd
Specify a disk group's fronting ssd to unmount the ssd and each backing hdd from VSAN usage.e.g.: mpx.vmhba2:C0:T1:L0

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[string]$ssd,
	[string]$disk,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.storage.diskgroup.unmount){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.storage.diskgroup.unmount is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.vsan.storage.diskgroup.unmount | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.vsan.storage.diskgroup.unmount.CreateArgs()
				if($PSBoundParameters.ContainsKey('ssd')){
					if($HashTable.containskey('ssd')){
						$HashTable.ssd = $ssd
					}
					Else{
						Write-error "The parameter ssd is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('disk')){
					if($HashTable.containskey('disk')){
						$HashTable.disk = $disk
					}
					Else{
						Write-error "The parameter disk is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.vsan.storage.diskgroup.unmount.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('ssd') -or $PSBoundParameters.ContainsKey('disk')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.vsan.storage.diskgroup.unmount.invoke()
				}
			}
		}
	}
}

function add-EsxCLI.vsan.storage.tag{
<#
.SYNOPSIS
Add a VSAN storage tag.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER disk
Name of the disk to which the tag should be added.

.PARAMETER tag
Tag to be added to disk. Supported tags are  [capacityFlash].

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$tag,
	[Parameter(Mandatory=$true)]
	[string]$disk,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.storage.tag.add){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.storage.tag.add is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.vsan.storage.tag.add | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.vsan.storage.tag.add.CreateArgs()
				if($PSBoundParameters.ContainsKey('tag')){
					if($HashTable.containskey('tag')){
						$HashTable.tag = $tag
					}
					Else{
						Write-error "The parameter tag is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('disk')){
					if($HashTable.containskey('disk')){
						$HashTable.disk = $disk
					}
					Else{
						Write-error "The parameter disk is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.vsan.storage.tag.add.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('tag') -or $PSBoundParameters.ContainsKey('disk')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.vsan.storage.tag.add.invoke()
				}
			}
		}
	}
}

function remove-EsxCLI.vsan.storage.tag{
<#
.SYNOPSIS
Remove a VSAN storage tag.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER disk
Name of the disk from which the tag should be removed.

.PARAMETER tag
Tag to be removed from disk. Supported tags are  [capacityFlash].

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true)]
	[string]$tag,
	[Parameter(Mandatory=$true)]
	[string]$disk,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.storage.tag.remove){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.storage.tag.remove is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.vsan.storage.tag.remove | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.vsan.storage.tag.remove.CreateArgs()
				if($PSBoundParameters.ContainsKey('tag')){
					if($HashTable.containskey('tag')){
						$HashTable.tag = $tag
					}
					Else{
						Write-error "The parameter tag is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('disk')){
					if($HashTable.containskey('disk')){
						$HashTable.disk = $disk
					}
					Else{
						Write-error "The parameter disk is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.vsan.storage.tag.remove.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('tag') -or $PSBoundParameters.ContainsKey('disk')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.vsan.storage.tag.remove.invoke()
				}
			}
		}
	}
}

function get-EsxCLI.vsan.trace{
<#
.SYNOPSIS
Get the VSAN tracing configuration.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.trace.get){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.trace.get is not available for $(($SelectedVMHost).name)"
		continue
		}

			$esxcliv2.vsan.trace.get.invoke()
		}
	}
}

function set-EsxCLI.vsan.trace{
<#
.SYNOPSIS
Configure VSAN trace. Please note: This command is not thread safe.

.DESCRIPTION
This function provide access via Power-Cli to the esxcli equivalent function.
All parameters and help associated to the original esxcli function are available.
This function is based on the original get-esxcli -v2 PowerCLI cmdlet
A PowerCli VMHost object is a mandatory parameter
It is also possible to pipe VMhost objects to execute this function accross many hosts in one operation

.NOTES
Author: Christophe Calvet
Blog: http://www.thecrazyconsultant.com/get-esxcli_on_steroids

.PARAMETER logtosyslog
Boolean value to enable or disable logging urgent traces to syslog.

.PARAMETER numfiles
Log file rotation for VSAN trace files.

.PARAMETER path
Path to store VSAN trace files.

.PARAMETER reset
When set to true, reset defaults for VSAN trace files.

.PARAMETER size
Maximum size of VSAN trace files in MB.

.PARAMETER VMHost
One or many PowerCli VMHost object

.EXAMPLE
Some examples are available in the blog
#>
	[CmdletBinding()]
	param(
	[boolean]$reset,
	[boolean]$logtosyslog,
	[long]$numfiles,
	[string]$path,
	[long]$size,
	[Parameter(Mandatory=$true,ValueFromPipeline=$true)]
	[VMware.VimAutomation.ViCore.Types.V1.Inventory.VMHost[]]$VMhost
	)
	process{
	foreach($SelectedVMHost in $VMhost){
		Try{
		$esxcliv2 = Get-EsxCLI -VMHost $SelectedVMHost -V2
		}
		Catch{
		Write-error "Not able to get-esxcli for $(($SelectedVMHost).name)"
		continue
		}

		if($esxcliv2.vsan.trace.set){
		#Namespace available for this ESXi host
		}
		Else{
		Write-error "The namespace esxcliv2.vsan.trace.set is not available for $(($SelectedVMHost).name)"
		continue
		}

			if($esxcliv2.vsan.trace.set | gm | where {$_.Name -eq 'CreateArgs'}){
			#To anticipate scenario with commands that didn't have any parameters in a previous build
			#More details about this challenge in the blog
			$HashTable = $esxcliv2.vsan.trace.set.CreateArgs()
				if($PSBoundParameters.ContainsKey('reset')){
					if($HashTable.containskey('reset')){
						$HashTable.reset = $reset
					}
					Else{
						Write-error "The parameter reset is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('logtosyslog')){
					if($HashTable.containskey('logtosyslog')){
						$HashTable.logtosyslog = $logtosyslog
					}
					Else{
						Write-error "The parameter logtosyslog is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('numfiles')){
					if($HashTable.containskey('numfiles')){
						$HashTable.numfiles = $numfiles
					}
					Else{
						Write-error "The parameter numfiles is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('path')){
					if($HashTable.containskey('path')){
						$HashTable.path = $path
					}
					Else{
						Write-error "The parameter path is not available for $(($SelectedVMHost).name)"
						continue
					}
				}
				if($PSBoundParameters.ContainsKey('size')){
					if($HashTable.containskey('size')){
						$HashTable.size = $size
					}
					Else{
						Write-error "The parameter size is not available for $(($SelectedVMHost).name)"
						continue
					}
				}

					$esxcliv2.vsan.trace.set.invoke($hashtable)
			}
			Else{
				if($PSBoundParameters.ContainsKey('reset') -or $PSBoundParameters.ContainsKey('logtosyslog') -or $PSBoundParameters.ContainsKey('numfiles') -or $PSBoundParameters.ContainsKey('path') -or $PSBoundParameters.ContainsKey('size')){
					Write-error "No parameters are available for $(($SelectedVMHost).name)"
				}
				Else{
					$esxcliv2.vsan.trace.set.invoke()
				}
			}
		}
	}
}

